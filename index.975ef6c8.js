// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"igKGj":[function(require,module,exports) {
var global = arguments[3];
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "d6ea1d42532a7575";
module.bundle.HMR_BUNDLE_ID = "890e741a975ef6c8";
"use strict";
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE, chrome, browser, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: {|[string]: mixed|};
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
interface ExtensionContext {
  runtime: {|
    reload(): void,
    getURL(url: string): string;
    getManifest(): {manifest_version: number, ...};
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
declare var chrome: ExtensionContext;
declare var browser: ExtensionContext;
declare var __parcel__import__: (string) => Promise<void>;
declare var __parcel__importScripts__: (string) => Promise<void>;
declare var globalThis: typeof self;
declare var ServiceWorkerGlobalScope: Object;
*/ var OVERLAY_ID = "__parcel__error__overlay__";
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData[moduleName],
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(fn) {
            this._acceptCallbacks.push(fn || function() {});
        },
        dispose: function(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData[moduleName] = undefined;
}
module.bundle.Module = Module;
module.bundle.hotData = {};
var checkedAssets /*: {|[string]: boolean|} */ , assetsToDispose /*: Array<[ParcelRequire, string]> */ , assetsToAccept /*: Array<[ParcelRequire, string]> */ ;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf("http") === 0 ? location.hostname : "localhost");
}
function getPort() {
    return HMR_PORT || location.port;
}
// eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== "undefined") {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == "https:" && !/localhost|127.0.0.1|0.0.0.0/.test(hostname) ? "wss" : "ws";
    var ws = new WebSocket(protocol + "://" + hostname + (port ? ":" + port : "") + "/");
    // Web extension context
    var extCtx = typeof chrome === "undefined" ? typeof browser === "undefined" ? null : browser : chrome;
    // Safari doesn't support sourceURL in error stacks.
    // eval may also be disabled via CSP, so do a quick check.
    var supportsSourceURL = false;
    try {
        (0, eval)('throw new Error("test"); //# sourceURL=test.js');
    } catch (err) {
        supportsSourceURL = err.stack.includes("test.js");
    }
    // $FlowFixMe
    ws.onmessage = async function(event /*: {data: string, ...} */ ) {
        checkedAssets = {} /*: {|[string]: boolean|} */ ;
        assetsToAccept = [];
        assetsToDispose = [];
        var data /*: HMRMessage */  = JSON.parse(event.data);
        if (data.type === "update") {
            // Remove error overlay if there is one
            if (typeof document !== "undefined") removeErrorOverlay();
            let assets = data.assets.filter((asset)=>asset.envHash === HMR_ENV_HASH);
            // Handle HMR Update
            let handled = assets.every((asset)=>{
                return asset.type === "css" || asset.type === "js" && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear();
                // Dispatch custom event so other runtimes (e.g React Refresh) are aware.
                if (typeof window !== "undefined" && typeof CustomEvent !== "undefined") window.dispatchEvent(new CustomEvent("parcelhmraccept"));
                await hmrApplyUpdates(assets);
                // Dispose all old assets.
                let processedAssets = {} /*: {|[string]: boolean|} */ ;
                for(let i = 0; i < assetsToDispose.length; i++){
                    let id = assetsToDispose[i][1];
                    if (!processedAssets[id]) {
                        hmrDispose(assetsToDispose[i][0], id);
                        processedAssets[id] = true;
                    }
                }
                // Run accept callbacks. This will also re-execute other disposed assets in topological order.
                processedAssets = {};
                for(let i = 0; i < assetsToAccept.length; i++){
                    let id = assetsToAccept[i][1];
                    if (!processedAssets[id]) {
                        hmrAccept(assetsToAccept[i][0], id);
                        processedAssets[id] = true;
                    }
                }
            } else fullReload();
        }
        if (data.type === "error") {
            // Log parcel errors to console
            for (let ansiDiagnostic of data.diagnostics.ansi){
                let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                console.error("\uD83D\uDEA8 [parcel]: " + ansiDiagnostic.message + "\n" + stack + "\n\n" + ansiDiagnostic.hints.join("\n"));
            }
            if (typeof document !== "undefined") {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html);
                // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    ws.onerror = function(e) {
        console.error(e.message);
    };
    ws.onclose = function() {
        console.warn("[parcel] \uD83D\uDEA8 Connection to the HMR server was lost");
    };
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log("[parcel] ✨ Error resolved");
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement("div");
    overlay.id = OVERLAY_ID;
    let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    for (let diagnostic of diagnostics){
        let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame)=>{
            return `${p}
<a href="/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}" style="text-decoration: underline; color: #888" onclick="fetch(this.href); return false">${frame.location}</a>
${frame.code}`;
        }, "") : diagnostic.stack;
        errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          🚨 ${diagnostic.message}
        </div>
        <pre>${stack}</pre>
        <div>
          ${diagnostic.hints.map((hint)=>"<div>\uD83D\uDCA1 " + hint + "</div>").join("")}
        </div>
        ${diagnostic.documentation ? `<div>📝 <a style="color: violet" href="${diagnostic.documentation}" target="_blank">Learn more</a></div>` : ""}
      </div>
    `;
    }
    errorHTML += "</div>";
    overlay.innerHTML = errorHTML;
    return overlay;
}
function fullReload() {
    if ("reload" in location) location.reload();
    else if (extCtx && extCtx.runtime && extCtx.runtime.reload) extCtx.runtime.reload();
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var href = link.getAttribute("href");
    if (!href) return;
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute("href", // $FlowFixMe
    href.split("?")[0] + "?" + Date.now());
    // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href /*: string */  = links[i].getAttribute("href");
            var hostname = getHostname();
            var servedFromHMRServer = hostname === "localhost" ? new RegExp("^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):" + getPort()).test(href) : href.indexOf(hostname + ":" + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrDownload(asset) {
    if (asset.type === "js") {
        if (typeof document !== "undefined") {
            let script = document.createElement("script");
            script.src = asset.url + "?t=" + Date.now();
            if (asset.outputFormat === "esmodule") script.type = "module";
            return new Promise((resolve, reject)=>{
                var _document$head;
                script.onload = ()=>resolve(script);
                script.onerror = reject;
                (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);
            });
        } else if (typeof importScripts === "function") {
            // Worker scripts
            if (asset.outputFormat === "esmodule") return import(asset.url + "?t=" + Date.now());
            else return new Promise((resolve, reject)=>{
                try {
                    importScripts(asset.url + "?t=" + Date.now());
                    resolve();
                } catch (err) {
                    reject(err);
                }
            });
        }
    }
}
async function hmrApplyUpdates(assets) {
    global.parcelHotUpdate = Object.create(null);
    let scriptsToRemove;
    try {
        // If sourceURL comments aren't supported in eval, we need to load
        // the update from the dev server over HTTP so that stack traces
        // are correct in errors/logs. This is much slower than eval, so
        // we only do it if needed (currently just Safari).
        // https://bugs.webkit.org/show_bug.cgi?id=137297
        // This path is also taken if a CSP disallows eval.
        if (!supportsSourceURL) {
            let promises = assets.map((asset)=>{
                var _hmrDownload;
                return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch((err)=>{
                    // Web extension bugfix for Chromium
                    // https://bugs.chromium.org/p/chromium/issues/detail?id=1255412#c12
                    if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3) {
                        if (typeof ServiceWorkerGlobalScope != "undefined" && global instanceof ServiceWorkerGlobalScope) {
                            extCtx.runtime.reload();
                            return;
                        }
                        asset.url = extCtx.runtime.getURL("/__parcel_hmr_proxy__?url=" + encodeURIComponent(asset.url + "?t=" + Date.now()));
                        return hmrDownload(asset);
                    }
                    throw err;
                });
            });
            scriptsToRemove = await Promise.all(promises);
        }
        assets.forEach(function(asset) {
            hmrApply(module.bundle.root, asset);
        });
    } finally{
        delete global.parcelHotUpdate;
        if (scriptsToRemove) scriptsToRemove.forEach((script)=>{
            if (script) {
                var _document$head2;
                (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);
            }
        });
    }
}
function hmrApply(bundle /*: ParcelRequire */ , asset /*:  HMRAsset */ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === "css") reloadCSS();
    else if (asset.type === "js") {
        let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                let oldDeps = modules[asset.id][1];
                for(let dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    let id = oldDeps[dep];
                    let parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            if (supportsSourceURL) // Global eval. We would use `new Function` here but browser
            // support for source maps is better with eval.
            (0, eval)(asset.output);
            // $FlowFixMe
            let fn = global.parcelHotUpdate[asset.id];
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id) {
    let modules = bundle.modules;
    if (!modules) return;
    if (modules[id]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        let deps = modules[id][1];
        let orphans = [];
        for(let dep in deps){
            let parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        }
        // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id];
        delete bundle.cache[id];
        // Now delete the orphans.
        orphans.forEach((id)=>{
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id);
}
function hmrAcceptCheck(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
    // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    let parents = getParents(module.bundle.root, id);
    let accepted = false;
    while(parents.length > 0){
        let v = parents.shift();
        let a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else {
            // Otherwise, queue the parents in the next level upward.
            let p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push(...p);
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToDispose.push([
        bundle,
        id
    ]);
    if (!cached || cached.hot && cached.hot._acceptCallbacks.length) {
        assetsToAccept.push([
            bundle,
            id
        ]);
        return true;
    }
}
function hmrDispose(bundle /*: ParcelRequire */ , id /*: string */ ) {
    var cached = bundle.cache[id];
    bundle.hotData[id] = {};
    if (cached && cached.hot) cached.hot.data = bundle.hotData[id];
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData[id]);
    });
    delete bundle.cache[id];
}
function hmrAccept(bundle /*: ParcelRequire */ , id /*: string */ ) {
    // Execute the module.
    bundle(id);
    // Run the accept callbacks in the new version of the module.
    var cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) {
            assetsToAlsoAccept.forEach(function(a) {
                hmrDispose(a[0], a[1]);
            });
            // $FlowFixMe[method-unbinding]
            assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
        }
    });
}

},{}],"8lqZg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
var _xterm = require("xterm");
var _xtermAddonAttach = require("xterm-addon-attach");
var _xtermAddonCanvas = require("xterm-addon-canvas");
var _xtermAddonFit = require("xterm-addon-fit");
var _xtermAddonLigatures = require("xterm-addon-ligatures");
var _xtermAddonSearch = require("xterm-addon-search");
var _xtermAddonSerialize = require("xterm-addon-serialize");
var _xtermAddonUnicode11 = require("xterm-addon-unicode11");
var _xtermAddonWebLinks = require("xterm-addon-web-links");
var _xtermAddonWebgl = require("xterm-addon-webgl");
var _confettiJs = require("confetti-js");
var _confettiJsDefault = parcelHelpers.interopDefault(_confettiJs);
const xtermjsTheme = {
    foreground: "#F8F8F8",
    background: "#2D2E2C",
    selectionBackground: "#5DA5D533",
    black: "#1E1E1D",
    brightBlack: "#262625",
    red: "#CE5C5C",
    brightRed: "#FF7272",
    green: "#5BCC5B",
    brightGreen: "#72FF72",
    yellow: "#CCCC5B",
    brightYellow: "#FFFF72",
    blue: "#5D5DD3",
    brightBlue: "#7279FF",
    magenta: "#BC5ED1",
    brightMagenta: "#E572FF",
    cyan: "#5DA5D5",
    brightCyan: "#72F0FF",
    white: "#F8F8F8",
    brightWhite: "#FFFFFF"
};
const protocol = location.protocol === "https:" ? "wss://" : "ws://";
const socketport = "9878";
// socketURL = protocol + location.hostname + ((location.port) ? (':' + location.port) : '') + '/terminals/';
const socketURL = protocol + location.hostname + ":" + socketport;
const terminal = new (0, _xterm.Terminal)({
    cursorBlink: true,
    macOptionIsMeta: true,
    scrollback: true,
    allowProposedApi: true,
    fontFamily: '"FiraCode Nerd Font", "Fira Code", courier-new, courier, monospace, "Powerline Extra Symbols"',
    // theme: xtermjsTheme,
    scrollback: 9999999
});
const webSocket = new WebSocket(socketURL);
// const attachAddon = new AttachAddon(webSocket);
const fitAddon = new (0, _xtermAddonFit.FitAddon)();
const ligaturesAddon = new (0, _xtermAddonLigatures.LigaturesAddon)();
const searchAddon = new (0, _xtermAddonSearch.SearchAddon)();
const serializeAddon = new (0, _xtermAddonSerialize.SerializeAddon)();
const unicode11Addon = new (0, _xtermAddonUnicode11.Unicode11Addon)();
const webgladdon = new (0, _xtermAddonWebgl.WebglAddon)();
let userInput, terminalOutput;
const app = ()=>{
    window.userInput = document.getElementById("userInput");
    terminalOutput = document.getElementById("terminalOutput");
// document.getElementById("dummyKeyboard").focus();
};
terminal.open(document.getElementById("terminalOutput"));
// terminal.loadAddon(attachAddon);
terminal.loadAddon(fitAddon);
terminal.resize(15, 50);
fitAddon.fit();
terminal.loadAddon(new (0, _xtermAddonCanvas.CanvasAddon)());
terminal.loadAddon(ligaturesAddon);
terminal.loadAddon(searchAddon);
// searchAddon.findNext('foo');
terminal.loadAddon(serializeAddon);
terminal.loadAddon(unicode11Addon);
terminal.unicode.activeVersion = "11";
terminal.loadAddon(new (0, _xtermAddonWebLinks.WebLinksAddon)());
webgladdon.onContextLoss((e)=>{
    webgladdon.dispose();
});
terminal.loadAddon(webgladdon);
webSocket.onmessage = function(event) {
    const text = event.data.text().then((text)=>{
        // console.log(text);
        terminal.writeln(text);
    });
}; // terminal.write("something...", () => {
 //   console.log(serializeAddon.serialize());
 // });

},{"xterm":"aEUZq","confetti-js":"jAzui","xterm-addon-attach":"fl6Io","xterm-addon-canvas":"llEjX","xterm-addon-fit":"a5mjI","xterm-addon-ligatures":"4b1al","xterm-addon-search":"eE9w7","xterm-addon-serialize":"gojVV","xterm-addon-unicode11":"7BS3Y","xterm-addon-web-links":"hbPbQ","xterm-addon-webgl":"8OLZt","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aEUZq":[function(require,module,exports) {
!function(e, t) {
    var i, s;
    module.exports = t();
}(self, ()=>(()=>{
        "use strict";
        var e = {
            4567: function(e, t, i) {
                var s = this && this.__decorate || function(e, t, i, s) {
                    var r, n = arguments.length, o = n < 3 ? t : null === s ? s = Object.getOwnPropertyDescriptor(t, i) : s;
                    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, i, s);
                    else for(var a = e.length - 1; a >= 0; a--)(r = e[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(t, i, o) : r(t, i)) || o);
                    return n > 3 && o && Object.defineProperty(t, i, o), o;
                }, r = this && this.__param || function(e, t) {
                    return function(i, s) {
                        t(i, s, e);
                    };
                };
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.AccessibilityManager = void 0;
                const n = i(9042), o = i(6114), a = i(9924), h = i(844), c = i(5596), l = i(4725), d = i(3656);
                let _ = class extends h.Disposable {
                    constructor(e, t){
                        super(), this._terminal = e, this._renderService = t, this._liveRegionLineCount = 0, this._charsToConsume = [], this._charsToAnnounce = "", this._accessibilityContainer = document.createElement("div"), this._accessibilityContainer.classList.add("xterm-accessibility"), this._rowContainer = document.createElement("div"), this._rowContainer.setAttribute("role", "list"), this._rowContainer.classList.add("xterm-accessibility-tree"), this._rowElements = [];
                        for(let e = 0; e < this._terminal.rows; e++)this._rowElements[e] = this._createAccessibilityTreeNode(), this._rowContainer.appendChild(this._rowElements[e]);
                        if (this._topBoundaryFocusListener = (e)=>this._handleBoundaryFocus(e, 0), this._bottomBoundaryFocusListener = (e)=>this._handleBoundaryFocus(e, 1), this._rowElements[0].addEventListener("focus", this._topBoundaryFocusListener), this._rowElements[this._rowElements.length - 1].addEventListener("focus", this._bottomBoundaryFocusListener), this._refreshRowsDimensions(), this._accessibilityContainer.appendChild(this._rowContainer), this._liveRegion = document.createElement("div"), this._liveRegion.classList.add("live-region"), this._liveRegion.setAttribute("aria-live", "assertive"), this._accessibilityContainer.appendChild(this._liveRegion), this._liveRegionDebouncer = this.register(new a.TimeBasedDebouncer(this._announceCharacters.bind(this))), !this._terminal.element) throw new Error("Cannot enable accessibility before Terminal.open");
                        this._terminal.element.insertAdjacentElement("afterbegin", this._accessibilityContainer), this.register(this._liveRegionDebouncer), this.register(this._terminal.onResize((e)=>this._handleResize(e.rows))), this.register(this._terminal.onRender((e)=>this._refreshRows(e.start, e.end))), this.register(this._terminal.onScroll(()=>this._refreshRows())), this.register(this._terminal.onA11yChar((e)=>this._handleChar(e))), this.register(this._terminal.onLineFeed(()=>this._handleChar("\n"))), this.register(this._terminal.onA11yTab((e)=>this._handleTab(e))), this.register(this._terminal.onKey((e)=>this._handleKey(e.key))), this.register(this._terminal.onBlur(()=>this._clearLiveRegion())), this.register(this._renderService.onDimensionsChange(()=>this._refreshRowsDimensions())), this._screenDprMonitor = new c.ScreenDprMonitor(window), this.register(this._screenDprMonitor), this._screenDprMonitor.setListener(()=>this._refreshRowsDimensions()), this.register((0, d.addDisposableDomListener)(window, "resize", ()=>this._refreshRowsDimensions())), this._refreshRows(), this.register((0, h.toDisposable)(()=>{
                            this._accessibilityContainer.remove(), this._rowElements.length = 0;
                        }));
                    }
                    _handleTab(e) {
                        for(let t = 0; t < e; t++)this._handleChar(" ");
                    }
                    _handleChar(e) {
                        this._liveRegionLineCount < 21 && (this._charsToConsume.length > 0 ? this._charsToConsume.shift() !== e && (this._charsToAnnounce += e) : this._charsToAnnounce += e, "\n" === e && (this._liveRegionLineCount++, 21 === this._liveRegionLineCount && (this._liveRegion.textContent += n.tooMuchOutput)), o.isMac && this._liveRegion.textContent && this._liveRegion.textContent.length > 0 && !this._liveRegion.parentNode && setTimeout(()=>{
                            this._accessibilityContainer.appendChild(this._liveRegion);
                        }, 0));
                    }
                    _clearLiveRegion() {
                        this._liveRegion.textContent = "", this._liveRegionLineCount = 0, o.isMac && this._liveRegion.remove();
                    }
                    _handleKey(e) {
                        this._clearLiveRegion(), /\p{Control}/u.test(e) || this._charsToConsume.push(e);
                    }
                    _refreshRows(e, t) {
                        this._liveRegionDebouncer.refresh(e, t, this._terminal.rows);
                    }
                    _announceCharacters() {
                        0 !== this._charsToAnnounce.length && (this._liveRegion.textContent += this._charsToAnnounce, this._charsToAnnounce = "");
                    }
                    _handleBoundaryFocus(e, t) {
                        const i = e.target, s = this._rowElements[0 === t ? 1 : this._rowElements.length - 2];
                        if (i.getAttribute("aria-posinset") === (0 === t ? "1" : `${this._terminal.buffer.lines.length}`)) return;
                        if (e.relatedTarget !== s) return;
                        let r, n;
                        if (0 === t ? (r = i, n = this._rowElements.pop(), this._rowContainer.removeChild(n)) : (r = this._rowElements.shift(), n = i, this._rowContainer.removeChild(r)), r.removeEventListener("focus", this._topBoundaryFocusListener), n.removeEventListener("focus", this._bottomBoundaryFocusListener), 0 === t) {
                            const e = this._createAccessibilityTreeNode();
                            this._rowElements.unshift(e), this._rowContainer.insertAdjacentElement("afterbegin", e);
                        } else {
                            const e = this._createAccessibilityTreeNode();
                            this._rowElements.push(e), this._rowContainer.appendChild(e);
                        }
                        this._rowElements[0].addEventListener("focus", this._topBoundaryFocusListener), this._rowElements[this._rowElements.length - 1].addEventListener("focus", this._bottomBoundaryFocusListener), this._terminal.scrollLines(0 === t ? -1 : 1), this._rowElements[0 === t ? 1 : this._rowElements.length - 2].focus(), e.preventDefault(), e.stopImmediatePropagation();
                    }
                    _handleResize(e) {
                        this._rowElements[this._rowElements.length - 1].removeEventListener("focus", this._bottomBoundaryFocusListener);
                        for(let e = this._rowContainer.children.length; e < this._terminal.rows; e++)this._rowElements[e] = this._createAccessibilityTreeNode(), this._rowContainer.appendChild(this._rowElements[e]);
                        for(; this._rowElements.length > e;)this._rowContainer.removeChild(this._rowElements.pop());
                        this._rowElements[this._rowElements.length - 1].addEventListener("focus", this._bottomBoundaryFocusListener), this._refreshRowsDimensions();
                    }
                    _createAccessibilityTreeNode() {
                        const e = document.createElement("div");
                        return e.setAttribute("role", "listitem"), e.tabIndex = -1, this._refreshRowDimensions(e), e;
                    }
                    _refreshRowsDimensions() {
                        if (this._renderService.dimensions.css.cell.height) {
                            this._accessibilityContainer.style.width = `${this._renderService.dimensions.css.canvas.width}px`, this._rowElements.length !== this._terminal.rows && this._handleResize(this._terminal.rows);
                            for(let e = 0; e < this._terminal.rows; e++)this._refreshRowDimensions(this._rowElements[e]);
                        }
                    }
                    _refreshRowDimensions(e) {
                        e.style.height = `${this._renderService.dimensions.css.cell.height}px`;
                    }
                };
                _ = s([
                    r(1, l.IRenderService)
                ], _), t.AccessibilityManager = _;
            },
            3614: (e, t)=>{
                function i(e) {
                    return e.replace(/\r?\n/g, "\r");
                }
                function s(e, t) {
                    return t ? "\x1b[200~" + e + "\x1b[201~" : e;
                }
                function r(e, t, r) {
                    e = s(e = i(e), r.decPrivateModes.bracketedPasteMode), r.triggerDataEvent(e, !0), t.value = "";
                }
                function n(e, t, i) {
                    const s = i.getBoundingClientRect(), r = e.clientX - s.left - 10, n = e.clientY - s.top - 10;
                    t.style.width = "20px", t.style.height = "20px", t.style.left = `${r}px`, t.style.top = `${n}px`, t.style.zIndex = "1000", t.focus();
                }
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.rightClickHandler = t.moveTextAreaUnderMouseCursor = t.paste = t.handlePasteEvent = t.copyHandler = t.bracketTextForPaste = t.prepareTextForTerminal = void 0, t.prepareTextForTerminal = i, t.bracketTextForPaste = s, t.copyHandler = function(e, t) {
                    e.clipboardData && e.clipboardData.setData("text/plain", t.selectionText), e.preventDefault();
                }, t.handlePasteEvent = function(e, t, i) {
                    e.stopPropagation(), e.clipboardData && r(e.clipboardData.getData("text/plain"), t, i);
                }, t.paste = r, t.moveTextAreaUnderMouseCursor = n, t.rightClickHandler = function(e, t, i, s, r) {
                    n(e, t, i), r && s.rightClickSelect(e), t.value = s.selectionText, t.select();
                };
            },
            7239: (e, t, i)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.ColorContrastCache = void 0;
                const s = i(1505);
                t.ColorContrastCache = class {
                    constructor(){
                        this._color = new s.TwoKeyMap, this._css = new s.TwoKeyMap;
                    }
                    setCss(e, t, i) {
                        this._css.set(e, t, i);
                    }
                    getCss(e, t) {
                        return this._css.get(e, t);
                    }
                    setColor(e, t, i) {
                        this._color.set(e, t, i);
                    }
                    getColor(e, t) {
                        return this._color.get(e, t);
                    }
                    clear() {
                        this._color.clear(), this._css.clear();
                    }
                };
            },
            3656: (e, t)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.addDisposableDomListener = void 0, t.addDisposableDomListener = function(e, t, i, s) {
                    e.addEventListener(t, i, s);
                    let r = !1;
                    return {
                        dispose: ()=>{
                            r || (r = !0, e.removeEventListener(t, i, s));
                        }
                    };
                };
            },
            6465: function(e, t, i) {
                var s = this && this.__decorate || function(e, t, i, s) {
                    var r, n = arguments.length, o = n < 3 ? t : null === s ? s = Object.getOwnPropertyDescriptor(t, i) : s;
                    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, i, s);
                    else for(var a = e.length - 1; a >= 0; a--)(r = e[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(t, i, o) : r(t, i)) || o);
                    return n > 3 && o && Object.defineProperty(t, i, o), o;
                }, r = this && this.__param || function(e, t) {
                    return function(i, s) {
                        t(i, s, e);
                    };
                };
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.Linkifier2 = void 0;
                const n = i(2585), o = i(8460), a = i(844), h = i(3656);
                let c = class extends a.Disposable {
                    constructor(e){
                        super(), this._bufferService = e, this._linkProviders = [], this._linkCacheDisposables = [], this._isMouseOut = !0, this._wasResized = !1, this._activeLine = -1, this._onShowLinkUnderline = this.register(new o.EventEmitter), this.onShowLinkUnderline = this._onShowLinkUnderline.event, this._onHideLinkUnderline = this.register(new o.EventEmitter), this.onHideLinkUnderline = this._onHideLinkUnderline.event, this.register((0, a.getDisposeArrayDisposable)(this._linkCacheDisposables)), this.register((0, a.toDisposable)(()=>{
                            this._lastMouseEvent = void 0;
                        })), this.register(this._bufferService.onResize(()=>{
                            this._clearCurrentLink(), this._wasResized = !0;
                        }));
                    }
                    get currentLink() {
                        return this._currentLink;
                    }
                    registerLinkProvider(e) {
                        return this._linkProviders.push(e), {
                            dispose: ()=>{
                                const t = this._linkProviders.indexOf(e);
                                -1 !== t && this._linkProviders.splice(t, 1);
                            }
                        };
                    }
                    attachToDom(e, t, i) {
                        this._element = e, this._mouseService = t, this._renderService = i, this.register((0, h.addDisposableDomListener)(this._element, "mouseleave", ()=>{
                            this._isMouseOut = !0, this._clearCurrentLink();
                        })), this.register((0, h.addDisposableDomListener)(this._element, "mousemove", this._handleMouseMove.bind(this))), this.register((0, h.addDisposableDomListener)(this._element, "mousedown", this._handleMouseDown.bind(this))), this.register((0, h.addDisposableDomListener)(this._element, "mouseup", this._handleMouseUp.bind(this)));
                    }
                    _handleMouseMove(e) {
                        if (this._lastMouseEvent = e, !this._element || !this._mouseService) return;
                        const t = this._positionFromMouseEvent(e, this._element, this._mouseService);
                        if (!t) return;
                        this._isMouseOut = !1;
                        const i = e.composedPath();
                        for(let e = 0; e < i.length; e++){
                            const t = i[e];
                            if (t.classList.contains("xterm")) break;
                            if (t.classList.contains("xterm-hover")) return;
                        }
                        this._lastBufferCell && t.x === this._lastBufferCell.x && t.y === this._lastBufferCell.y || (this._handleHover(t), this._lastBufferCell = t);
                    }
                    _handleHover(e) {
                        if (this._activeLine !== e.y || this._wasResized) return this._clearCurrentLink(), this._askForLink(e, !1), void (this._wasResized = !1);
                        this._currentLink && this._linkAtPosition(this._currentLink.link, e) || (this._clearCurrentLink(), this._askForLink(e, !0));
                    }
                    _askForLink(e, t) {
                        var i, s;
                        this._activeProviderReplies && t || (null === (i = this._activeProviderReplies) || void 0 === i || i.forEach((e)=>{
                            null == e || e.forEach((e)=>{
                                e.link.dispose && e.link.dispose();
                            });
                        }), this._activeProviderReplies = new Map, this._activeLine = e.y);
                        let r = !1;
                        for (const [i, n] of this._linkProviders.entries())t ? (null === (s = this._activeProviderReplies) || void 0 === s ? void 0 : s.get(i)) && (r = this._checkLinkProviderResult(i, e, r)) : n.provideLinks(e.y, (t)=>{
                            var s, n;
                            if (this._isMouseOut) return;
                            const o = null == t ? void 0 : t.map((e)=>({
                                    link: e
                                }));
                            null === (s = this._activeProviderReplies) || void 0 === s || s.set(i, o), r = this._checkLinkProviderResult(i, e, r), (null === (n = this._activeProviderReplies) || void 0 === n ? void 0 : n.size) === this._linkProviders.length && this._removeIntersectingLinks(e.y, this._activeProviderReplies);
                        });
                    }
                    _removeIntersectingLinks(e, t) {
                        const i = new Set;
                        for(let s = 0; s < t.size; s++){
                            const r = t.get(s);
                            if (r) for(let t = 0; t < r.length; t++){
                                const s = r[t], n = s.link.range.start.y < e ? 0 : s.link.range.start.x, o = s.link.range.end.y > e ? this._bufferService.cols : s.link.range.end.x;
                                for(let e = n; e <= o; e++){
                                    if (i.has(e)) {
                                        r.splice(t--, 1);
                                        break;
                                    }
                                    i.add(e);
                                }
                            }
                        }
                    }
                    _checkLinkProviderResult(e, t, i) {
                        var s;
                        if (!this._activeProviderReplies) return i;
                        const r = this._activeProviderReplies.get(e);
                        let n = !1;
                        for(let t = 0; t < e; t++)this._activeProviderReplies.has(t) && !this._activeProviderReplies.get(t) || (n = !0);
                        if (!n && r) {
                            const e = r.find((e)=>this._linkAtPosition(e.link, t));
                            e && (i = !0, this._handleNewLink(e));
                        }
                        if (this._activeProviderReplies.size === this._linkProviders.length && !i) for(let e = 0; e < this._activeProviderReplies.size; e++){
                            const r = null === (s = this._activeProviderReplies.get(e)) || void 0 === s ? void 0 : s.find((e)=>this._linkAtPosition(e.link, t));
                            if (r) {
                                i = !0, this._handleNewLink(r);
                                break;
                            }
                        }
                        return i;
                    }
                    _handleMouseDown() {
                        this._mouseDownLink = this._currentLink;
                    }
                    _handleMouseUp(e) {
                        if (!this._element || !this._mouseService || !this._currentLink) return;
                        const t = this._positionFromMouseEvent(e, this._element, this._mouseService);
                        t && this._mouseDownLink === this._currentLink && this._linkAtPosition(this._currentLink.link, t) && this._currentLink.link.activate(e, this._currentLink.link.text);
                    }
                    _clearCurrentLink(e, t) {
                        this._element && this._currentLink && this._lastMouseEvent && (!e || !t || this._currentLink.link.range.start.y >= e && this._currentLink.link.range.end.y <= t) && (this._linkLeave(this._element, this._currentLink.link, this._lastMouseEvent), this._currentLink = void 0, (0, a.disposeArray)(this._linkCacheDisposables));
                    }
                    _handleNewLink(e) {
                        if (!this._element || !this._lastMouseEvent || !this._mouseService) return;
                        const t = this._positionFromMouseEvent(this._lastMouseEvent, this._element, this._mouseService);
                        t && this._linkAtPosition(e.link, t) && (this._currentLink = e, this._currentLink.state = {
                            decorations: {
                                underline: void 0 === e.link.decorations || e.link.decorations.underline,
                                pointerCursor: void 0 === e.link.decorations || e.link.decorations.pointerCursor
                            },
                            isHovered: !0
                        }, this._linkHover(this._element, e.link, this._lastMouseEvent), e.link.decorations = {}, Object.defineProperties(e.link.decorations, {
                            pointerCursor: {
                                get: ()=>{
                                    var e, t;
                                    return null === (t = null === (e = this._currentLink) || void 0 === e ? void 0 : e.state) || void 0 === t ? void 0 : t.decorations.pointerCursor;
                                },
                                set: (e)=>{
                                    var t, i;
                                    (null === (t = this._currentLink) || void 0 === t ? void 0 : t.state) && this._currentLink.state.decorations.pointerCursor !== e && (this._currentLink.state.decorations.pointerCursor = e, this._currentLink.state.isHovered && (null === (i = this._element) || void 0 === i || i.classList.toggle("xterm-cursor-pointer", e)));
                                }
                            },
                            underline: {
                                get: ()=>{
                                    var e, t;
                                    return null === (t = null === (e = this._currentLink) || void 0 === e ? void 0 : e.state) || void 0 === t ? void 0 : t.decorations.underline;
                                },
                                set: (t)=>{
                                    var i, s, r;
                                    (null === (i = this._currentLink) || void 0 === i ? void 0 : i.state) && (null === (r = null === (s = this._currentLink) || void 0 === s ? void 0 : s.state) || void 0 === r ? void 0 : r.decorations.underline) !== t && (this._currentLink.state.decorations.underline = t, this._currentLink.state.isHovered && this._fireUnderlineEvent(e.link, t));
                                }
                            }
                        }), this._renderService && this._linkCacheDisposables.push(this._renderService.onRenderedViewportChange((e)=>{
                            if (!this._currentLink) return;
                            const t = 0 === e.start ? 0 : e.start + 1 + this._bufferService.buffer.ydisp, i = this._bufferService.buffer.ydisp + 1 + e.end;
                            if (this._currentLink.link.range.start.y >= t && this._currentLink.link.range.end.y <= i && (this._clearCurrentLink(t, i), this._lastMouseEvent && this._element)) {
                                const e = this._positionFromMouseEvent(this._lastMouseEvent, this._element, this._mouseService);
                                e && this._askForLink(e, !1);
                            }
                        })));
                    }
                    _linkHover(e, t, i) {
                        var s;
                        (null === (s = this._currentLink) || void 0 === s ? void 0 : s.state) && (this._currentLink.state.isHovered = !0, this._currentLink.state.decorations.underline && this._fireUnderlineEvent(t, !0), this._currentLink.state.decorations.pointerCursor && e.classList.add("xterm-cursor-pointer")), t.hover && t.hover(i, t.text);
                    }
                    _fireUnderlineEvent(e, t) {
                        const i = e.range, s = this._bufferService.buffer.ydisp, r = this._createLinkUnderlineEvent(i.start.x - 1, i.start.y - s - 1, i.end.x, i.end.y - s - 1, void 0);
                        (t ? this._onShowLinkUnderline : this._onHideLinkUnderline).fire(r);
                    }
                    _linkLeave(e, t, i) {
                        var s;
                        (null === (s = this._currentLink) || void 0 === s ? void 0 : s.state) && (this._currentLink.state.isHovered = !1, this._currentLink.state.decorations.underline && this._fireUnderlineEvent(t, !1), this._currentLink.state.decorations.pointerCursor && e.classList.remove("xterm-cursor-pointer")), t.leave && t.leave(i, t.text);
                    }
                    _linkAtPosition(e, t) {
                        const i = e.range.start.y * this._bufferService.cols + e.range.start.x, s = e.range.end.y * this._bufferService.cols + e.range.end.x, r = t.y * this._bufferService.cols + t.x;
                        return i <= r && r <= s;
                    }
                    _positionFromMouseEvent(e, t, i) {
                        const s = i.getCoords(e, t, this._bufferService.cols, this._bufferService.rows);
                        if (s) return {
                            x: s[0],
                            y: s[1] + this._bufferService.buffer.ydisp
                        };
                    }
                    _createLinkUnderlineEvent(e, t, i, s, r) {
                        return {
                            x1: e,
                            y1: t,
                            x2: i,
                            y2: s,
                            cols: this._bufferService.cols,
                            fg: r
                        };
                    }
                };
                c = s([
                    r(0, n.IBufferService)
                ], c), t.Linkifier2 = c;
            },
            9042: (e, t)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.tooMuchOutput = t.promptLabel = void 0, t.promptLabel = "Terminal input", t.tooMuchOutput = "Too much output to announce, navigate to rows manually to read";
            },
            3730: function(e, t, i) {
                var s = this && this.__decorate || function(e, t, i, s) {
                    var r, n = arguments.length, o = n < 3 ? t : null === s ? s = Object.getOwnPropertyDescriptor(t, i) : s;
                    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, i, s);
                    else for(var a = e.length - 1; a >= 0; a--)(r = e[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(t, i, o) : r(t, i)) || o);
                    return n > 3 && o && Object.defineProperty(t, i, o), o;
                }, r = this && this.__param || function(e, t) {
                    return function(i, s) {
                        t(i, s, e);
                    };
                };
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.OscLinkProvider = void 0;
                const n = i(511), o = i(2585);
                let a = class {
                    constructor(e, t, i){
                        this._bufferService = e, this._optionsService = t, this._oscLinkService = i;
                    }
                    provideLinks(e, t) {
                        var i;
                        const s = this._bufferService.buffer.lines.get(e - 1);
                        if (!s) return void t(void 0);
                        const r = [], o = this._optionsService.rawOptions.linkHandler, a = new n.CellData, c = s.getTrimmedLength();
                        let l = -1, d = -1, _ = !1;
                        for(let t = 0; t < c; t++)if (-1 !== d || s.hasContent(t)) {
                            if (s.loadCell(t, a), a.hasExtendedAttrs() && a.extended.urlId) {
                                if (-1 === d) {
                                    d = t, l = a.extended.urlId;
                                    continue;
                                }
                                _ = a.extended.urlId !== l;
                            } else -1 !== d && (_ = !0);
                            if (_ || -1 !== d && t === c - 1) {
                                const s = null === (i = this._oscLinkService.getLinkData(l)) || void 0 === i ? void 0 : i.uri;
                                if (s) {
                                    const i = {
                                        start: {
                                            x: d + 1,
                                            y: e
                                        },
                                        end: {
                                            x: t + (_ || t !== c - 1 ? 0 : 1),
                                            y: e
                                        }
                                    };
                                    let n = !1;
                                    if (!(null == o ? void 0 : o.allowNonHttpProtocols)) try {
                                        const e = new URL(s);
                                        [
                                            "http:",
                                            "https:"
                                        ].includes(e.protocol) || (n = !0);
                                    } catch (e) {
                                        n = !0;
                                    }
                                    n || r.push({
                                        text: s,
                                        range: i,
                                        activate: (e, t)=>o ? o.activate(e, t, i) : h(0, t),
                                        hover: (e, t)=>{
                                            var s;
                                            return null === (s = null == o ? void 0 : o.hover) || void 0 === s ? void 0 : s.call(o, e, t, i);
                                        },
                                        leave: (e, t)=>{
                                            var s;
                                            return null === (s = null == o ? void 0 : o.leave) || void 0 === s ? void 0 : s.call(o, e, t, i);
                                        }
                                    });
                                }
                                _ = !1, a.hasExtendedAttrs() && a.extended.urlId ? (d = t, l = a.extended.urlId) : (d = -1, l = -1);
                            }
                        }
                        t(r);
                    }
                };
                function h(e, t) {
                    if (confirm(`Do you want to navigate to ${t}?\n\nWARNING: This link could potentially be dangerous`)) {
                        const e = window.open();
                        if (e) {
                            try {
                                e.opener = null;
                            } catch (e) {}
                            e.location.href = t;
                        } else console.warn("Opening link blocked as opener could not be cleared");
                    }
                }
                a = s([
                    r(0, o.IBufferService),
                    r(1, o.IOptionsService),
                    r(2, o.IOscLinkService)
                ], a), t.OscLinkProvider = a;
            },
            6193: (e, t)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.RenderDebouncer = void 0, t.RenderDebouncer = class {
                    constructor(e, t){
                        this._parentWindow = e, this._renderCallback = t, this._refreshCallbacks = [];
                    }
                    dispose() {
                        this._animationFrame && (this._parentWindow.cancelAnimationFrame(this._animationFrame), this._animationFrame = void 0);
                    }
                    addRefreshCallback(e) {
                        return this._refreshCallbacks.push(e), this._animationFrame || (this._animationFrame = this._parentWindow.requestAnimationFrame(()=>this._innerRefresh())), this._animationFrame;
                    }
                    refresh(e, t, i) {
                        this._rowCount = i, e = void 0 !== e ? e : 0, t = void 0 !== t ? t : this._rowCount - 1, this._rowStart = void 0 !== this._rowStart ? Math.min(this._rowStart, e) : e, this._rowEnd = void 0 !== this._rowEnd ? Math.max(this._rowEnd, t) : t, this._animationFrame || (this._animationFrame = this._parentWindow.requestAnimationFrame(()=>this._innerRefresh()));
                    }
                    _innerRefresh() {
                        if (this._animationFrame = void 0, void 0 === this._rowStart || void 0 === this._rowEnd || void 0 === this._rowCount) return void this._runRefreshCallbacks();
                        const e = Math.max(this._rowStart, 0), t = Math.min(this._rowEnd, this._rowCount - 1);
                        this._rowStart = void 0, this._rowEnd = void 0, this._renderCallback(e, t), this._runRefreshCallbacks();
                    }
                    _runRefreshCallbacks() {
                        for (const e of this._refreshCallbacks)e(0);
                        this._refreshCallbacks = [];
                    }
                };
            },
            5596: (e, t, i)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.ScreenDprMonitor = void 0;
                const s = i(844);
                class r extends s.Disposable {
                    constructor(e){
                        super(), this._parentWindow = e, this._currentDevicePixelRatio = this._parentWindow.devicePixelRatio, this.register((0, s.toDisposable)(()=>{
                            this.clearListener();
                        }));
                    }
                    setListener(e) {
                        this._listener && this.clearListener(), this._listener = e, this._outerListener = ()=>{
                            this._listener && (this._listener(this._parentWindow.devicePixelRatio, this._currentDevicePixelRatio), this._updateDpr());
                        }, this._updateDpr();
                    }
                    _updateDpr() {
                        var e;
                        this._outerListener && (null === (e = this._resolutionMediaMatchList) || void 0 === e || e.removeListener(this._outerListener), this._currentDevicePixelRatio = this._parentWindow.devicePixelRatio, this._resolutionMediaMatchList = this._parentWindow.matchMedia(`screen and (resolution: ${this._parentWindow.devicePixelRatio}dppx)`), this._resolutionMediaMatchList.addListener(this._outerListener));
                    }
                    clearListener() {
                        this._resolutionMediaMatchList && this._listener && this._outerListener && (this._resolutionMediaMatchList.removeListener(this._outerListener), this._resolutionMediaMatchList = void 0, this._listener = void 0, this._outerListener = void 0);
                    }
                }
                t.ScreenDprMonitor = r;
            },
            3236: (e, t, i)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.Terminal = void 0;
                const s = i(2950), r = i(1680), n = i(3614), o = i(2584), a = i(5435), h = i(9312), c = i(6114), l = i(3656), d = i(9042), _ = i(4567), u = i(1296), f = i(7399), v = i(8460), g = i(8437), p = i(3230), S = i(4725), m = i(428), C = i(8934), b = i(6465), y = i(5114), w = i(8969), E = i(8055), L = i(4269), k = i(5941), R = i(3107), D = i(5744), A = i(9074), x = i(2585), B = i(3730), T = i(844), M = i(6731), O = "undefined" != typeof window ? window.document : null;
                class I extends w.CoreTerminal {
                    constructor(e = {}){
                        super(e), this.browser = c, this._keyDownHandled = !1, this._keyDownSeen = !1, this._keyPressHandled = !1, this._unprocessedDeadKey = !1, this._onCursorMove = this.register(new v.EventEmitter), this.onCursorMove = this._onCursorMove.event, this._onKey = this.register(new v.EventEmitter), this.onKey = this._onKey.event, this._onRender = this.register(new v.EventEmitter), this.onRender = this._onRender.event, this._onSelectionChange = this.register(new v.EventEmitter), this.onSelectionChange = this._onSelectionChange.event, this._onTitleChange = this.register(new v.EventEmitter), this.onTitleChange = this._onTitleChange.event, this._onBell = this.register(new v.EventEmitter), this.onBell = this._onBell.event, this._onFocus = this.register(new v.EventEmitter), this._onBlur = this.register(new v.EventEmitter), this._onA11yCharEmitter = this.register(new v.EventEmitter), this._onA11yTabEmitter = this.register(new v.EventEmitter), this._onWillOpen = this.register(new v.EventEmitter), this._setup(), this.linkifier2 = this.register(this._instantiationService.createInstance(b.Linkifier2)), this.linkifier2.registerLinkProvider(this._instantiationService.createInstance(B.OscLinkProvider)), this._decorationService = this._instantiationService.createInstance(A.DecorationService), this._instantiationService.setService(x.IDecorationService, this._decorationService), this.register(this._inputHandler.onRequestBell(()=>this._onBell.fire())), this.register(this._inputHandler.onRequestRefreshRows((e, t)=>this.refresh(e, t))), this.register(this._inputHandler.onRequestSendFocus(()=>this._reportFocus())), this.register(this._inputHandler.onRequestReset(()=>this.reset())), this.register(this._inputHandler.onRequestWindowsOptionsReport((e)=>this._reportWindowsOptions(e))), this.register(this._inputHandler.onColor((e)=>this._handleColorEvent(e))), this.register((0, v.forwardEvent)(this._inputHandler.onCursorMove, this._onCursorMove)), this.register((0, v.forwardEvent)(this._inputHandler.onTitleChange, this._onTitleChange)), this.register((0, v.forwardEvent)(this._inputHandler.onA11yChar, this._onA11yCharEmitter)), this.register((0, v.forwardEvent)(this._inputHandler.onA11yTab, this._onA11yTabEmitter)), this.register(this._bufferService.onResize((e)=>this._afterResize(e.cols, e.rows))), this.register((0, T.toDisposable)(()=>{
                            var e, t;
                            this._customKeyEventHandler = void 0, null === (t = null === (e = this.element) || void 0 === e ? void 0 : e.parentNode) || void 0 === t || t.removeChild(this.element);
                        }));
                    }
                    get onFocus() {
                        return this._onFocus.event;
                    }
                    get onBlur() {
                        return this._onBlur.event;
                    }
                    get onA11yChar() {
                        return this._onA11yCharEmitter.event;
                    }
                    get onA11yTab() {
                        return this._onA11yTabEmitter.event;
                    }
                    get onWillOpen() {
                        return this._onWillOpen.event;
                    }
                    _handleColorEvent(e) {
                        if (this._themeService) for (const t of e){
                            let e, i = "";
                            switch(t.index){
                                case 256:
                                    e = "foreground", i = "10";
                                    break;
                                case 257:
                                    e = "background", i = "11";
                                    break;
                                case 258:
                                    e = "cursor", i = "12";
                                    break;
                                default:
                                    e = "ansi", i = "4;" + t.index;
                            }
                            switch(t.type){
                                case 0:
                                    const s = E.color.toColorRGB("ansi" === e ? this._themeService.colors.ansi[t.index] : this._themeService.colors[e]);
                                    this.coreService.triggerDataEvent(`${o.C0.ESC}]${i};${(0, k.toRgbString)(s)}${o.C1_ESCAPED.ST}`);
                                    break;
                                case 1:
                                    if ("ansi" === e) this._themeService.modifyColors((e)=>e.ansi[t.index] = E.rgba.toColor(...t.color));
                                    else {
                                        const i = e;
                                        this._themeService.modifyColors((e)=>e[i] = E.rgba.toColor(...t.color));
                                    }
                                    break;
                                case 2:
                                    this._themeService.restoreColor(t.index);
                            }
                        }
                    }
                    _setup() {
                        super._setup(), this._customKeyEventHandler = void 0;
                    }
                    get buffer() {
                        return this.buffers.active;
                    }
                    focus() {
                        this.textarea && this.textarea.focus({
                            preventScroll: !0
                        });
                    }
                    _handleScreenReaderModeOptionChange(e) {
                        var t;
                        e ? !this._accessibilityManager && this._renderService && (this._accessibilityManager = this._instantiationService.createInstance(_.AccessibilityManager, this)) : (null === (t = this._accessibilityManager) || void 0 === t || t.dispose(), this._accessibilityManager = void 0);
                    }
                    _handleTextAreaFocus(e) {
                        this.coreService.decPrivateModes.sendFocus && this.coreService.triggerDataEvent(o.C0.ESC + "[I"), this.updateCursorStyle(e), this.element.classList.add("focus"), this._showCursor(), this._onFocus.fire();
                    }
                    blur() {
                        var e;
                        return null === (e = this.textarea) || void 0 === e ? void 0 : e.blur();
                    }
                    _handleTextAreaBlur() {
                        this.textarea.value = "", this.refresh(this.buffer.y, this.buffer.y), this.coreService.decPrivateModes.sendFocus && this.coreService.triggerDataEvent(o.C0.ESC + "[O"), this.element.classList.remove("focus"), this._onBlur.fire();
                    }
                    _syncTextArea() {
                        if (!this.textarea || !this.buffer.isCursorInViewport || this._compositionHelper.isComposing || !this._renderService) return;
                        const e = this.buffer.ybase + this.buffer.y, t = this.buffer.lines.get(e);
                        if (!t) return;
                        const i = Math.min(this.buffer.x, this.cols - 1), s = this._renderService.dimensions.css.cell.height, r = t.getWidth(i), n = this._renderService.dimensions.css.cell.width * r, o = this.buffer.y * this._renderService.dimensions.css.cell.height, a = i * this._renderService.dimensions.css.cell.width;
                        this.textarea.style.left = a + "px", this.textarea.style.top = o + "px", this.textarea.style.width = n + "px", this.textarea.style.height = s + "px", this.textarea.style.lineHeight = s + "px", this.textarea.style.zIndex = "-5";
                    }
                    _initGlobal() {
                        this._bindKeys(), this.register((0, l.addDisposableDomListener)(this.element, "copy", (e)=>{
                            this.hasSelection() && (0, n.copyHandler)(e, this._selectionService);
                        }));
                        const e = (e)=>(0, n.handlePasteEvent)(e, this.textarea, this.coreService);
                        this.register((0, l.addDisposableDomListener)(this.textarea, "paste", e)), this.register((0, l.addDisposableDomListener)(this.element, "paste", e)), c.isFirefox ? this.register((0, l.addDisposableDomListener)(this.element, "mousedown", (e)=>{
                            2 === e.button && (0, n.rightClickHandler)(e, this.textarea, this.screenElement, this._selectionService, this.options.rightClickSelectsWord);
                        })) : this.register((0, l.addDisposableDomListener)(this.element, "contextmenu", (e)=>{
                            (0, n.rightClickHandler)(e, this.textarea, this.screenElement, this._selectionService, this.options.rightClickSelectsWord);
                        })), c.isLinux && this.register((0, l.addDisposableDomListener)(this.element, "auxclick", (e)=>{
                            1 === e.button && (0, n.moveTextAreaUnderMouseCursor)(e, this.textarea, this.screenElement);
                        }));
                    }
                    _bindKeys() {
                        this.register((0, l.addDisposableDomListener)(this.textarea, "keyup", (e)=>this._keyUp(e), !0)), this.register((0, l.addDisposableDomListener)(this.textarea, "keydown", (e)=>this._keyDown(e), !0)), this.register((0, l.addDisposableDomListener)(this.textarea, "keypress", (e)=>this._keyPress(e), !0)), this.register((0, l.addDisposableDomListener)(this.textarea, "compositionstart", ()=>this._compositionHelper.compositionstart())), this.register((0, l.addDisposableDomListener)(this.textarea, "compositionupdate", (e)=>this._compositionHelper.compositionupdate(e))), this.register((0, l.addDisposableDomListener)(this.textarea, "compositionend", ()=>this._compositionHelper.compositionend())), this.register((0, l.addDisposableDomListener)(this.textarea, "input", (e)=>this._inputEvent(e), !0)), this.register(this.onRender(()=>this._compositionHelper.updateCompositionElements()));
                    }
                    open(e) {
                        var t;
                        if (!e) throw new Error("Terminal requires a parent element.");
                        e.isConnected || this._logService.debug("Terminal.open was called on an element that was not attached to the DOM"), this._document = e.ownerDocument, this.element = this._document.createElement("div"), this.element.dir = "ltr", this.element.classList.add("terminal"), this.element.classList.add("xterm"), e.appendChild(this.element);
                        const i = O.createDocumentFragment();
                        this._viewportElement = O.createElement("div"), this._viewportElement.classList.add("xterm-viewport"), i.appendChild(this._viewportElement), this._viewportScrollArea = O.createElement("div"), this._viewportScrollArea.classList.add("xterm-scroll-area"), this._viewportElement.appendChild(this._viewportScrollArea), this.screenElement = O.createElement("div"), this.screenElement.classList.add("xterm-screen"), this._helperContainer = O.createElement("div"), this._helperContainer.classList.add("xterm-helpers"), this.screenElement.appendChild(this._helperContainer), i.appendChild(this.screenElement), this.textarea = O.createElement("textarea"), this.textarea.classList.add("xterm-helper-textarea"), this.textarea.setAttribute("aria-label", d.promptLabel), c.isChromeOS || this.textarea.setAttribute("aria-multiline", "false"), this.textarea.setAttribute("autocorrect", "off"), this.textarea.setAttribute("autocapitalize", "off"), this.textarea.setAttribute("spellcheck", "false"), this.textarea.tabIndex = 0, this._coreBrowserService = this._instantiationService.createInstance(y.CoreBrowserService, this.textarea, null !== (t = this._document.defaultView) && void 0 !== t ? t : window), this._instantiationService.setService(S.ICoreBrowserService, this._coreBrowserService), this.register((0, l.addDisposableDomListener)(this.textarea, "focus", (e)=>this._handleTextAreaFocus(e))), this.register((0, l.addDisposableDomListener)(this.textarea, "blur", ()=>this._handleTextAreaBlur())), this._helperContainer.appendChild(this.textarea), this._charSizeService = this._instantiationService.createInstance(m.CharSizeService, this._document, this._helperContainer), this._instantiationService.setService(S.ICharSizeService, this._charSizeService), this._themeService = this._instantiationService.createInstance(M.ThemeService), this._instantiationService.setService(S.IThemeService, this._themeService), this._characterJoinerService = this._instantiationService.createInstance(L.CharacterJoinerService), this._instantiationService.setService(S.ICharacterJoinerService, this._characterJoinerService), this._renderService = this.register(this._instantiationService.createInstance(p.RenderService, this.rows, this.screenElement)), this._instantiationService.setService(S.IRenderService, this._renderService), this.register(this._renderService.onRenderedViewportChange((e)=>this._onRender.fire(e))), this.onResize((e)=>this._renderService.resize(e.cols, e.rows)), this._compositionView = O.createElement("div"), this._compositionView.classList.add("composition-view"), this._compositionHelper = this._instantiationService.createInstance(s.CompositionHelper, this.textarea, this._compositionView), this._helperContainer.appendChild(this._compositionView), this.element.appendChild(i);
                        try {
                            this._onWillOpen.fire(this.element);
                        } catch (e) {}
                        this._renderService.hasRenderer() || this._renderService.setRenderer(this._createRenderer()), this._mouseService = this._instantiationService.createInstance(C.MouseService), this._instantiationService.setService(S.IMouseService, this._mouseService), this.viewport = this._instantiationService.createInstance(r.Viewport, (e)=>this.scrollLines(e, !0, 1), this._viewportElement, this._viewportScrollArea), this.register(this._inputHandler.onRequestSyncScrollBar(()=>this.viewport.syncScrollArea())), this.register(this.viewport), this.register(this.onCursorMove(()=>{
                            this._renderService.handleCursorMove(), this._syncTextArea();
                        })), this.register(this.onResize(()=>this._renderService.handleResize(this.cols, this.rows))), this.register(this.onBlur(()=>this._renderService.handleBlur())), this.register(this.onFocus(()=>this._renderService.handleFocus())), this.register(this._renderService.onDimensionsChange(()=>this.viewport.syncScrollArea())), this._selectionService = this.register(this._instantiationService.createInstance(h.SelectionService, this.element, this.screenElement, this.linkifier2)), this._instantiationService.setService(S.ISelectionService, this._selectionService), this.register(this._selectionService.onRequestScrollLines((e)=>this.scrollLines(e.amount, e.suppressScrollEvent))), this.register(this._selectionService.onSelectionChange(()=>this._onSelectionChange.fire())), this.register(this._selectionService.onRequestRedraw((e)=>this._renderService.handleSelectionChanged(e.start, e.end, e.columnSelectMode))), this.register(this._selectionService.onLinuxMouseSelection((e)=>{
                            this.textarea.value = e, this.textarea.focus(), this.textarea.select();
                        })), this.register(this._onScroll.event((e)=>{
                            this.viewport.syncScrollArea(), this._selectionService.refresh();
                        })), this.register((0, l.addDisposableDomListener)(this._viewportElement, "scroll", ()=>this._selectionService.refresh())), this.linkifier2.attachToDom(this.screenElement, this._mouseService, this._renderService), this.register(this._instantiationService.createInstance(R.BufferDecorationRenderer, this.screenElement)), this.register((0, l.addDisposableDomListener)(this.element, "mousedown", (e)=>this._selectionService.handleMouseDown(e))), this.coreMouseService.areMouseEventsActive ? (this._selectionService.disable(), this.element.classList.add("enable-mouse-events")) : this._selectionService.enable(), this.options.screenReaderMode && (this._accessibilityManager = this._instantiationService.createInstance(_.AccessibilityManager, this)), this.register(this.optionsService.onSpecificOptionChange("screenReaderMode", (e)=>this._handleScreenReaderModeOptionChange(e))), this.options.overviewRulerWidth && (this._overviewRulerRenderer = this.register(this._instantiationService.createInstance(D.OverviewRulerRenderer, this._viewportElement, this.screenElement))), this.optionsService.onSpecificOptionChange("overviewRulerWidth", (e)=>{
                            !this._overviewRulerRenderer && e && this._viewportElement && this.screenElement && (this._overviewRulerRenderer = this.register(this._instantiationService.createInstance(D.OverviewRulerRenderer, this._viewportElement, this.screenElement)));
                        }), this._charSizeService.measure(), this.refresh(0, this.rows - 1), this._initGlobal(), this.bindMouse();
                    }
                    _createRenderer() {
                        return this._instantiationService.createInstance(u.DomRenderer, this.element, this.screenElement, this._viewportElement, this.linkifier2);
                    }
                    bindMouse() {
                        const e = this, t = this.element;
                        function i(t) {
                            const i = e._mouseService.getMouseReportCoords(t, e.screenElement);
                            if (!i) return !1;
                            let s, r;
                            switch(t.overrideType || t.type){
                                case "mousemove":
                                    r = 32, void 0 === t.buttons ? (s = 3, void 0 !== t.button && (s = t.button < 3 ? t.button : 3)) : s = 1 & t.buttons ? 0 : 4 & t.buttons ? 1 : 2 & t.buttons ? 2 : 3;
                                    break;
                                case "mouseup":
                                    r = 0, s = t.button < 3 ? t.button : 3;
                                    break;
                                case "mousedown":
                                    r = 1, s = t.button < 3 ? t.button : 3;
                                    break;
                                case "wheel":
                                    if (0 === e.viewport.getLinesScrolled(t)) return !1;
                                    r = t.deltaY < 0 ? 0 : 1, s = 4;
                                    break;
                                default:
                                    return !1;
                            }
                            return !(void 0 === r || void 0 === s || s > 4) && e.coreMouseService.triggerMouseEvent({
                                col: i.col,
                                row: i.row,
                                x: i.x,
                                y: i.y,
                                button: s,
                                action: r,
                                ctrl: t.ctrlKey,
                                alt: t.altKey,
                                shift: t.shiftKey
                            });
                        }
                        const s = {
                            mouseup: null,
                            wheel: null,
                            mousedrag: null,
                            mousemove: null
                        }, r = {
                            mouseup: (e)=>(i(e), e.buttons || (this._document.removeEventListener("mouseup", s.mouseup), s.mousedrag && this._document.removeEventListener("mousemove", s.mousedrag)), this.cancel(e)),
                            wheel: (e)=>(i(e), this.cancel(e, !0)),
                            mousedrag: (e)=>{
                                e.buttons && i(e);
                            },
                            mousemove: (e)=>{
                                e.buttons || i(e);
                            }
                        };
                        this.register(this.coreMouseService.onProtocolChange((e)=>{
                            e ? ("debug" === this.optionsService.rawOptions.logLevel && this._logService.debug("Binding to mouse events:", this.coreMouseService.explainEvents(e)), this.element.classList.add("enable-mouse-events"), this._selectionService.disable()) : (this._logService.debug("Unbinding from mouse events."), this.element.classList.remove("enable-mouse-events"), this._selectionService.enable()), 8 & e ? s.mousemove || (t.addEventListener("mousemove", r.mousemove), s.mousemove = r.mousemove) : (t.removeEventListener("mousemove", s.mousemove), s.mousemove = null), 16 & e ? s.wheel || (t.addEventListener("wheel", r.wheel, {
                                passive: !1
                            }), s.wheel = r.wheel) : (t.removeEventListener("wheel", s.wheel), s.wheel = null), 2 & e ? s.mouseup || (s.mouseup = r.mouseup) : (this._document.removeEventListener("mouseup", s.mouseup), s.mouseup = null), 4 & e ? s.mousedrag || (s.mousedrag = r.mousedrag) : (this._document.removeEventListener("mousemove", s.mousedrag), s.mousedrag = null);
                        })), this.coreMouseService.activeProtocol = this.coreMouseService.activeProtocol, this.register((0, l.addDisposableDomListener)(t, "mousedown", (e)=>{
                            if (e.preventDefault(), this.focus(), this.coreMouseService.areMouseEventsActive && !this._selectionService.shouldForceSelection(e)) return i(e), s.mouseup && this._document.addEventListener("mouseup", s.mouseup), s.mousedrag && this._document.addEventListener("mousemove", s.mousedrag), this.cancel(e);
                        })), this.register((0, l.addDisposableDomListener)(t, "wheel", (e)=>{
                            if (!s.wheel) {
                                if (!this.buffer.hasScrollback) {
                                    const t = this.viewport.getLinesScrolled(e);
                                    if (0 === t) return;
                                    const i = o.C0.ESC + (this.coreService.decPrivateModes.applicationCursorKeys ? "O" : "[") + (e.deltaY < 0 ? "A" : "B");
                                    let s = "";
                                    for(let e = 0; e < Math.abs(t); e++)s += i;
                                    return this.coreService.triggerDataEvent(s, !0), this.cancel(e, !0);
                                }
                                return this.viewport.handleWheel(e) ? this.cancel(e) : void 0;
                            }
                        }, {
                            passive: !1
                        })), this.register((0, l.addDisposableDomListener)(t, "touchstart", (e)=>{
                            if (!this.coreMouseService.areMouseEventsActive) return this.viewport.handleTouchStart(e), this.cancel(e);
                        }, {
                            passive: !0
                        })), this.register((0, l.addDisposableDomListener)(t, "touchmove", (e)=>{
                            if (!this.coreMouseService.areMouseEventsActive) return this.viewport.handleTouchMove(e) ? void 0 : this.cancel(e);
                        }, {
                            passive: !1
                        }));
                    }
                    refresh(e, t) {
                        var i;
                        null === (i = this._renderService) || void 0 === i || i.refreshRows(e, t);
                    }
                    updateCursorStyle(e) {
                        var t;
                        (null === (t = this._selectionService) || void 0 === t ? void 0 : t.shouldColumnSelect(e)) ? this.element.classList.add("column-select") : this.element.classList.remove("column-select");
                    }
                    _showCursor() {
                        this.coreService.isCursorInitialized || (this.coreService.isCursorInitialized = !0, this.refresh(this.buffer.y, this.buffer.y));
                    }
                    scrollLines(e, t, i = 0) {
                        super.scrollLines(e, t, i), this.refresh(0, this.rows - 1);
                    }
                    paste(e) {
                        (0, n.paste)(e, this.textarea, this.coreService);
                    }
                    attachCustomKeyEventHandler(e) {
                        this._customKeyEventHandler = e;
                    }
                    registerLinkProvider(e) {
                        return this.linkifier2.registerLinkProvider(e);
                    }
                    registerCharacterJoiner(e) {
                        if (!this._characterJoinerService) throw new Error("Terminal must be opened first");
                        const t = this._characterJoinerService.register(e);
                        return this.refresh(0, this.rows - 1), t;
                    }
                    deregisterCharacterJoiner(e) {
                        if (!this._characterJoinerService) throw new Error("Terminal must be opened first");
                        this._characterJoinerService.deregister(e) && this.refresh(0, this.rows - 1);
                    }
                    get markers() {
                        return this.buffer.markers;
                    }
                    addMarker(e) {
                        return this.buffer.addMarker(this.buffer.ybase + this.buffer.y + e);
                    }
                    registerDecoration(e) {
                        return this._decorationService.registerDecoration(e);
                    }
                    hasSelection() {
                        return !!this._selectionService && this._selectionService.hasSelection;
                    }
                    select(e, t, i) {
                        this._selectionService.setSelection(e, t, i);
                    }
                    getSelection() {
                        return this._selectionService ? this._selectionService.selectionText : "";
                    }
                    getSelectionPosition() {
                        if (this._selectionService && this._selectionService.hasSelection) return {
                            start: {
                                x: this._selectionService.selectionStart[0],
                                y: this._selectionService.selectionStart[1]
                            },
                            end: {
                                x: this._selectionService.selectionEnd[0],
                                y: this._selectionService.selectionEnd[1]
                            }
                        };
                    }
                    clearSelection() {
                        var e;
                        null === (e = this._selectionService) || void 0 === e || e.clearSelection();
                    }
                    selectAll() {
                        var e;
                        null === (e = this._selectionService) || void 0 === e || e.selectAll();
                    }
                    selectLines(e, t) {
                        var i;
                        null === (i = this._selectionService) || void 0 === i || i.selectLines(e, t);
                    }
                    _keyDown(e) {
                        if (this._keyDownHandled = !1, this._keyDownSeen = !0, this._customKeyEventHandler && !1 === this._customKeyEventHandler(e)) return !1;
                        const t = this.browser.isMac && this.options.macOptionIsMeta && e.altKey;
                        if (!t && !this._compositionHelper.keydown(e)) return this.options.scrollOnUserInput && this.buffer.ybase !== this.buffer.ydisp && this._bufferService.scrollToBottom(), !1;
                        t || "Dead" !== e.key && "AltGraph" !== e.key || (this._unprocessedDeadKey = !0);
                        const i = (0, f.evaluateKeyboardEvent)(e, this.coreService.decPrivateModes.applicationCursorKeys, this.browser.isMac, this.options.macOptionIsMeta);
                        if (this.updateCursorStyle(e), 3 === i.type || 2 === i.type) {
                            const t = this.rows - 1;
                            return this.scrollLines(2 === i.type ? -t : t), this.cancel(e, !0);
                        }
                        return 1 === i.type && this.selectAll(), !!this._isThirdLevelShift(this.browser, e) || (i.cancel && this.cancel(e, !0), !i.key || !!(e.key && !e.ctrlKey && !e.altKey && !e.metaKey && 1 === e.key.length && e.key.charCodeAt(0) >= 65 && e.key.charCodeAt(0) <= 90) || (this._unprocessedDeadKey ? (this._unprocessedDeadKey = !1, !0) : (i.key !== o.C0.ETX && i.key !== o.C0.CR || (this.textarea.value = ""), this._onKey.fire({
                            key: i.key,
                            domEvent: e
                        }), this._showCursor(), this.coreService.triggerDataEvent(i.key, !0), !this.optionsService.rawOptions.screenReaderMode || e.altKey || e.ctrlKey ? this.cancel(e, !0) : void (this._keyDownHandled = !0))));
                    }
                    _isThirdLevelShift(e, t) {
                        const i = e.isMac && !this.options.macOptionIsMeta && t.altKey && !t.ctrlKey && !t.metaKey || e.isWindows && t.altKey && t.ctrlKey && !t.metaKey || e.isWindows && t.getModifierState("AltGraph");
                        return "keypress" === t.type ? i : i && (!t.keyCode || t.keyCode > 47);
                    }
                    _keyUp(e) {
                        this._keyDownSeen = !1, this._customKeyEventHandler && !1 === this._customKeyEventHandler(e) || (function(e) {
                            return 16 === e.keyCode || 17 === e.keyCode || 18 === e.keyCode;
                        }(e) || this.focus(), this.updateCursorStyle(e), this._keyPressHandled = !1);
                    }
                    _keyPress(e) {
                        let t;
                        if (this._keyPressHandled = !1, this._keyDownHandled) return !1;
                        if (this._customKeyEventHandler && !1 === this._customKeyEventHandler(e)) return !1;
                        if (this.cancel(e), e.charCode) t = e.charCode;
                        else if (null === e.which || void 0 === e.which) t = e.keyCode;
                        else {
                            if (0 === e.which || 0 === e.charCode) return !1;
                            t = e.which;
                        }
                        return !(!t || (e.altKey || e.ctrlKey || e.metaKey) && !this._isThirdLevelShift(this.browser, e) || (t = String.fromCharCode(t), this._onKey.fire({
                            key: t,
                            domEvent: e
                        }), this._showCursor(), this.coreService.triggerDataEvent(t, !0), this._keyPressHandled = !0, this._unprocessedDeadKey = !1, 0));
                    }
                    _inputEvent(e) {
                        if (e.data && "insertText" === e.inputType && (!e.composed || !this._keyDownSeen) && !this.optionsService.rawOptions.screenReaderMode) {
                            if (this._keyPressHandled) return !1;
                            this._unprocessedDeadKey = !1;
                            const t = e.data;
                            return this.coreService.triggerDataEvent(t, !0), this.cancel(e), !0;
                        }
                        return !1;
                    }
                    resize(e, t) {
                        e !== this.cols || t !== this.rows ? super.resize(e, t) : this._charSizeService && !this._charSizeService.hasValidSize && this._charSizeService.measure();
                    }
                    _afterResize(e, t) {
                        var i, s;
                        null === (i = this._charSizeService) || void 0 === i || i.measure(), null === (s = this.viewport) || void 0 === s || s.syncScrollArea(!0);
                    }
                    clear() {
                        if (0 !== this.buffer.ybase || 0 !== this.buffer.y) {
                            this.buffer.clearAllMarkers(), this.buffer.lines.set(0, this.buffer.lines.get(this.buffer.ybase + this.buffer.y)), this.buffer.lines.length = 1, this.buffer.ydisp = 0, this.buffer.ybase = 0, this.buffer.y = 0;
                            for(let e = 1; e < this.rows; e++)this.buffer.lines.push(this.buffer.getBlankLine(g.DEFAULT_ATTR_DATA));
                            this.refresh(0, this.rows - 1), this._onScroll.fire({
                                position: this.buffer.ydisp,
                                source: 0
                            });
                        }
                    }
                    reset() {
                        var e, t;
                        this.options.rows = this.rows, this.options.cols = this.cols;
                        const i = this._customKeyEventHandler;
                        this._setup(), super.reset(), null === (e = this._selectionService) || void 0 === e || e.reset(), this._decorationService.reset(), this._customKeyEventHandler = i, this.refresh(0, this.rows - 1), null === (t = this.viewport) || void 0 === t || t.syncScrollArea();
                    }
                    clearTextureAtlas() {
                        var e;
                        null === (e = this._renderService) || void 0 === e || e.clearTextureAtlas();
                    }
                    _reportFocus() {
                        var e;
                        (null === (e = this.element) || void 0 === e ? void 0 : e.classList.contains("focus")) ? this.coreService.triggerDataEvent(o.C0.ESC + "[I") : this.coreService.triggerDataEvent(o.C0.ESC + "[O");
                    }
                    _reportWindowsOptions(e) {
                        if (this._renderService) switch(e){
                            case a.WindowsOptionsReportType.GET_WIN_SIZE_PIXELS:
                                const e1 = this._renderService.dimensions.css.canvas.width.toFixed(0), t = this._renderService.dimensions.css.canvas.height.toFixed(0);
                                this.coreService.triggerDataEvent(`${o.C0.ESC}[4;${t};${e1}t`);
                                break;
                            case a.WindowsOptionsReportType.GET_CELL_SIZE_PIXELS:
                                const i = this._renderService.dimensions.css.cell.width.toFixed(0), s = this._renderService.dimensions.css.cell.height.toFixed(0);
                                this.coreService.triggerDataEvent(`${o.C0.ESC}[6;${s};${i}t`);
                        }
                    }
                    cancel(e, t) {
                        if (this.options.cancelEvents || t) return e.preventDefault(), e.stopPropagation(), !1;
                    }
                }
                t.Terminal = I;
            },
            9924: (e, t)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.TimeBasedDebouncer = void 0, t.TimeBasedDebouncer = class {
                    constructor(e, t = 1e3){
                        this._renderCallback = e, this._debounceThresholdMS = t, this._lastRefreshMs = 0, this._additionalRefreshRequested = !1;
                    }
                    dispose() {
                        this._refreshTimeoutID && clearTimeout(this._refreshTimeoutID);
                    }
                    refresh(e, t, i) {
                        this._rowCount = i, e = void 0 !== e ? e : 0, t = void 0 !== t ? t : this._rowCount - 1, this._rowStart = void 0 !== this._rowStart ? Math.min(this._rowStart, e) : e, this._rowEnd = void 0 !== this._rowEnd ? Math.max(this._rowEnd, t) : t;
                        const s = Date.now();
                        if (s - this._lastRefreshMs >= this._debounceThresholdMS) this._lastRefreshMs = s, this._innerRefresh();
                        else if (!this._additionalRefreshRequested) {
                            const e = s - this._lastRefreshMs, t = this._debounceThresholdMS - e;
                            this._additionalRefreshRequested = !0, this._refreshTimeoutID = window.setTimeout(()=>{
                                this._lastRefreshMs = Date.now(), this._innerRefresh(), this._additionalRefreshRequested = !1, this._refreshTimeoutID = void 0;
                            }, t);
                        }
                    }
                    _innerRefresh() {
                        if (void 0 === this._rowStart || void 0 === this._rowEnd || void 0 === this._rowCount) return;
                        const e = Math.max(this._rowStart, 0), t = Math.min(this._rowEnd, this._rowCount - 1);
                        this._rowStart = void 0, this._rowEnd = void 0, this._renderCallback(e, t);
                    }
                };
            },
            1680: function(e, t, i) {
                var s = this && this.__decorate || function(e, t, i, s) {
                    var r, n = arguments.length, o = n < 3 ? t : null === s ? s = Object.getOwnPropertyDescriptor(t, i) : s;
                    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, i, s);
                    else for(var a = e.length - 1; a >= 0; a--)(r = e[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(t, i, o) : r(t, i)) || o);
                    return n > 3 && o && Object.defineProperty(t, i, o), o;
                }, r = this && this.__param || function(e, t) {
                    return function(i, s) {
                        t(i, s, e);
                    };
                };
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.Viewport = void 0;
                const n = i(844), o = i(3656), a = i(4725), h = i(2585);
                let c = class extends n.Disposable {
                    constructor(e, t, i, s, r, n, a, h, c){
                        super(), this._scrollLines = e, this._viewportElement = t, this._scrollArea = i, this._bufferService = s, this._optionsService = r, this._charSizeService = n, this._renderService = a, this._coreBrowserService = h, this.scrollBarWidth = 0, this._currentRowHeight = 0, this._currentDeviceCellHeight = 0, this._lastRecordedBufferLength = 0, this._lastRecordedViewportHeight = 0, this._lastRecordedBufferHeight = 0, this._lastTouchY = 0, this._lastScrollTop = 0, this._wheelPartialScroll = 0, this._refreshAnimationFrame = null, this._ignoreNextScrollEvent = !1, this._smoothScrollState = {
                            startTime: 0,
                            origin: -1,
                            target: -1
                        }, this.scrollBarWidth = this._viewportElement.offsetWidth - this._scrollArea.offsetWidth || 15, this.register((0, o.addDisposableDomListener)(this._viewportElement, "scroll", this._handleScroll.bind(this))), this._activeBuffer = this._bufferService.buffer, this.register(this._bufferService.buffers.onBufferActivate((e)=>this._activeBuffer = e.activeBuffer)), this._renderDimensions = this._renderService.dimensions, this.register(this._renderService.onDimensionsChange((e)=>this._renderDimensions = e)), this._handleThemeChange(c.colors), this.register(c.onChangeColors((e)=>this._handleThemeChange(e))), this.register(this._optionsService.onSpecificOptionChange("scrollback", ()=>this.syncScrollArea())), setTimeout(()=>this.syncScrollArea(), 0);
                    }
                    _handleThemeChange(e) {
                        this._viewportElement.style.backgroundColor = e.background.css;
                    }
                    _refresh(e) {
                        if (e) return this._innerRefresh(), void (null !== this._refreshAnimationFrame && this._coreBrowserService.window.cancelAnimationFrame(this._refreshAnimationFrame));
                        null === this._refreshAnimationFrame && (this._refreshAnimationFrame = this._coreBrowserService.window.requestAnimationFrame(()=>this._innerRefresh()));
                    }
                    _innerRefresh() {
                        if (this._charSizeService.height > 0) {
                            this._currentRowHeight = this._renderService.dimensions.device.cell.height / this._coreBrowserService.dpr, this._currentDeviceCellHeight = this._renderService.dimensions.device.cell.height, this._lastRecordedViewportHeight = this._viewportElement.offsetHeight;
                            const e = Math.round(this._currentRowHeight * this._lastRecordedBufferLength) + (this._lastRecordedViewportHeight - this._renderService.dimensions.css.canvas.height);
                            this._lastRecordedBufferHeight !== e && (this._lastRecordedBufferHeight = e, this._scrollArea.style.height = this._lastRecordedBufferHeight + "px");
                        }
                        const e = this._bufferService.buffer.ydisp * this._currentRowHeight;
                        this._viewportElement.scrollTop !== e && (this._ignoreNextScrollEvent = !0, this._viewportElement.scrollTop = e), this._refreshAnimationFrame = null;
                    }
                    syncScrollArea(e = !1) {
                        if (this._lastRecordedBufferLength !== this._bufferService.buffer.lines.length) return this._lastRecordedBufferLength = this._bufferService.buffer.lines.length, void this._refresh(e);
                        this._lastRecordedViewportHeight === this._renderService.dimensions.css.canvas.height && this._lastScrollTop === this._activeBuffer.ydisp * this._currentRowHeight && this._renderDimensions.device.cell.height === this._currentDeviceCellHeight || this._refresh(e);
                    }
                    _handleScroll(e) {
                        if (this._lastScrollTop = this._viewportElement.scrollTop, !this._viewportElement.offsetParent) return;
                        if (this._ignoreNextScrollEvent) return this._ignoreNextScrollEvent = !1, void this._scrollLines(0);
                        const t = Math.round(this._lastScrollTop / this._currentRowHeight) - this._bufferService.buffer.ydisp;
                        this._scrollLines(t);
                    }
                    _smoothScroll() {
                        if (this._isDisposed || -1 === this._smoothScrollState.origin || -1 === this._smoothScrollState.target) return;
                        const e = this._smoothScrollPercent();
                        this._viewportElement.scrollTop = this._smoothScrollState.origin + Math.round(e * (this._smoothScrollState.target - this._smoothScrollState.origin)), e < 1 ? this._coreBrowserService.window.requestAnimationFrame(()=>this._smoothScroll()) : this._clearSmoothScrollState();
                    }
                    _smoothScrollPercent() {
                        return this._optionsService.rawOptions.smoothScrollDuration && this._smoothScrollState.startTime ? Math.max(Math.min((Date.now() - this._smoothScrollState.startTime) / this._optionsService.rawOptions.smoothScrollDuration, 1), 0) : 1;
                    }
                    _clearSmoothScrollState() {
                        this._smoothScrollState.startTime = 0, this._smoothScrollState.origin = -1, this._smoothScrollState.target = -1;
                    }
                    _bubbleScroll(e, t) {
                        const i = this._viewportElement.scrollTop + this._lastRecordedViewportHeight;
                        return !(t < 0 && 0 !== this._viewportElement.scrollTop || t > 0 && i < this._lastRecordedBufferHeight) || (e.cancelable && e.preventDefault(), !1);
                    }
                    handleWheel(e) {
                        const t = this._getPixelsScrolled(e);
                        return 0 !== t && (this._optionsService.rawOptions.smoothScrollDuration ? (this._smoothScrollState.startTime = Date.now(), this._smoothScrollPercent() < 1 ? (this._smoothScrollState.origin = this._viewportElement.scrollTop, -1 === this._smoothScrollState.target ? this._smoothScrollState.target = this._viewportElement.scrollTop + t : this._smoothScrollState.target += t, this._smoothScrollState.target = Math.max(Math.min(this._smoothScrollState.target, this._viewportElement.scrollHeight), 0), this._smoothScroll()) : this._clearSmoothScrollState()) : this._viewportElement.scrollTop += t, this._bubbleScroll(e, t));
                    }
                    _getPixelsScrolled(e) {
                        if (0 === e.deltaY || e.shiftKey) return 0;
                        let t = this._applyScrollModifier(e.deltaY, e);
                        return e.deltaMode === WheelEvent.DOM_DELTA_LINE ? t *= this._currentRowHeight : e.deltaMode === WheelEvent.DOM_DELTA_PAGE && (t *= this._currentRowHeight * this._bufferService.rows), t;
                    }
                    getBufferElements(e, t) {
                        var i;
                        let s, r = "";
                        const n = [], o = null != t ? t : this._bufferService.buffer.lines.length, a = this._bufferService.buffer.lines;
                        for(let t = e; t < o; t++){
                            const e = a.get(t);
                            if (!e) continue;
                            const o = null === (i = a.get(t + 1)) || void 0 === i ? void 0 : i.isWrapped;
                            if (r += e.translateToString(!o), !o || t === a.length - 1) {
                                const e = document.createElement("div");
                                e.textContent = r, n.push(e), r.length > 0 && (s = e), r = "";
                            }
                        }
                        return {
                            bufferElements: n,
                            cursorElement: s
                        };
                    }
                    getLinesScrolled(e) {
                        if (0 === e.deltaY || e.shiftKey) return 0;
                        let t = this._applyScrollModifier(e.deltaY, e);
                        return e.deltaMode === WheelEvent.DOM_DELTA_PIXEL ? (t /= this._currentRowHeight + 0, this._wheelPartialScroll += t, t = Math.floor(Math.abs(this._wheelPartialScroll)) * (this._wheelPartialScroll > 0 ? 1 : -1), this._wheelPartialScroll %= 1) : e.deltaMode === WheelEvent.DOM_DELTA_PAGE && (t *= this._bufferService.rows), t;
                    }
                    _applyScrollModifier(e, t) {
                        const i = this._optionsService.rawOptions.fastScrollModifier;
                        return "alt" === i && t.altKey || "ctrl" === i && t.ctrlKey || "shift" === i && t.shiftKey ? e * this._optionsService.rawOptions.fastScrollSensitivity * this._optionsService.rawOptions.scrollSensitivity : e * this._optionsService.rawOptions.scrollSensitivity;
                    }
                    handleTouchStart(e) {
                        this._lastTouchY = e.touches[0].pageY;
                    }
                    handleTouchMove(e) {
                        const t = this._lastTouchY - e.touches[0].pageY;
                        return this._lastTouchY = e.touches[0].pageY, 0 !== t && (this._viewportElement.scrollTop += t, this._bubbleScroll(e, t));
                    }
                };
                c = s([
                    r(3, h.IBufferService),
                    r(4, h.IOptionsService),
                    r(5, a.ICharSizeService),
                    r(6, a.IRenderService),
                    r(7, a.ICoreBrowserService),
                    r(8, a.IThemeService)
                ], c), t.Viewport = c;
            },
            3107: function(e, t, i) {
                var s = this && this.__decorate || function(e, t, i, s) {
                    var r, n = arguments.length, o = n < 3 ? t : null === s ? s = Object.getOwnPropertyDescriptor(t, i) : s;
                    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, i, s);
                    else for(var a = e.length - 1; a >= 0; a--)(r = e[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(t, i, o) : r(t, i)) || o);
                    return n > 3 && o && Object.defineProperty(t, i, o), o;
                }, r = this && this.__param || function(e, t) {
                    return function(i, s) {
                        t(i, s, e);
                    };
                };
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.BufferDecorationRenderer = void 0;
                const n = i(3656), o = i(4725), a = i(844), h = i(2585);
                let c = class extends a.Disposable {
                    constructor(e, t, i, s){
                        super(), this._screenElement = e, this._bufferService = t, this._decorationService = i, this._renderService = s, this._decorationElements = new Map, this._altBufferIsActive = !1, this._dimensionsChanged = !1, this._container = document.createElement("div"), this._container.classList.add("xterm-decoration-container"), this._screenElement.appendChild(this._container), this.register(this._renderService.onRenderedViewportChange(()=>this._doRefreshDecorations())), this.register(this._renderService.onDimensionsChange(()=>{
                            this._dimensionsChanged = !0, this._queueRefresh();
                        })), this.register((0, n.addDisposableDomListener)(window, "resize", ()=>this._queueRefresh())), this.register(this._bufferService.buffers.onBufferActivate(()=>{
                            this._altBufferIsActive = this._bufferService.buffer === this._bufferService.buffers.alt;
                        })), this.register(this._decorationService.onDecorationRegistered(()=>this._queueRefresh())), this.register(this._decorationService.onDecorationRemoved((e)=>this._removeDecoration(e))), this.register((0, a.toDisposable)(()=>{
                            this._container.remove(), this._decorationElements.clear();
                        }));
                    }
                    _queueRefresh() {
                        void 0 === this._animationFrame && (this._animationFrame = this._renderService.addRefreshCallback(()=>{
                            this._doRefreshDecorations(), this._animationFrame = void 0;
                        }));
                    }
                    _doRefreshDecorations() {
                        for (const e of this._decorationService.decorations)this._renderDecoration(e);
                        this._dimensionsChanged = !1;
                    }
                    _renderDecoration(e) {
                        this._refreshStyle(e), this._dimensionsChanged && this._refreshXPosition(e);
                    }
                    _createElement(e) {
                        var t, i;
                        const s = document.createElement("div");
                        s.classList.add("xterm-decoration"), s.classList.toggle("xterm-decoration-top-layer", "top" === (null === (t = null == e ? void 0 : e.options) || void 0 === t ? void 0 : t.layer)), s.style.width = `${Math.round((e.options.width || 1) * this._renderService.dimensions.css.cell.width)}px`, s.style.height = (e.options.height || 1) * this._renderService.dimensions.css.cell.height + "px", s.style.top = (e.marker.line - this._bufferService.buffers.active.ydisp) * this._renderService.dimensions.css.cell.height + "px", s.style.lineHeight = `${this._renderService.dimensions.css.cell.height}px`;
                        const r = null !== (i = e.options.x) && void 0 !== i ? i : 0;
                        return r && r > this._bufferService.cols && (s.style.display = "none"), this._refreshXPosition(e, s), s;
                    }
                    _refreshStyle(e) {
                        const t = e.marker.line - this._bufferService.buffers.active.ydisp;
                        if (t < 0 || t >= this._bufferService.rows) e.element && (e.element.style.display = "none", e.onRenderEmitter.fire(e.element));
                        else {
                            let i = this._decorationElements.get(e);
                            i || (i = this._createElement(e), e.element = i, this._decorationElements.set(e, i), this._container.appendChild(i)), i.style.top = t * this._renderService.dimensions.css.cell.height + "px", i.style.display = this._altBufferIsActive ? "none" : "block", e.onRenderEmitter.fire(i);
                        }
                    }
                    _refreshXPosition(e, t = e.element) {
                        var i;
                        if (!t) return;
                        const s = null !== (i = e.options.x) && void 0 !== i ? i : 0;
                        "right" === (e.options.anchor || "left") ? t.style.right = s ? s * this._renderService.dimensions.css.cell.width + "px" : "" : t.style.left = s ? s * this._renderService.dimensions.css.cell.width + "px" : "";
                    }
                    _removeDecoration(e) {
                        var t;
                        null === (t = this._decorationElements.get(e)) || void 0 === t || t.remove(), this._decorationElements.delete(e), e.dispose();
                    }
                };
                c = s([
                    r(1, h.IBufferService),
                    r(2, h.IDecorationService),
                    r(3, o.IRenderService)
                ], c), t.BufferDecorationRenderer = c;
            },
            5871: (e, t)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.ColorZoneStore = void 0, t.ColorZoneStore = class {
                    constructor(){
                        this._zones = [], this._zonePool = [], this._zonePoolIndex = 0, this._linePadding = {
                            full: 0,
                            left: 0,
                            center: 0,
                            right: 0
                        };
                    }
                    get zones() {
                        return this._zonePool.length = Math.min(this._zonePool.length, this._zones.length), this._zones;
                    }
                    clear() {
                        this._zones.length = 0, this._zonePoolIndex = 0;
                    }
                    addDecoration(e) {
                        if (e.options.overviewRulerOptions) {
                            for (const t of this._zones)if (t.color === e.options.overviewRulerOptions.color && t.position === e.options.overviewRulerOptions.position) {
                                if (this._lineIntersectsZone(t, e.marker.line)) return;
                                if (this._lineAdjacentToZone(t, e.marker.line, e.options.overviewRulerOptions.position)) return void this._addLineToZone(t, e.marker.line);
                            }
                            if (this._zonePoolIndex < this._zonePool.length) return this._zonePool[this._zonePoolIndex].color = e.options.overviewRulerOptions.color, this._zonePool[this._zonePoolIndex].position = e.options.overviewRulerOptions.position, this._zonePool[this._zonePoolIndex].startBufferLine = e.marker.line, this._zonePool[this._zonePoolIndex].endBufferLine = e.marker.line, void this._zones.push(this._zonePool[this._zonePoolIndex++]);
                            this._zones.push({
                                color: e.options.overviewRulerOptions.color,
                                position: e.options.overviewRulerOptions.position,
                                startBufferLine: e.marker.line,
                                endBufferLine: e.marker.line
                            }), this._zonePool.push(this._zones[this._zones.length - 1]), this._zonePoolIndex++;
                        }
                    }
                    setPadding(e) {
                        this._linePadding = e;
                    }
                    _lineIntersectsZone(e, t) {
                        return t >= e.startBufferLine && t <= e.endBufferLine;
                    }
                    _lineAdjacentToZone(e, t, i) {
                        return t >= e.startBufferLine - this._linePadding[i || "full"] && t <= e.endBufferLine + this._linePadding[i || "full"];
                    }
                    _addLineToZone(e, t) {
                        e.startBufferLine = Math.min(e.startBufferLine, t), e.endBufferLine = Math.max(e.endBufferLine, t);
                    }
                };
            },
            5744: function(e, t, i) {
                var s = this && this.__decorate || function(e, t, i, s) {
                    var r, n = arguments.length, o = n < 3 ? t : null === s ? s = Object.getOwnPropertyDescriptor(t, i) : s;
                    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, i, s);
                    else for(var a = e.length - 1; a >= 0; a--)(r = e[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(t, i, o) : r(t, i)) || o);
                    return n > 3 && o && Object.defineProperty(t, i, o), o;
                }, r = this && this.__param || function(e, t) {
                    return function(i, s) {
                        t(i, s, e);
                    };
                };
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.OverviewRulerRenderer = void 0;
                const n = i(5871), o = i(3656), a = i(4725), h = i(844), c = i(2585), l = {
                    full: 0,
                    left: 0,
                    center: 0,
                    right: 0
                }, d = {
                    full: 0,
                    left: 0,
                    center: 0,
                    right: 0
                }, _ = {
                    full: 0,
                    left: 0,
                    center: 0,
                    right: 0
                };
                let u = class extends h.Disposable {
                    constructor(e, t, i, s, r, o, a){
                        var c;
                        super(), this._viewportElement = e, this._screenElement = t, this._bufferService = i, this._decorationService = s, this._renderService = r, this._optionsService = o, this._coreBrowseService = a, this._colorZoneStore = new n.ColorZoneStore, this._shouldUpdateDimensions = !0, this._shouldUpdateAnchor = !0, this._lastKnownBufferLength = 0, this._canvas = document.createElement("canvas"), this._canvas.classList.add("xterm-decoration-overview-ruler"), this._refreshCanvasDimensions(), null === (c = this._viewportElement.parentElement) || void 0 === c || c.insertBefore(this._canvas, this._viewportElement);
                        const l = this._canvas.getContext("2d");
                        if (!l) throw new Error("Ctx cannot be null");
                        this._ctx = l, this._registerDecorationListeners(), this._registerBufferChangeListeners(), this._registerDimensionChangeListeners(), this.register((0, h.toDisposable)(()=>{
                            var e;
                            null === (e = this._canvas) || void 0 === e || e.remove();
                        }));
                    }
                    get _width() {
                        return this._optionsService.options.overviewRulerWidth || 0;
                    }
                    _registerDecorationListeners() {
                        this.register(this._decorationService.onDecorationRegistered(()=>this._queueRefresh(void 0, !0))), this.register(this._decorationService.onDecorationRemoved(()=>this._queueRefresh(void 0, !0)));
                    }
                    _registerBufferChangeListeners() {
                        this.register(this._renderService.onRenderedViewportChange(()=>this._queueRefresh())), this.register(this._bufferService.buffers.onBufferActivate(()=>{
                            this._canvas.style.display = this._bufferService.buffer === this._bufferService.buffers.alt ? "none" : "block";
                        })), this.register(this._bufferService.onScroll(()=>{
                            this._lastKnownBufferLength !== this._bufferService.buffers.normal.lines.length && (this._refreshDrawHeightConstants(), this._refreshColorZonePadding());
                        }));
                    }
                    _registerDimensionChangeListeners() {
                        this.register(this._renderService.onRender(()=>{
                            this._containerHeight && this._containerHeight === this._screenElement.clientHeight || (this._queueRefresh(!0), this._containerHeight = this._screenElement.clientHeight);
                        })), this.register(this._optionsService.onSpecificOptionChange("overviewRulerWidth", ()=>this._queueRefresh(!0))), this.register((0, o.addDisposableDomListener)(this._coreBrowseService.window, "resize", ()=>this._queueRefresh(!0))), this._queueRefresh(!0);
                    }
                    _refreshDrawConstants() {
                        const e = Math.floor(this._canvas.width / 3), t = Math.ceil(this._canvas.width / 3);
                        d.full = this._canvas.width, d.left = e, d.center = t, d.right = e, this._refreshDrawHeightConstants(), _.full = 0, _.left = 0, _.center = d.left, _.right = d.left + d.center;
                    }
                    _refreshDrawHeightConstants() {
                        l.full = Math.round(2 * this._coreBrowseService.dpr);
                        const e = this._canvas.height / this._bufferService.buffer.lines.length, t = Math.round(Math.max(Math.min(e, 12), 6) * this._coreBrowseService.dpr);
                        l.left = t, l.center = t, l.right = t;
                    }
                    _refreshColorZonePadding() {
                        this._colorZoneStore.setPadding({
                            full: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * l.full),
                            left: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * l.left),
                            center: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * l.center),
                            right: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * l.right)
                        }), this._lastKnownBufferLength = this._bufferService.buffers.normal.lines.length;
                    }
                    _refreshCanvasDimensions() {
                        this._canvas.style.width = `${this._width}px`, this._canvas.width = Math.round(this._width * this._coreBrowseService.dpr), this._canvas.style.height = `${this._screenElement.clientHeight}px`, this._canvas.height = Math.round(this._screenElement.clientHeight * this._coreBrowseService.dpr), this._refreshDrawConstants(), this._refreshColorZonePadding();
                    }
                    _refreshDecorations() {
                        this._shouldUpdateDimensions && this._refreshCanvasDimensions(), this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height), this._colorZoneStore.clear();
                        for (const e of this._decorationService.decorations)this._colorZoneStore.addDecoration(e);
                        this._ctx.lineWidth = 1;
                        const e = this._colorZoneStore.zones;
                        for (const t of e)"full" !== t.position && this._renderColorZone(t);
                        for (const t of e)"full" === t.position && this._renderColorZone(t);
                        this._shouldUpdateDimensions = !1, this._shouldUpdateAnchor = !1;
                    }
                    _renderColorZone(e) {
                        this._ctx.fillStyle = e.color, this._ctx.fillRect(_[e.position || "full"], Math.round((this._canvas.height - 1) * (e.startBufferLine / this._bufferService.buffers.active.lines.length) - l[e.position || "full"] / 2), d[e.position || "full"], Math.round((this._canvas.height - 1) * ((e.endBufferLine - e.startBufferLine) / this._bufferService.buffers.active.lines.length) + l[e.position || "full"]));
                    }
                    _queueRefresh(e, t) {
                        this._shouldUpdateDimensions = e || this._shouldUpdateDimensions, this._shouldUpdateAnchor = t || this._shouldUpdateAnchor, void 0 === this._animationFrame && (this._animationFrame = this._coreBrowseService.window.requestAnimationFrame(()=>{
                            this._refreshDecorations(), this._animationFrame = void 0;
                        }));
                    }
                };
                u = s([
                    r(2, c.IBufferService),
                    r(3, c.IDecorationService),
                    r(4, a.IRenderService),
                    r(5, c.IOptionsService),
                    r(6, a.ICoreBrowserService)
                ], u), t.OverviewRulerRenderer = u;
            },
            2950: function(e, t, i) {
                var s = this && this.__decorate || function(e, t, i, s) {
                    var r, n = arguments.length, o = n < 3 ? t : null === s ? s = Object.getOwnPropertyDescriptor(t, i) : s;
                    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, i, s);
                    else for(var a = e.length - 1; a >= 0; a--)(r = e[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(t, i, o) : r(t, i)) || o);
                    return n > 3 && o && Object.defineProperty(t, i, o), o;
                }, r = this && this.__param || function(e, t) {
                    return function(i, s) {
                        t(i, s, e);
                    };
                };
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.CompositionHelper = void 0;
                const n = i(4725), o = i(2585), a = i(2584);
                let h = class {
                    constructor(e, t, i, s, r, n){
                        this._textarea = e, this._compositionView = t, this._bufferService = i, this._optionsService = s, this._coreService = r, this._renderService = n, this._isComposing = !1, this._isSendingComposition = !1, this._compositionPosition = {
                            start: 0,
                            end: 0
                        }, this._dataAlreadySent = "";
                    }
                    get isComposing() {
                        return this._isComposing;
                    }
                    compositionstart() {
                        this._isComposing = !0, this._compositionPosition.start = this._textarea.value.length, this._compositionView.textContent = "", this._dataAlreadySent = "", this._compositionView.classList.add("active");
                    }
                    compositionupdate(e) {
                        this._compositionView.textContent = e.data, this.updateCompositionElements(), setTimeout(()=>{
                            this._compositionPosition.end = this._textarea.value.length;
                        }, 0);
                    }
                    compositionend() {
                        this._finalizeComposition(!0);
                    }
                    keydown(e) {
                        if (this._isComposing || this._isSendingComposition) {
                            if (229 === e.keyCode) return !1;
                            if (16 === e.keyCode || 17 === e.keyCode || 18 === e.keyCode) return !1;
                            this._finalizeComposition(!1);
                        }
                        return 229 !== e.keyCode || (this._handleAnyTextareaChanges(), !1);
                    }
                    _finalizeComposition(e) {
                        if (this._compositionView.classList.remove("active"), this._isComposing = !1, e) {
                            const e = {
                                start: this._compositionPosition.start,
                                end: this._compositionPosition.end
                            };
                            this._isSendingComposition = !0, setTimeout(()=>{
                                if (this._isSendingComposition) {
                                    let t;
                                    this._isSendingComposition = !1, e.start += this._dataAlreadySent.length, t = this._isComposing ? this._textarea.value.substring(e.start, e.end) : this._textarea.value.substring(e.start), t.length > 0 && this._coreService.triggerDataEvent(t, !0);
                                }
                            }, 0);
                        } else {
                            this._isSendingComposition = !1;
                            const e = this._textarea.value.substring(this._compositionPosition.start, this._compositionPosition.end);
                            this._coreService.triggerDataEvent(e, !0);
                        }
                    }
                    _handleAnyTextareaChanges() {
                        const e = this._textarea.value;
                        setTimeout(()=>{
                            if (!this._isComposing) {
                                const t = this._textarea.value, i = t.replace(e, "");
                                this._dataAlreadySent = i, t.length > e.length ? this._coreService.triggerDataEvent(i, !0) : t.length < e.length ? this._coreService.triggerDataEvent(`${a.C0.DEL}`, !0) : t.length === e.length && t !== e && this._coreService.triggerDataEvent(t, !0);
                            }
                        }, 0);
                    }
                    updateCompositionElements(e) {
                        if (this._isComposing) {
                            if (this._bufferService.buffer.isCursorInViewport) {
                                const e = Math.min(this._bufferService.buffer.x, this._bufferService.cols - 1), t = this._renderService.dimensions.css.cell.height, i = this._bufferService.buffer.y * this._renderService.dimensions.css.cell.height, s = e * this._renderService.dimensions.css.cell.width;
                                this._compositionView.style.left = s + "px", this._compositionView.style.top = i + "px", this._compositionView.style.height = t + "px", this._compositionView.style.lineHeight = t + "px", this._compositionView.style.fontFamily = this._optionsService.rawOptions.fontFamily, this._compositionView.style.fontSize = this._optionsService.rawOptions.fontSize + "px";
                                const r = this._compositionView.getBoundingClientRect();
                                this._textarea.style.left = s + "px", this._textarea.style.top = i + "px", this._textarea.style.width = Math.max(r.width, 1) + "px", this._textarea.style.height = Math.max(r.height, 1) + "px", this._textarea.style.lineHeight = r.height + "px";
                            }
                            e || setTimeout(()=>this.updateCompositionElements(!0), 0);
                        }
                    }
                };
                h = s([
                    r(2, o.IBufferService),
                    r(3, o.IOptionsService),
                    r(4, o.ICoreService),
                    r(5, n.IRenderService)
                ], h), t.CompositionHelper = h;
            },
            9806: (e, t)=>{
                function i(e, t, i) {
                    const s = i.getBoundingClientRect(), r = e.getComputedStyle(i), n = parseInt(r.getPropertyValue("padding-left")), o = parseInt(r.getPropertyValue("padding-top"));
                    return [
                        t.clientX - s.left - n,
                        t.clientY - s.top - o
                    ];
                }
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.getCoords = t.getCoordsRelativeToElement = void 0, t.getCoordsRelativeToElement = i, t.getCoords = function(e, t, s, r, n, o, a, h, c) {
                    if (!o) return;
                    const l = i(e, t, s);
                    return l ? (l[0] = Math.ceil((l[0] + (c ? a / 2 : 0)) / a), l[1] = Math.ceil(l[1] / h), l[0] = Math.min(Math.max(l[0], 1), r + (c ? 1 : 0)), l[1] = Math.min(Math.max(l[1], 1), n), l) : void 0;
                };
            },
            9504: (e, t, i)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.moveToCellSequence = void 0;
                const s = i(2584);
                function r(e, t, i, s) {
                    const r = e - n(e, i), a = t - n(t, i), l = Math.abs(r - a) - function(e, t, i) {
                        let s = 0;
                        const r = e - n(e, i), a = t - n(t, i);
                        for(let n = 0; n < Math.abs(r - a); n++){
                            const a = "A" === o(e, t) ? -1 : 1, h = i.buffer.lines.get(r + a * n);
                            (null == h ? void 0 : h.isWrapped) && s++;
                        }
                        return s;
                    }(e, t, i);
                    return c(l, h(o(e, t), s));
                }
                function n(e, t) {
                    let i = 0, s = t.buffer.lines.get(e), r = null == s ? void 0 : s.isWrapped;
                    for(; r && e >= 0 && e < t.rows;)i++, s = t.buffer.lines.get(--e), r = null == s ? void 0 : s.isWrapped;
                    return i;
                }
                function o(e, t) {
                    return e > t ? "A" : "B";
                }
                function a(e, t, i, s, r, n) {
                    let o = e, a = t, h = "";
                    for(; o !== i || a !== s;)o += r ? 1 : -1, r && o > n.cols - 1 ? (h += n.buffer.translateBufferLineToString(a, !1, e, o), o = 0, e = 0, a++) : !r && o < 0 && (h += n.buffer.translateBufferLineToString(a, !1, 0, e + 1), o = n.cols - 1, e = o, a--);
                    return h + n.buffer.translateBufferLineToString(a, !1, e, o);
                }
                function h(e, t) {
                    const i = t ? "O" : "[";
                    return s.C0.ESC + i + e;
                }
                function c(e, t) {
                    e = Math.floor(e);
                    let i = "";
                    for(let s = 0; s < e; s++)i += t;
                    return i;
                }
                t.moveToCellSequence = function(e, t, i, s) {
                    const o = i.buffer.x, l = i.buffer.y;
                    if (!i.buffer.hasScrollback) return function(e, t, i, s, o, l) {
                        return 0 === r(t, s, o, l).length ? "" : c(a(e, t, e, t - n(t, o), !1, o).length, h("D", l));
                    }(o, l, 0, t, i, s) + r(l, t, i, s) + function(e, t, i, s, o, l) {
                        let d;
                        d = r(t, s, o, l).length > 0 ? s - n(s, o) : t;
                        const _ = s, u = function(e, t, i, s, o, a) {
                            let h;
                            return h = r(i, s, o, a).length > 0 ? s - n(s, o) : t, e < i && h <= s || e >= i && h < s ? "C" : "D";
                        }(e, t, i, s, o, l);
                        return c(a(e, d, i, _, "C" === u, o).length, h(u, l));
                    }(o, l, e, t, i, s);
                    let d;
                    if (l === t) return d = o > e ? "D" : "C", c(Math.abs(o - e), h(d, s));
                    d = l > t ? "D" : "C";
                    const _ = Math.abs(l - t);
                    return c(function(e, t) {
                        return t.cols - e;
                    }(l > t ? e : o, i) + (_ - 1) * i.cols + 1 + ((l > t ? o : e) - 1), h(d, s));
                };
            },
            1296: function(e, t, i) {
                var s = this && this.__decorate || function(e, t, i, s) {
                    var r, n = arguments.length, o = n < 3 ? t : null === s ? s = Object.getOwnPropertyDescriptor(t, i) : s;
                    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, i, s);
                    else for(var a = e.length - 1; a >= 0; a--)(r = e[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(t, i, o) : r(t, i)) || o);
                    return n > 3 && o && Object.defineProperty(t, i, o), o;
                }, r = this && this.__param || function(e, t) {
                    return function(i, s) {
                        t(i, s, e);
                    };
                };
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.DomRenderer = void 0;
                const n = i(3787), o = i(2223), a = i(6171), h = i(4725), c = i(8055), l = i(8460), d = i(844), _ = i(2585), u = "xterm-dom-renderer-owner-", f = "xterm-focus";
                let v = 1, g = class extends d.Disposable {
                    constructor(e, t, i, s, r, o, h, c, _, f){
                        super(), this._element = e, this._screenElement = t, this._viewportElement = i, this._linkifier2 = s, this._charSizeService = o, this._optionsService = h, this._bufferService = c, this._coreBrowserService = _, this._themeService = f, this._terminalClass = v++, this._rowElements = [], this._cellToRowElements = [], this.onRequestRedraw = this.register(new l.EventEmitter).event, this._rowContainer = document.createElement("div"), this._rowContainer.classList.add("xterm-rows"), this._rowContainer.style.lineHeight = "normal", this._rowContainer.setAttribute("aria-hidden", "true"), this._refreshRowElements(this._bufferService.cols, this._bufferService.rows), this._selectionContainer = document.createElement("div"), this._selectionContainer.classList.add("xterm-selection"), this._selectionContainer.setAttribute("aria-hidden", "true"), this.dimensions = (0, a.createRenderDimensions)(), this._updateDimensions(), this.register(this._optionsService.onOptionChange(()=>this._handleOptionsChanged())), this.register(this._themeService.onChangeColors((e)=>this._injectCss(e))), this._injectCss(this._themeService.colors), this._rowFactory = r.createInstance(n.DomRendererRowFactory, document), this._element.classList.add(u + this._terminalClass), this._screenElement.appendChild(this._rowContainer), this._screenElement.appendChild(this._selectionContainer), this.register(this._linkifier2.onShowLinkUnderline((e)=>this._handleLinkHover(e))), this.register(this._linkifier2.onHideLinkUnderline((e)=>this._handleLinkLeave(e))), this.register((0, d.toDisposable)(()=>{
                            this._element.classList.remove(u + this._terminalClass), this._rowContainer.remove(), this._selectionContainer.remove(), this._themeStyleElement.remove(), this._dimensionsStyleElement.remove();
                        }));
                    }
                    _updateDimensions() {
                        const e = this._coreBrowserService.dpr;
                        this.dimensions.device.char.width = this._charSizeService.width * e, this.dimensions.device.char.height = Math.ceil(this._charSizeService.height * e), this.dimensions.device.cell.width = this.dimensions.device.char.width + Math.round(this._optionsService.rawOptions.letterSpacing), this.dimensions.device.cell.height = Math.floor(this.dimensions.device.char.height * this._optionsService.rawOptions.lineHeight), this.dimensions.device.char.left = 0, this.dimensions.device.char.top = 0, this.dimensions.device.canvas.width = this.dimensions.device.cell.width * this._bufferService.cols, this.dimensions.device.canvas.height = this.dimensions.device.cell.height * this._bufferService.rows, this.dimensions.css.canvas.width = Math.round(this.dimensions.device.canvas.width / e), this.dimensions.css.canvas.height = Math.round(this.dimensions.device.canvas.height / e), this.dimensions.css.cell.width = this.dimensions.css.canvas.width / this._bufferService.cols, this.dimensions.css.cell.height = this.dimensions.css.canvas.height / this._bufferService.rows;
                        for (const e of this._rowElements)e.style.width = `${this.dimensions.css.canvas.width}px`, e.style.height = `${this.dimensions.css.cell.height}px`, e.style.lineHeight = `${this.dimensions.css.cell.height}px`, e.style.overflow = "hidden";
                        this._dimensionsStyleElement || (this._dimensionsStyleElement = document.createElement("style"), this._screenElement.appendChild(this._dimensionsStyleElement));
                        const t = `${this._terminalSelector} .xterm-rows span { display: inline-block; height: 100%; vertical-align: top; width: ${this.dimensions.css.cell.width}px}`;
                        this._dimensionsStyleElement.textContent = t, this._selectionContainer.style.height = this._viewportElement.style.height, this._screenElement.style.width = `${this.dimensions.css.canvas.width}px`, this._screenElement.style.height = `${this.dimensions.css.canvas.height}px`;
                    }
                    _injectCss(e) {
                        this._themeStyleElement || (this._themeStyleElement = document.createElement("style"), this._screenElement.appendChild(this._themeStyleElement));
                        let t = `${this._terminalSelector} .xterm-rows { color: ${e.foreground.css}; font-family: ${this._optionsService.rawOptions.fontFamily}; font-size: ${this._optionsService.rawOptions.fontSize}px;}`;
                        t += `${this._terminalSelector} .xterm-rows .xterm-dim { color: ${c.color.multiplyOpacity(e.foreground, .5).css};}`, t += `${this._terminalSelector} span:not(.${n.BOLD_CLASS}) { font-weight: ${this._optionsService.rawOptions.fontWeight};}${this._terminalSelector} span.${n.BOLD_CLASS} { font-weight: ${this._optionsService.rawOptions.fontWeightBold};}${this._terminalSelector} span.${n.ITALIC_CLASS} { font-style: italic;}`, t += "@keyframes blink_box_shadow_" + this._terminalClass + " { 50% {  box-shadow: none; }}", t += "@keyframes blink_block_" + this._terminalClass + " { 0% {" + `  background-color: ${e.cursor.css};` + `  color: ${e.cursorAccent.css}; } 50% {` + `  background-color: ${e.cursorAccent.css};` + `  color: ${e.cursor.css}; }}`, t += `${this._terminalSelector} .xterm-rows:not(.xterm-focus) .${n.CURSOR_CLASS}.${n.CURSOR_STYLE_BLOCK_CLASS} ,${this._terminalSelector} .xterm-rows:not(.xterm-focus) .${n.CURSOR_CLASS}.${n.CURSOR_STYLE_BAR_CLASS} ,${this._terminalSelector} .xterm-rows:not(.xterm-focus) .${n.CURSOR_CLASS}.${n.CURSOR_STYLE_UNDERLINE_CLASS} { outline: 1px solid ${e.cursor.css}; outline-offset: -1px;}${this._terminalSelector} .xterm-rows.xterm-focus .${n.CURSOR_CLASS}.${n.CURSOR_BLINK_CLASS}:not(.${n.CURSOR_STYLE_BLOCK_CLASS}) { animation: blink_box_shadow_` + this._terminalClass + " 1s step-end infinite;}" + `${this._terminalSelector} .xterm-rows.xterm-focus .${n.CURSOR_CLASS}.${n.CURSOR_BLINK_CLASS}.${n.CURSOR_STYLE_BLOCK_CLASS} { animation: blink_block_` + this._terminalClass + " 1s step-end infinite;}" + `${this._terminalSelector} .xterm-rows.xterm-focus .${n.CURSOR_CLASS}.${n.CURSOR_STYLE_BLOCK_CLASS} {` + ` background-color: ${e.cursor.css};` + ` color: ${e.cursorAccent.css};}` + `${this._terminalSelector} .xterm-rows .${n.CURSOR_CLASS}.${n.CURSOR_STYLE_BAR_CLASS} {` + ` box-shadow: ${this._optionsService.rawOptions.cursorWidth}px 0 0 ${e.cursor.css} inset;}` + `${this._terminalSelector} .xterm-rows .${n.CURSOR_CLASS}.${n.CURSOR_STYLE_UNDERLINE_CLASS} {` + ` box-shadow: 0 -1px 0 ${e.cursor.css} inset;}`, t += `${this._terminalSelector} .xterm-selection { position: absolute; top: 0; left: 0; z-index: 1; pointer-events: none;}${this._terminalSelector}.focus .xterm-selection div { position: absolute; background-color: ${e.selectionBackgroundOpaque.css};}${this._terminalSelector} .xterm-selection div { position: absolute; background-color: ${e.selectionInactiveBackgroundOpaque.css};}`;
                        for (const [i, s] of e.ansi.entries())t += `${this._terminalSelector} .xterm-fg-${i} { color: ${s.css}; }${this._terminalSelector} .xterm-fg-${i}.${n.DIM_CLASS} { color: ${c.color.multiplyOpacity(s, .5).css}; }${this._terminalSelector} .xterm-bg-${i} { background-color: ${s.css}; }`;
                        t += `${this._terminalSelector} .xterm-fg-${o.INVERTED_DEFAULT_COLOR} { color: ${c.color.opaque(e.background).css}; }${this._terminalSelector} .xterm-fg-${o.INVERTED_DEFAULT_COLOR}.${n.DIM_CLASS} { color: ${c.color.multiplyOpacity(c.color.opaque(e.background), .5).css}; }${this._terminalSelector} .xterm-bg-${o.INVERTED_DEFAULT_COLOR} { background-color: ${e.foreground.css}; }`, this._themeStyleElement.textContent = t;
                    }
                    handleDevicePixelRatioChange() {
                        this._updateDimensions();
                    }
                    _refreshRowElements(e, t) {
                        for(let e = this._rowElements.length; e <= t; e++){
                            const e = document.createElement("div");
                            this._rowContainer.appendChild(e), this._rowElements.push(e);
                        }
                        for(; this._rowElements.length > t;)this._rowContainer.removeChild(this._rowElements.pop());
                    }
                    handleResize(e, t) {
                        this._refreshRowElements(e, t), this._updateDimensions();
                    }
                    handleCharSizeChanged() {
                        this._updateDimensions();
                    }
                    handleBlur() {
                        this._rowContainer.classList.remove(f);
                    }
                    handleFocus() {
                        this._rowContainer.classList.add(f);
                    }
                    handleSelectionChanged(e, t, i) {
                        for(; this._selectionContainer.children.length;)this._selectionContainer.removeChild(this._selectionContainer.children[0]);
                        if (this._rowFactory.handleSelectionChanged(e, t, i), this.renderRows(0, this._bufferService.rows - 1), !e || !t) return;
                        const s = e[1] - this._bufferService.buffer.ydisp, r = t[1] - this._bufferService.buffer.ydisp, n = Math.max(s, 0), o = Math.min(r, this._bufferService.rows - 1);
                        if (n >= this._bufferService.rows || o < 0) return;
                        const a = document.createDocumentFragment();
                        if (i) {
                            const i = e[0] > t[0];
                            a.appendChild(this._createSelectionElement(n, i ? t[0] : e[0], i ? e[0] : t[0], o - n + 1));
                        } else {
                            const i = s === n ? e[0] : 0, h = n === r ? t[0] : this._bufferService.cols;
                            a.appendChild(this._createSelectionElement(n, i, h));
                            const c = o - n - 1;
                            if (a.appendChild(this._createSelectionElement(n + 1, 0, this._bufferService.cols, c)), n !== o) {
                                const e = r === o ? t[0] : this._bufferService.cols;
                                a.appendChild(this._createSelectionElement(o, 0, e));
                            }
                        }
                        this._selectionContainer.appendChild(a);
                    }
                    _createSelectionElement(e, t, i, s = 1) {
                        const r = document.createElement("div");
                        return r.style.height = s * this.dimensions.css.cell.height + "px", r.style.top = e * this.dimensions.css.cell.height + "px", r.style.left = t * this.dimensions.css.cell.width + "px", r.style.width = this.dimensions.css.cell.width * (i - t) + "px", r;
                    }
                    handleCursorMove() {}
                    _handleOptionsChanged() {
                        this._updateDimensions(), this._injectCss(this._themeService.colors);
                    }
                    clear() {
                        for (const e of this._rowElements)e.replaceChildren();
                    }
                    renderRows(e, t) {
                        const i = this._bufferService.buffer.ybase + this._bufferService.buffer.y, s = Math.min(this._bufferService.buffer.x, this._bufferService.cols - 1), r = this._optionsService.rawOptions.cursorBlink;
                        for(let n = e; n <= t; n++){
                            const e = this._rowElements[n], t = n + this._bufferService.buffer.ydisp, o = this._bufferService.buffer.lines.get(t), a = this._optionsService.rawOptions.cursorStyle;
                            this._cellToRowElements[n] && this._cellToRowElements[n].length === this._bufferService.cols || (this._cellToRowElements[n] = new Int16Array(this._bufferService.cols)), e.replaceChildren(this._rowFactory.createRow(o, t, t === i, a, s, r, this.dimensions.css.cell.width, this._bufferService.cols, this._cellToRowElements[n]));
                        }
                    }
                    get _terminalSelector() {
                        return `.${u}${this._terminalClass}`;
                    }
                    _handleLinkHover(e) {
                        this._setCellUnderline(e.x1, e.x2, e.y1, e.y2, e.cols, !0);
                    }
                    _handleLinkLeave(e) {
                        this._setCellUnderline(e.x1, e.x2, e.y1, e.y2, e.cols, !1);
                    }
                    _setCellUnderline(e, t, i, s, r, n) {
                        i < 0 && (e = 0), s < 0 && (t = 0);
                        const o = this._cellToRowElements.length - 1;
                        i = Math.max(Math.min(i, o), 0), s = Math.max(Math.min(s, o), 0);
                        const a = this._cellToRowElements[i], h = this._cellToRowElements[s];
                        if (!(e >= a.length || t >= h.length) && (e = a[e], t = h[t], -1 !== e && -1 !== t)) for(; e !== t || i !== s;){
                            const t = this._rowElements[i];
                            if (!t) return;
                            const s = t.children[e];
                            s && (s.style.textDecoration = n ? "underline" : "none"), ++e >= r && (e = 0, i++);
                        }
                    }
                };
                g = s([
                    r(4, _.IInstantiationService),
                    r(5, h.ICharSizeService),
                    r(6, _.IOptionsService),
                    r(7, _.IBufferService),
                    r(8, h.ICoreBrowserService),
                    r(9, h.IThemeService)
                ], g), t.DomRenderer = g;
            },
            3787: function(e, t, i) {
                var s = this && this.__decorate || function(e, t, i, s) {
                    var r, n = arguments.length, o = n < 3 ? t : null === s ? s = Object.getOwnPropertyDescriptor(t, i) : s;
                    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, i, s);
                    else for(var a = e.length - 1; a >= 0; a--)(r = e[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(t, i, o) : r(t, i)) || o);
                    return n > 3 && o && Object.defineProperty(t, i, o), o;
                }, r = this && this.__param || function(e, t) {
                    return function(i, s) {
                        t(i, s, e);
                    };
                };
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.DomRendererRowFactory = t.CURSOR_STYLE_UNDERLINE_CLASS = t.CURSOR_STYLE_BAR_CLASS = t.CURSOR_STYLE_BLOCK_CLASS = t.CURSOR_BLINK_CLASS = t.CURSOR_CLASS = t.STRIKETHROUGH_CLASS = t.OVERLINE_CLASS = t.UNDERLINE_CLASS = t.ITALIC_CLASS = t.DIM_CLASS = t.BOLD_CLASS = void 0;
                const n = i(2223), o = i(643), a = i(511), h = i(2585), c = i(8055), l = i(4725), d = i(4269), _ = i(6171), u = i(3734);
                t.BOLD_CLASS = "xterm-bold", t.DIM_CLASS = "xterm-dim", t.ITALIC_CLASS = "xterm-italic", t.UNDERLINE_CLASS = "xterm-underline", t.OVERLINE_CLASS = "xterm-overline", t.STRIKETHROUGH_CLASS = "xterm-strikethrough", t.CURSOR_CLASS = "xterm-cursor", t.CURSOR_BLINK_CLASS = "xterm-cursor-blink", t.CURSOR_STYLE_BLOCK_CLASS = "xterm-cursor-block", t.CURSOR_STYLE_BAR_CLASS = "xterm-cursor-bar", t.CURSOR_STYLE_UNDERLINE_CLASS = "xterm-cursor-underline";
                let f = class {
                    constructor(e, t, i, s, r, n, o){
                        this._document = e, this._characterJoinerService = t, this._optionsService = i, this._coreBrowserService = s, this._coreService = r, this._decorationService = n, this._themeService = o, this._workCell = new a.CellData, this._columnSelectMode = !1;
                    }
                    handleSelectionChanged(e, t, i) {
                        this._selectionStart = e, this._selectionEnd = t, this._columnSelectMode = i;
                    }
                    createRow(e, i, s, r, a, h, l, _, f) {
                        const g = this._document.createDocumentFragment(), p = this._characterJoinerService.getJoinedCharacters(i);
                        let S = 0;
                        for(let t = Math.min(e.length, _) - 1; t >= 0; t--)if (e.loadCell(t, this._workCell).getCode() !== o.NULL_CELL_CODE || s && t === a) {
                            S = t + 1;
                            break;
                        }
                        const m = this._themeService.colors;
                        let C = -1, b = 0;
                        for(; b < S; b++){
                            e.loadCell(b, this._workCell);
                            let _ = this._workCell.getWidth();
                            if (0 === _) {
                                f[b] = C;
                                continue;
                            }
                            let S = !1, y = b, w = this._workCell;
                            if (p.length > 0 && b === p[0][0]) {
                                S = !0;
                                const t = p.shift();
                                w = new d.JoinedCellData(this._workCell, e.translateToString(!0, t[0], t[1]), t[1] - t[0]), y = t[1] - 1, _ = w.getWidth();
                            }
                            const E = this._document.createElement("span");
                            if (_ > 1 && (E.style.width = l * _ + "px"), S && (E.style.display = "inline", a >= b && a <= y && (a = b)), !this._coreService.isCursorHidden && s && b === a) switch(E.classList.add(t.CURSOR_CLASS), h && E.classList.add(t.CURSOR_BLINK_CLASS), r){
                                case "bar":
                                    E.classList.add(t.CURSOR_STYLE_BAR_CLASS);
                                    break;
                                case "underline":
                                    E.classList.add(t.CURSOR_STYLE_UNDERLINE_CLASS);
                                    break;
                                default:
                                    E.classList.add(t.CURSOR_STYLE_BLOCK_CLASS);
                            }
                            if (w.isBold() && E.classList.add(t.BOLD_CLASS), w.isItalic() && E.classList.add(t.ITALIC_CLASS), w.isDim() && E.classList.add(t.DIM_CLASS), w.isInvisible() ? E.textContent = o.WHITESPACE_CELL_CHAR : E.textContent = w.getChars() || o.WHITESPACE_CELL_CHAR, w.isUnderline() && (E.classList.add(`${t.UNDERLINE_CLASS}-${w.extended.underlineStyle}`), " " === E.textContent && (E.textContent = "\xa0"), !w.isUnderlineColorDefault())) {
                                if (w.isUnderlineColorRGB()) E.style.textDecorationColor = `rgb(${u.AttributeData.toColorRGB(w.getUnderlineColor()).join(",")})`;
                                else {
                                    let e = w.getUnderlineColor();
                                    this._optionsService.rawOptions.drawBoldTextInBrightColors && w.isBold() && e < 8 && (e += 8), E.style.textDecorationColor = m.ansi[e].css;
                                }
                            }
                            w.isOverline() && (E.classList.add(t.OVERLINE_CLASS), " " === E.textContent && (E.textContent = "\xa0")), w.isStrikethrough() && E.classList.add(t.STRIKETHROUGH_CLASS);
                            let L = w.getFgColor(), k = w.getFgColorMode(), R = w.getBgColor(), D = w.getBgColorMode();
                            const A = !!w.isInverse();
                            if (A) {
                                const e = L;
                                L = R, R = e;
                                const t = k;
                                k = D, D = t;
                            }
                            let x, B, T = !1;
                            this._decorationService.forEachDecorationAtCell(b, i, void 0, (e)=>{
                                "top" !== e.options.layer && T || (e.backgroundColorRGB && (D = 50331648, R = e.backgroundColorRGB.rgba >> 8 & 16777215, x = e.backgroundColorRGB), e.foregroundColorRGB && (k = 50331648, L = e.foregroundColorRGB.rgba >> 8 & 16777215, B = e.foregroundColorRGB), T = "top" === e.options.layer);
                            });
                            const M = this._isCellInSelection(b, i);
                            let O;
                            switch(T || m.selectionForeground && M && (k = 50331648, L = m.selectionForeground.rgba >> 8 & 16777215, B = m.selectionForeground), M && (x = this._coreBrowserService.isFocused ? m.selectionBackgroundOpaque : m.selectionInactiveBackgroundOpaque, T = !0), T && E.classList.add("xterm-decoration-top"), D){
                                case 16777216:
                                case 33554432:
                                    O = m.ansi[R], E.classList.add(`xterm-bg-${R}`);
                                    break;
                                case 50331648:
                                    O = c.rgba.toColor(R >> 16, R >> 8 & 255, 255 & R), this._addStyle(E, `background-color:#${v((R >>> 0).toString(16), "0", 6)}`);
                                    break;
                                default:
                                    A ? (O = m.foreground, E.classList.add(`xterm-bg-${n.INVERTED_DEFAULT_COLOR}`)) : O = m.background;
                            }
                            switch(x || w.isDim() && (x = c.color.multiplyOpacity(O, .5)), k){
                                case 16777216:
                                case 33554432:
                                    w.isBold() && L < 8 && this._optionsService.rawOptions.drawBoldTextInBrightColors && (L += 8), this._applyMinimumContrast(E, O, m.ansi[L], w, x, void 0) || E.classList.add(`xterm-fg-${L}`);
                                    break;
                                case 50331648:
                                    const e1 = c.rgba.toColor(L >> 16 & 255, L >> 8 & 255, 255 & L);
                                    this._applyMinimumContrast(E, O, e1, w, x, B) || this._addStyle(E, `color:#${v(L.toString(16), "0", 6)}`);
                                    break;
                                default:
                                    this._applyMinimumContrast(E, O, m.foreground, w, x, void 0) || A && E.classList.add(`xterm-fg-${n.INVERTED_DEFAULT_COLOR}`);
                            }
                            g.appendChild(E), f[b] = ++C, b = y;
                        }
                        return b < _ - 1 && f.subarray(b).fill(++C), g;
                    }
                    _applyMinimumContrast(e, t, i, s, r, n) {
                        if (1 === this._optionsService.rawOptions.minimumContrastRatio || (0, _.excludeFromContrastRatioDemands)(s.getCode())) return !1;
                        let o;
                        return r || n || (o = this._themeService.colors.contrastCache.getColor(t.rgba, i.rgba)), void 0 === o && (o = c.color.ensureContrastRatio(r || t, n || i, this._optionsService.rawOptions.minimumContrastRatio), this._themeService.colors.contrastCache.setColor((r || t).rgba, (n || i).rgba, null != o ? o : null)), !!o && (this._addStyle(e, `color:${o.css}`), !0);
                    }
                    _addStyle(e, t) {
                        e.setAttribute("style", `${e.getAttribute("style") || ""}${t};`);
                    }
                    _isCellInSelection(e, t) {
                        const i = this._selectionStart, s = this._selectionEnd;
                        return !(!i || !s) && (this._columnSelectMode ? i[0] <= s[0] ? e >= i[0] && t >= i[1] && e < s[0] && t <= s[1] : e < i[0] && t >= i[1] && e >= s[0] && t <= s[1] : t > i[1] && t < s[1] || i[1] === s[1] && t === i[1] && e >= i[0] && e < s[0] || i[1] < s[1] && t === s[1] && e < s[0] || i[1] < s[1] && t === i[1] && e >= i[0]);
                    }
                };
                function v(e, t, i) {
                    for(; e.length < i;)e = t + e;
                    return e;
                }
                f = s([
                    r(1, l.ICharacterJoinerService),
                    r(2, h.IOptionsService),
                    r(3, l.ICoreBrowserService),
                    r(4, h.ICoreService),
                    r(5, h.IDecorationService),
                    r(6, l.IThemeService)
                ], f), t.DomRendererRowFactory = f;
            },
            2223: (e, t, i)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.TEXT_BASELINE = t.DIM_OPACITY = t.INVERTED_DEFAULT_COLOR = void 0;
                const s = i(6114);
                t.INVERTED_DEFAULT_COLOR = 257, t.DIM_OPACITY = .5, t.TEXT_BASELINE = s.isFirefox || s.isLegacyEdge ? "bottom" : "ideographic";
            },
            6171: (e, t)=>{
                function i(e) {
                    return 57508 <= e && e <= 57558;
                }
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.createRenderDimensions = t.excludeFromContrastRatioDemands = t.isRestrictedPowerlineGlyph = t.isPowerlineGlyph = t.throwIfFalsy = void 0, t.throwIfFalsy = function(e) {
                    if (!e) throw new Error("value must not be falsy");
                    return e;
                }, t.isPowerlineGlyph = i, t.isRestrictedPowerlineGlyph = function(e) {
                    return 57520 <= e && e <= 57527;
                }, t.excludeFromContrastRatioDemands = function(e) {
                    return i(e) || function(e) {
                        return 9472 <= e && e <= 9631;
                    }(e);
                }, t.createRenderDimensions = function() {
                    return {
                        css: {
                            canvas: {
                                width: 0,
                                height: 0
                            },
                            cell: {
                                width: 0,
                                height: 0
                            }
                        },
                        device: {
                            canvas: {
                                width: 0,
                                height: 0
                            },
                            cell: {
                                width: 0,
                                height: 0
                            },
                            char: {
                                width: 0,
                                height: 0,
                                left: 0,
                                top: 0
                            }
                        }
                    };
                };
            },
            456: (e, t)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.SelectionModel = void 0, t.SelectionModel = class {
                    constructor(e){
                        this._bufferService = e, this.isSelectAllActive = !1, this.selectionStartLength = 0;
                    }
                    clearSelection() {
                        this.selectionStart = void 0, this.selectionEnd = void 0, this.isSelectAllActive = !1, this.selectionStartLength = 0;
                    }
                    get finalSelectionStart() {
                        return this.isSelectAllActive ? [
                            0,
                            0
                        ] : this.selectionEnd && this.selectionStart && this.areSelectionValuesReversed() ? this.selectionEnd : this.selectionStart;
                    }
                    get finalSelectionEnd() {
                        if (this.isSelectAllActive) return [
                            this._bufferService.cols,
                            this._bufferService.buffer.ybase + this._bufferService.rows - 1
                        ];
                        if (this.selectionStart) {
                            if (!this.selectionEnd || this.areSelectionValuesReversed()) {
                                const e = this.selectionStart[0] + this.selectionStartLength;
                                return e > this._bufferService.cols ? e % this._bufferService.cols == 0 ? [
                                    this._bufferService.cols,
                                    this.selectionStart[1] + Math.floor(e / this._bufferService.cols) - 1
                                ] : [
                                    e % this._bufferService.cols,
                                    this.selectionStart[1] + Math.floor(e / this._bufferService.cols)
                                ] : [
                                    e,
                                    this.selectionStart[1]
                                ];
                            }
                            if (this.selectionStartLength && this.selectionEnd[1] === this.selectionStart[1]) {
                                const e = this.selectionStart[0] + this.selectionStartLength;
                                return e > this._bufferService.cols ? [
                                    e % this._bufferService.cols,
                                    this.selectionStart[1] + Math.floor(e / this._bufferService.cols)
                                ] : [
                                    Math.max(e, this.selectionEnd[0]),
                                    this.selectionEnd[1]
                                ];
                            }
                            return this.selectionEnd;
                        }
                    }
                    areSelectionValuesReversed() {
                        const e = this.selectionStart, t = this.selectionEnd;
                        return !(!e || !t) && (e[1] > t[1] || e[1] === t[1] && e[0] > t[0]);
                    }
                    handleTrim(e) {
                        return this.selectionStart && (this.selectionStart[1] -= e), this.selectionEnd && (this.selectionEnd[1] -= e), this.selectionEnd && this.selectionEnd[1] < 0 ? (this.clearSelection(), !0) : (this.selectionStart && this.selectionStart[1] < 0 && (this.selectionStart[1] = 0), !1);
                    }
                };
            },
            428: function(e, t, i) {
                var s = this && this.__decorate || function(e, t, i, s) {
                    var r, n = arguments.length, o = n < 3 ? t : null === s ? s = Object.getOwnPropertyDescriptor(t, i) : s;
                    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, i, s);
                    else for(var a = e.length - 1; a >= 0; a--)(r = e[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(t, i, o) : r(t, i)) || o);
                    return n > 3 && o && Object.defineProperty(t, i, o), o;
                }, r = this && this.__param || function(e, t) {
                    return function(i, s) {
                        t(i, s, e);
                    };
                };
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.CharSizeService = void 0;
                const n = i(2585), o = i(8460), a = i(844);
                let h = class extends a.Disposable {
                    constructor(e, t, i){
                        super(), this._optionsService = i, this.width = 0, this.height = 0, this._onCharSizeChange = this.register(new o.EventEmitter), this.onCharSizeChange = this._onCharSizeChange.event, this._measureStrategy = new c(e, t, this._optionsService), this.register(this._optionsService.onMultipleOptionChange([
                            "fontFamily",
                            "fontSize"
                        ], ()=>this.measure()));
                    }
                    get hasValidSize() {
                        return this.width > 0 && this.height > 0;
                    }
                    measure() {
                        const e = this._measureStrategy.measure();
                        e.width === this.width && e.height === this.height || (this.width = e.width, this.height = e.height, this._onCharSizeChange.fire());
                    }
                };
                h = s([
                    r(2, n.IOptionsService)
                ], h), t.CharSizeService = h;
                class c {
                    constructor(e, t, i){
                        this._document = e, this._parentElement = t, this._optionsService = i, this._result = {
                            width: 0,
                            height: 0
                        }, this._measureElement = this._document.createElement("span"), this._measureElement.classList.add("xterm-char-measure-element"), this._measureElement.textContent = "W", this._measureElement.setAttribute("aria-hidden", "true"), this._parentElement.appendChild(this._measureElement);
                    }
                    measure() {
                        this._measureElement.style.fontFamily = this._optionsService.rawOptions.fontFamily, this._measureElement.style.fontSize = `${this._optionsService.rawOptions.fontSize}px`;
                        const e = this._measureElement.getBoundingClientRect();
                        return 0 !== e.width && 0 !== e.height && (this._result.width = e.width, this._result.height = Math.ceil(e.height)), this._result;
                    }
                }
            },
            4269: function(e, t, i) {
                var s = this && this.__decorate || function(e, t, i, s) {
                    var r, n = arguments.length, o = n < 3 ? t : null === s ? s = Object.getOwnPropertyDescriptor(t, i) : s;
                    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, i, s);
                    else for(var a = e.length - 1; a >= 0; a--)(r = e[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(t, i, o) : r(t, i)) || o);
                    return n > 3 && o && Object.defineProperty(t, i, o), o;
                }, r = this && this.__param || function(e, t) {
                    return function(i, s) {
                        t(i, s, e);
                    };
                };
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.CharacterJoinerService = t.JoinedCellData = void 0;
                const n = i(3734), o = i(643), a = i(511), h = i(2585);
                class c extends n.AttributeData {
                    constructor(e, t, i){
                        super(), this.content = 0, this.combinedData = "", this.fg = e.fg, this.bg = e.bg, this.combinedData = t, this._width = i;
                    }
                    isCombined() {
                        return 2097152;
                    }
                    getWidth() {
                        return this._width;
                    }
                    getChars() {
                        return this.combinedData;
                    }
                    getCode() {
                        return 2097151;
                    }
                    setFromCharData(e) {
                        throw new Error("not implemented");
                    }
                    getAsCharData() {
                        return [
                            this.fg,
                            this.getChars(),
                            this.getWidth(),
                            this.getCode()
                        ];
                    }
                }
                t.JoinedCellData = c;
                let l = class e {
                    constructor(e){
                        this._bufferService = e, this._characterJoiners = [], this._nextCharacterJoinerId = 0, this._workCell = new a.CellData;
                    }
                    register(e) {
                        const t = {
                            id: this._nextCharacterJoinerId++,
                            handler: e
                        };
                        return this._characterJoiners.push(t), t.id;
                    }
                    deregister(e) {
                        for(let t = 0; t < this._characterJoiners.length; t++)if (this._characterJoiners[t].id === e) return this._characterJoiners.splice(t, 1), !0;
                        return !1;
                    }
                    getJoinedCharacters(e) {
                        if (0 === this._characterJoiners.length) return [];
                        const t = this._bufferService.buffer.lines.get(e);
                        if (!t || 0 === t.length) return [];
                        const i = [], s = t.translateToString(!0);
                        let r = 0, n = 0, a = 0, h = t.getFg(0), c = t.getBg(0);
                        for(let e = 0; e < t.getTrimmedLength(); e++)if (t.loadCell(e, this._workCell), 0 !== this._workCell.getWidth()) {
                            if (this._workCell.fg !== h || this._workCell.bg !== c) {
                                if (e - r > 1) {
                                    const e = this._getJoinedRanges(s, a, n, t, r);
                                    for(let t = 0; t < e.length; t++)i.push(e[t]);
                                }
                                r = e, a = n, h = this._workCell.fg, c = this._workCell.bg;
                            }
                            n += this._workCell.getChars().length || o.WHITESPACE_CELL_CHAR.length;
                        }
                        if (this._bufferService.cols - r > 1) {
                            const e = this._getJoinedRanges(s, a, n, t, r);
                            for(let t = 0; t < e.length; t++)i.push(e[t]);
                        }
                        return i;
                    }
                    _getJoinedRanges(t, i, s, r, n) {
                        const o = t.substring(i, s);
                        let a = [];
                        try {
                            a = this._characterJoiners[0].handler(o);
                        } catch (e) {
                            console.error(e);
                        }
                        for(let t = 1; t < this._characterJoiners.length; t++)try {
                            const i = this._characterJoiners[t].handler(o);
                            for(let t = 0; t < i.length; t++)e._mergeRanges(a, i[t]);
                        } catch (e) {
                            console.error(e);
                        }
                        return this._stringRangesToCellRanges(a, r, n), a;
                    }
                    _stringRangesToCellRanges(e, t, i) {
                        let s = 0, r = !1, n = 0, a = e[s];
                        if (a) {
                            for(let h = i; h < this._bufferService.cols; h++){
                                const i = t.getWidth(h), c = t.getString(h).length || o.WHITESPACE_CELL_CHAR.length;
                                if (0 !== i) {
                                    if (!r && a[0] <= n && (a[0] = h, r = !0), a[1] <= n) {
                                        if (a[1] = h, a = e[++s], !a) break;
                                        a[0] <= n ? (a[0] = h, r = !0) : r = !1;
                                    }
                                    n += c;
                                }
                            }
                            a && (a[1] = this._bufferService.cols);
                        }
                    }
                    static _mergeRanges(e, t) {
                        let i = !1;
                        for(let s = 0; s < e.length; s++){
                            const r = e[s];
                            if (i) {
                                if (t[1] <= r[0]) return e[s - 1][1] = t[1], e;
                                if (t[1] <= r[1]) return e[s - 1][1] = Math.max(t[1], r[1]), e.splice(s, 1), e;
                                e.splice(s, 1), s--;
                            } else {
                                if (t[1] <= r[0]) return e.splice(s, 0, t), e;
                                if (t[1] <= r[1]) return r[0] = Math.min(t[0], r[0]), e;
                                t[0] < r[1] && (r[0] = Math.min(t[0], r[0]), i = !0);
                            }
                        }
                        return i ? e[e.length - 1][1] = t[1] : e.push(t), e;
                    }
                };
                l = s([
                    r(0, h.IBufferService)
                ], l), t.CharacterJoinerService = l;
            },
            5114: (e, t)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.CoreBrowserService = void 0, t.CoreBrowserService = class {
                    constructor(e, t){
                        this._textarea = e, this.window = t, this._isFocused = !1, this._cachedIsFocused = void 0, this._textarea.addEventListener("focus", ()=>this._isFocused = !0), this._textarea.addEventListener("blur", ()=>this._isFocused = !1);
                    }
                    get dpr() {
                        return this.window.devicePixelRatio;
                    }
                    get isFocused() {
                        return void 0 === this._cachedIsFocused && (this._cachedIsFocused = this._isFocused && this._textarea.ownerDocument.hasFocus(), queueMicrotask(()=>this._cachedIsFocused = void 0)), this._cachedIsFocused;
                    }
                };
            },
            8934: function(e, t, i) {
                var s = this && this.__decorate || function(e, t, i, s) {
                    var r, n = arguments.length, o = n < 3 ? t : null === s ? s = Object.getOwnPropertyDescriptor(t, i) : s;
                    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, i, s);
                    else for(var a = e.length - 1; a >= 0; a--)(r = e[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(t, i, o) : r(t, i)) || o);
                    return n > 3 && o && Object.defineProperty(t, i, o), o;
                }, r = this && this.__param || function(e, t) {
                    return function(i, s) {
                        t(i, s, e);
                    };
                };
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.MouseService = void 0;
                const n = i(4725), o = i(9806);
                let a = class {
                    constructor(e, t){
                        this._renderService = e, this._charSizeService = t;
                    }
                    getCoords(e, t, i, s, r) {
                        return (0, o.getCoords)(window, e, t, i, s, this._charSizeService.hasValidSize, this._renderService.dimensions.css.cell.width, this._renderService.dimensions.css.cell.height, r);
                    }
                    getMouseReportCoords(e, t) {
                        const i = (0, o.getCoordsRelativeToElement)(window, e, t);
                        if (!(!this._charSizeService.hasValidSize || i[0] < 0 || i[1] < 0 || i[0] >= this._renderService.dimensions.css.canvas.width || i[1] >= this._renderService.dimensions.css.canvas.height)) return {
                            col: Math.floor(i[0] / this._renderService.dimensions.css.cell.width),
                            row: Math.floor(i[1] / this._renderService.dimensions.css.cell.height),
                            x: Math.floor(i[0]),
                            y: Math.floor(i[1])
                        };
                    }
                };
                a = s([
                    r(0, n.IRenderService),
                    r(1, n.ICharSizeService)
                ], a), t.MouseService = a;
            },
            3230: function(e, t, i) {
                var s = this && this.__decorate || function(e, t, i, s) {
                    var r, n = arguments.length, o = n < 3 ? t : null === s ? s = Object.getOwnPropertyDescriptor(t, i) : s;
                    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, i, s);
                    else for(var a = e.length - 1; a >= 0; a--)(r = e[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(t, i, o) : r(t, i)) || o);
                    return n > 3 && o && Object.defineProperty(t, i, o), o;
                }, r = this && this.__param || function(e, t) {
                    return function(i, s) {
                        t(i, s, e);
                    };
                };
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.RenderService = void 0;
                const n = i(6193), o = i(8460), a = i(844), h = i(5596), c = i(3656), l = i(2585), d = i(4725), _ = i(7226);
                let u = class extends a.Disposable {
                    constructor(e, t, i, s, r, a, l, d){
                        if (super(), this._rowCount = e, this._charSizeService = s, this._pausedResizeTask = new _.DebouncedIdleTask, this._isPaused = !1, this._needsFullRefresh = !1, this._isNextRenderRedrawOnly = !0, this._needsSelectionRefresh = !1, this._canvasWidth = 0, this._canvasHeight = 0, this._selectionState = {
                            start: void 0,
                            end: void 0,
                            columnSelectMode: !1
                        }, this._onDimensionsChange = this.register(new o.EventEmitter), this.onDimensionsChange = this._onDimensionsChange.event, this._onRenderedViewportChange = this.register(new o.EventEmitter), this.onRenderedViewportChange = this._onRenderedViewportChange.event, this._onRender = this.register(new o.EventEmitter), this.onRender = this._onRender.event, this._onRefreshRequest = this.register(new o.EventEmitter), this.onRefreshRequest = this._onRefreshRequest.event, this.register({
                            dispose: ()=>{
                                var e;
                                return null === (e = this._renderer) || void 0 === e ? void 0 : e.dispose();
                            }
                        }), this._renderDebouncer = new n.RenderDebouncer(l.window, (e, t)=>this._renderRows(e, t)), this.register(this._renderDebouncer), this._screenDprMonitor = new h.ScreenDprMonitor(l.window), this._screenDprMonitor.setListener(()=>this.handleDevicePixelRatioChange()), this.register(this._screenDprMonitor), this.register(a.onResize(()=>this._fullRefresh())), this.register(a.buffers.onBufferActivate(()=>{
                            var e;
                            return null === (e = this._renderer) || void 0 === e ? void 0 : e.clear();
                        })), this.register(i.onOptionChange(()=>this._handleOptionsChanged())), this.register(this._charSizeService.onCharSizeChange(()=>this.handleCharSizeChanged())), this.register(r.onDecorationRegistered(()=>this._fullRefresh())), this.register(r.onDecorationRemoved(()=>this._fullRefresh())), this.register(i.onMultipleOptionChange([
                            "customGlyphs",
                            "drawBoldTextInBrightColors",
                            "letterSpacing",
                            "lineHeight",
                            "fontFamily",
                            "fontSize",
                            "fontWeight",
                            "fontWeightBold",
                            "minimumContrastRatio"
                        ], ()=>{
                            this.clear(), this.handleResize(a.cols, a.rows), this._fullRefresh();
                        })), this.register(i.onMultipleOptionChange([
                            "cursorBlink",
                            "cursorStyle"
                        ], ()=>this.refreshRows(a.buffer.y, a.buffer.y, !0))), this.register((0, c.addDisposableDomListener)(l.window, "resize", ()=>this.handleDevicePixelRatioChange())), this.register(d.onChangeColors(()=>this._fullRefresh())), "IntersectionObserver" in l.window) {
                            const e = new l.window.IntersectionObserver((e)=>this._handleIntersectionChange(e[e.length - 1]), {
                                threshold: 0
                            });
                            e.observe(t), this.register({
                                dispose: ()=>e.disconnect()
                            });
                        }
                    }
                    get dimensions() {
                        return this._renderer.dimensions;
                    }
                    _handleIntersectionChange(e) {
                        this._isPaused = void 0 === e.isIntersecting ? 0 === e.intersectionRatio : !e.isIntersecting, this._isPaused || this._charSizeService.hasValidSize || this._charSizeService.measure(), !this._isPaused && this._needsFullRefresh && (this._pausedResizeTask.flush(), this.refreshRows(0, this._rowCount - 1), this._needsFullRefresh = !1);
                    }
                    refreshRows(e, t, i = !1) {
                        this._isPaused ? this._needsFullRefresh = !0 : (i || (this._isNextRenderRedrawOnly = !1), this._renderDebouncer.refresh(e, t, this._rowCount));
                    }
                    _renderRows(e, t) {
                        this._renderer && (e = Math.min(e, this._rowCount - 1), t = Math.min(t, this._rowCount - 1), this._renderer.renderRows(e, t), this._needsSelectionRefresh && (this._renderer.handleSelectionChanged(this._selectionState.start, this._selectionState.end, this._selectionState.columnSelectMode), this._needsSelectionRefresh = !1), this._isNextRenderRedrawOnly || this._onRenderedViewportChange.fire({
                            start: e,
                            end: t
                        }), this._onRender.fire({
                            start: e,
                            end: t
                        }), this._isNextRenderRedrawOnly = !0);
                    }
                    resize(e, t) {
                        this._rowCount = t, this._fireOnCanvasResize();
                    }
                    _handleOptionsChanged() {
                        this._renderer && (this.refreshRows(0, this._rowCount - 1), this._fireOnCanvasResize());
                    }
                    _fireOnCanvasResize() {
                        this._renderer && (this._renderer.dimensions.css.canvas.width === this._canvasWidth && this._renderer.dimensions.css.canvas.height === this._canvasHeight || this._onDimensionsChange.fire(this._renderer.dimensions));
                    }
                    hasRenderer() {
                        return !!this._renderer;
                    }
                    setRenderer(e) {
                        var t;
                        null === (t = this._renderer) || void 0 === t || t.dispose(), this._renderer = e, this._renderer.onRequestRedraw((e)=>this.refreshRows(e.start, e.end, !0)), this._needsSelectionRefresh = !0, this._fullRefresh();
                    }
                    addRefreshCallback(e) {
                        return this._renderDebouncer.addRefreshCallback(e);
                    }
                    _fullRefresh() {
                        this._isPaused ? this._needsFullRefresh = !0 : this.refreshRows(0, this._rowCount - 1);
                    }
                    clearTextureAtlas() {
                        var e, t;
                        this._renderer && (null === (t = (e = this._renderer).clearTextureAtlas) || void 0 === t || t.call(e), this._fullRefresh());
                    }
                    handleDevicePixelRatioChange() {
                        this._charSizeService.measure(), this._renderer && (this._renderer.handleDevicePixelRatioChange(), this.refreshRows(0, this._rowCount - 1));
                    }
                    handleResize(e, t) {
                        this._renderer && (this._isPaused ? this._pausedResizeTask.set(()=>this._renderer.handleResize(e, t)) : this._renderer.handleResize(e, t), this._fullRefresh());
                    }
                    handleCharSizeChanged() {
                        var e;
                        null === (e = this._renderer) || void 0 === e || e.handleCharSizeChanged();
                    }
                    handleBlur() {
                        var e;
                        null === (e = this._renderer) || void 0 === e || e.handleBlur();
                    }
                    handleFocus() {
                        var e;
                        null === (e = this._renderer) || void 0 === e || e.handleFocus();
                    }
                    handleSelectionChanged(e, t, i) {
                        var s;
                        this._selectionState.start = e, this._selectionState.end = t, this._selectionState.columnSelectMode = i, null === (s = this._renderer) || void 0 === s || s.handleSelectionChanged(e, t, i);
                    }
                    handleCursorMove() {
                        var e;
                        null === (e = this._renderer) || void 0 === e || e.handleCursorMove();
                    }
                    clear() {
                        var e;
                        null === (e = this._renderer) || void 0 === e || e.clear();
                    }
                };
                u = s([
                    r(2, l.IOptionsService),
                    r(3, d.ICharSizeService),
                    r(4, l.IDecorationService),
                    r(5, l.IBufferService),
                    r(6, d.ICoreBrowserService),
                    r(7, d.IThemeService)
                ], u), t.RenderService = u;
            },
            9312: function(e, t, i) {
                var s = this && this.__decorate || function(e, t, i, s) {
                    var r, n = arguments.length, o = n < 3 ? t : null === s ? s = Object.getOwnPropertyDescriptor(t, i) : s;
                    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, i, s);
                    else for(var a = e.length - 1; a >= 0; a--)(r = e[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(t, i, o) : r(t, i)) || o);
                    return n > 3 && o && Object.defineProperty(t, i, o), o;
                }, r = this && this.__param || function(e, t) {
                    return function(i, s) {
                        t(i, s, e);
                    };
                };
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.SelectionService = void 0;
                const n = i(6114), o = i(456), a = i(511), h = i(8460), c = i(4725), l = i(2585), d = i(9806), _ = i(9504), u = i(844), f = i(4841), v = String.fromCharCode(160), g = new RegExp(v, "g");
                let p = class extends u.Disposable {
                    constructor(e, t, i, s, r, n, c, l, d){
                        super(), this._element = e, this._screenElement = t, this._linkifier = i, this._bufferService = s, this._coreService = r, this._mouseService = n, this._optionsService = c, this._renderService = l, this._coreBrowserService = d, this._dragScrollAmount = 0, this._enabled = !0, this._workCell = new a.CellData, this._mouseDownTimeStamp = 0, this._oldHasSelection = !1, this._oldSelectionStart = void 0, this._oldSelectionEnd = void 0, this._onLinuxMouseSelection = this.register(new h.EventEmitter), this.onLinuxMouseSelection = this._onLinuxMouseSelection.event, this._onRedrawRequest = this.register(new h.EventEmitter), this.onRequestRedraw = this._onRedrawRequest.event, this._onSelectionChange = this.register(new h.EventEmitter), this.onSelectionChange = this._onSelectionChange.event, this._onRequestScrollLines = this.register(new h.EventEmitter), this.onRequestScrollLines = this._onRequestScrollLines.event, this._mouseMoveListener = (e)=>this._handleMouseMove(e), this._mouseUpListener = (e)=>this._handleMouseUp(e), this._coreService.onUserInput(()=>{
                            this.hasSelection && this.clearSelection();
                        }), this._trimListener = this._bufferService.buffer.lines.onTrim((e)=>this._handleTrim(e)), this.register(this._bufferService.buffers.onBufferActivate((e)=>this._handleBufferActivate(e))), this.enable(), this._model = new o.SelectionModel(this._bufferService), this._activeSelectionMode = 0, this.register((0, u.toDisposable)(()=>{
                            this._removeMouseDownListeners();
                        }));
                    }
                    reset() {
                        this.clearSelection();
                    }
                    disable() {
                        this.clearSelection(), this._enabled = !1;
                    }
                    enable() {
                        this._enabled = !0;
                    }
                    get selectionStart() {
                        return this._model.finalSelectionStart;
                    }
                    get selectionEnd() {
                        return this._model.finalSelectionEnd;
                    }
                    get hasSelection() {
                        const e = this._model.finalSelectionStart, t = this._model.finalSelectionEnd;
                        return !(!e || !t || e[0] === t[0] && e[1] === t[1]);
                    }
                    get selectionText() {
                        const e = this._model.finalSelectionStart, t = this._model.finalSelectionEnd;
                        if (!e || !t) return "";
                        const i = this._bufferService.buffer, s = [];
                        if (3 === this._activeSelectionMode) {
                            if (e[0] === t[0]) return "";
                            const r = e[0] < t[0] ? e[0] : t[0], n = e[0] < t[0] ? t[0] : e[0];
                            for(let o = e[1]; o <= t[1]; o++){
                                const e = i.translateBufferLineToString(o, !0, r, n);
                                s.push(e);
                            }
                        } else {
                            const r = e[1] === t[1] ? t[0] : void 0;
                            s.push(i.translateBufferLineToString(e[1], !0, e[0], r));
                            for(let r = e[1] + 1; r <= t[1] - 1; r++){
                                const e = i.lines.get(r), t = i.translateBufferLineToString(r, !0);
                                (null == e ? void 0 : e.isWrapped) ? s[s.length - 1] += t : s.push(t);
                            }
                            if (e[1] !== t[1]) {
                                const e = i.lines.get(t[1]), r = i.translateBufferLineToString(t[1], !0, 0, t[0]);
                                e && e.isWrapped ? s[s.length - 1] += r : s.push(r);
                            }
                        }
                        return s.map((e)=>e.replace(g, " ")).join(n.isWindows ? "\r\n" : "\n");
                    }
                    clearSelection() {
                        this._model.clearSelection(), this._removeMouseDownListeners(), this.refresh(), this._onSelectionChange.fire();
                    }
                    refresh(e) {
                        this._refreshAnimationFrame || (this._refreshAnimationFrame = this._coreBrowserService.window.requestAnimationFrame(()=>this._refresh())), n.isLinux && e && this.selectionText.length && this._onLinuxMouseSelection.fire(this.selectionText);
                    }
                    _refresh() {
                        this._refreshAnimationFrame = void 0, this._onRedrawRequest.fire({
                            start: this._model.finalSelectionStart,
                            end: this._model.finalSelectionEnd,
                            columnSelectMode: 3 === this._activeSelectionMode
                        });
                    }
                    _isClickInSelection(e) {
                        const t = this._getMouseBufferCoords(e), i = this._model.finalSelectionStart, s = this._model.finalSelectionEnd;
                        return !!(i && s && t) && this._areCoordsInSelection(t, i, s);
                    }
                    isCellInSelection(e, t) {
                        const i = this._model.finalSelectionStart, s = this._model.finalSelectionEnd;
                        return !(!i || !s) && this._areCoordsInSelection([
                            e,
                            t
                        ], i, s);
                    }
                    _areCoordsInSelection(e, t, i) {
                        return e[1] > t[1] && e[1] < i[1] || t[1] === i[1] && e[1] === t[1] && e[0] >= t[0] && e[0] < i[0] || t[1] < i[1] && e[1] === i[1] && e[0] < i[0] || t[1] < i[1] && e[1] === t[1] && e[0] >= t[0];
                    }
                    _selectWordAtCursor(e, t) {
                        var i, s;
                        const r = null === (s = null === (i = this._linkifier.currentLink) || void 0 === i ? void 0 : i.link) || void 0 === s ? void 0 : s.range;
                        if (r) return this._model.selectionStart = [
                            r.start.x - 1,
                            r.start.y - 1
                        ], this._model.selectionStartLength = (0, f.getRangeLength)(r, this._bufferService.cols), this._model.selectionEnd = void 0, !0;
                        const n = this._getMouseBufferCoords(e);
                        return !!n && (this._selectWordAt(n, t), this._model.selectionEnd = void 0, !0);
                    }
                    selectAll() {
                        this._model.isSelectAllActive = !0, this.refresh(), this._onSelectionChange.fire();
                    }
                    selectLines(e, t) {
                        this._model.clearSelection(), e = Math.max(e, 0), t = Math.min(t, this._bufferService.buffer.lines.length - 1), this._model.selectionStart = [
                            0,
                            e
                        ], this._model.selectionEnd = [
                            this._bufferService.cols,
                            t
                        ], this.refresh(), this._onSelectionChange.fire();
                    }
                    _handleTrim(e) {
                        this._model.handleTrim(e) && this.refresh();
                    }
                    _getMouseBufferCoords(e) {
                        const t = this._mouseService.getCoords(e, this._screenElement, this._bufferService.cols, this._bufferService.rows, !0);
                        if (t) return t[0]--, t[1]--, t[1] += this._bufferService.buffer.ydisp, t;
                    }
                    _getMouseEventScrollAmount(e) {
                        let t = (0, d.getCoordsRelativeToElement)(this._coreBrowserService.window, e, this._screenElement)[1];
                        const i = this._renderService.dimensions.css.canvas.height;
                        return t >= 0 && t <= i ? 0 : (t > i && (t -= i), t = Math.min(Math.max(t, -50), 50), t /= 50, t / Math.abs(t) + Math.round(14 * t));
                    }
                    shouldForceSelection(e) {
                        return n.isMac ? e.altKey && this._optionsService.rawOptions.macOptionClickForcesSelection : e.shiftKey;
                    }
                    handleMouseDown(e) {
                        if (this._mouseDownTimeStamp = e.timeStamp, (2 !== e.button || !this.hasSelection) && 0 === e.button) {
                            if (!this._enabled) {
                                if (!this.shouldForceSelection(e)) return;
                                e.stopPropagation();
                            }
                            e.preventDefault(), this._dragScrollAmount = 0, this._enabled && e.shiftKey ? this._handleIncrementalClick(e) : 1 === e.detail ? this._handleSingleClick(e) : 2 === e.detail ? this._handleDoubleClick(e) : 3 === e.detail && this._handleTripleClick(e), this._addMouseDownListeners(), this.refresh(!0);
                        }
                    }
                    _addMouseDownListeners() {
                        this._screenElement.ownerDocument && (this._screenElement.ownerDocument.addEventListener("mousemove", this._mouseMoveListener), this._screenElement.ownerDocument.addEventListener("mouseup", this._mouseUpListener)), this._dragScrollIntervalTimer = this._coreBrowserService.window.setInterval(()=>this._dragScroll(), 50);
                    }
                    _removeMouseDownListeners() {
                        this._screenElement.ownerDocument && (this._screenElement.ownerDocument.removeEventListener("mousemove", this._mouseMoveListener), this._screenElement.ownerDocument.removeEventListener("mouseup", this._mouseUpListener)), this._coreBrowserService.window.clearInterval(this._dragScrollIntervalTimer), this._dragScrollIntervalTimer = void 0;
                    }
                    _handleIncrementalClick(e) {
                        this._model.selectionStart && (this._model.selectionEnd = this._getMouseBufferCoords(e));
                    }
                    _handleSingleClick(e) {
                        if (this._model.selectionStartLength = 0, this._model.isSelectAllActive = !1, this._activeSelectionMode = this.shouldColumnSelect(e) ? 3 : 0, this._model.selectionStart = this._getMouseBufferCoords(e), !this._model.selectionStart) return;
                        this._model.selectionEnd = void 0;
                        const t = this._bufferService.buffer.lines.get(this._model.selectionStart[1]);
                        t && t.length !== this._model.selectionStart[0] && 0 === t.hasWidth(this._model.selectionStart[0]) && this._model.selectionStart[0]++;
                    }
                    _handleDoubleClick(e) {
                        this._selectWordAtCursor(e, !0) && (this._activeSelectionMode = 1);
                    }
                    _handleTripleClick(e) {
                        const t = this._getMouseBufferCoords(e);
                        t && (this._activeSelectionMode = 2, this._selectLineAt(t[1]));
                    }
                    shouldColumnSelect(e) {
                        return e.altKey && !(n.isMac && this._optionsService.rawOptions.macOptionClickForcesSelection);
                    }
                    _handleMouseMove(e) {
                        if (e.stopImmediatePropagation(), !this._model.selectionStart) return;
                        const t = this._model.selectionEnd ? [
                            this._model.selectionEnd[0],
                            this._model.selectionEnd[1]
                        ] : null;
                        if (this._model.selectionEnd = this._getMouseBufferCoords(e), !this._model.selectionEnd) return void this.refresh(!0);
                        2 === this._activeSelectionMode ? this._model.selectionEnd[1] < this._model.selectionStart[1] ? this._model.selectionEnd[0] = 0 : this._model.selectionEnd[0] = this._bufferService.cols : 1 === this._activeSelectionMode && this._selectToWordAt(this._model.selectionEnd), this._dragScrollAmount = this._getMouseEventScrollAmount(e), 3 !== this._activeSelectionMode && (this._dragScrollAmount > 0 ? this._model.selectionEnd[0] = this._bufferService.cols : this._dragScrollAmount < 0 && (this._model.selectionEnd[0] = 0));
                        const i = this._bufferService.buffer;
                        if (this._model.selectionEnd[1] < i.lines.length) {
                            const e = i.lines.get(this._model.selectionEnd[1]);
                            e && 0 === e.hasWidth(this._model.selectionEnd[0]) && this._model.selectionEnd[0]++;
                        }
                        t && t[0] === this._model.selectionEnd[0] && t[1] === this._model.selectionEnd[1] || this.refresh(!0);
                    }
                    _dragScroll() {
                        if (this._model.selectionEnd && this._model.selectionStart && this._dragScrollAmount) {
                            this._onRequestScrollLines.fire({
                                amount: this._dragScrollAmount,
                                suppressScrollEvent: !1
                            });
                            const e = this._bufferService.buffer;
                            this._dragScrollAmount > 0 ? (3 !== this._activeSelectionMode && (this._model.selectionEnd[0] = this._bufferService.cols), this._model.selectionEnd[1] = Math.min(e.ydisp + this._bufferService.rows, e.lines.length - 1)) : (3 !== this._activeSelectionMode && (this._model.selectionEnd[0] = 0), this._model.selectionEnd[1] = e.ydisp), this.refresh();
                        }
                    }
                    _handleMouseUp(e) {
                        const t = e.timeStamp - this._mouseDownTimeStamp;
                        if (this._removeMouseDownListeners(), this.selectionText.length <= 1 && t < 500 && e.altKey && this._optionsService.rawOptions.altClickMovesCursor) {
                            if (this._bufferService.buffer.ybase === this._bufferService.buffer.ydisp) {
                                const t = this._mouseService.getCoords(e, this._element, this._bufferService.cols, this._bufferService.rows, !1);
                                if (t && void 0 !== t[0] && void 0 !== t[1]) {
                                    const e = (0, _.moveToCellSequence)(t[0] - 1, t[1] - 1, this._bufferService, this._coreService.decPrivateModes.applicationCursorKeys);
                                    this._coreService.triggerDataEvent(e, !0);
                                }
                            }
                        } else this._fireEventIfSelectionChanged();
                    }
                    _fireEventIfSelectionChanged() {
                        const e = this._model.finalSelectionStart, t = this._model.finalSelectionEnd, i = !(!e || !t || e[0] === t[0] && e[1] === t[1]);
                        i ? e && t && (this._oldSelectionStart && this._oldSelectionEnd && e[0] === this._oldSelectionStart[0] && e[1] === this._oldSelectionStart[1] && t[0] === this._oldSelectionEnd[0] && t[1] === this._oldSelectionEnd[1] || this._fireOnSelectionChange(e, t, i)) : this._oldHasSelection && this._fireOnSelectionChange(e, t, i);
                    }
                    _fireOnSelectionChange(e, t, i) {
                        this._oldSelectionStart = e, this._oldSelectionEnd = t, this._oldHasSelection = i, this._onSelectionChange.fire();
                    }
                    _handleBufferActivate(e) {
                        this.clearSelection(), this._trimListener.dispose(), this._trimListener = e.activeBuffer.lines.onTrim((e)=>this._handleTrim(e));
                    }
                    _convertViewportColToCharacterIndex(e, t) {
                        let i = t;
                        for(let s = 0; t >= s; s++){
                            const r = e.loadCell(s, this._workCell).getChars().length;
                            0 === this._workCell.getWidth() ? i-- : r > 1 && t !== s && (i += r - 1);
                        }
                        return i;
                    }
                    setSelection(e, t, i) {
                        this._model.clearSelection(), this._removeMouseDownListeners(), this._model.selectionStart = [
                            e,
                            t
                        ], this._model.selectionStartLength = i, this.refresh(), this._fireEventIfSelectionChanged();
                    }
                    rightClickSelect(e) {
                        this._isClickInSelection(e) || (this._selectWordAtCursor(e, !1) && this.refresh(!0), this._fireEventIfSelectionChanged());
                    }
                    _getWordAt(e, t, i = !0, s = !0) {
                        if (e[0] >= this._bufferService.cols) return;
                        const r = this._bufferService.buffer, n = r.lines.get(e[1]);
                        if (!n) return;
                        const o = r.translateBufferLineToString(e[1], !1);
                        let a = this._convertViewportColToCharacterIndex(n, e[0]), h = a;
                        const c = e[0] - a;
                        let l = 0, d = 0, _ = 0, u = 0;
                        if (" " === o.charAt(a)) {
                            for(; a > 0 && " " === o.charAt(a - 1);)a--;
                            for(; h < o.length && " " === o.charAt(h + 1);)h++;
                        } else {
                            let t = e[0], i = e[0];
                            0 === n.getWidth(t) && (l++, t--), 2 === n.getWidth(i) && (d++, i++);
                            const s = n.getString(i).length;
                            for(s > 1 && (u += s - 1, h += s - 1); t > 0 && a > 0 && !this._isCharWordSeparator(n.loadCell(t - 1, this._workCell));){
                                n.loadCell(t - 1, this._workCell);
                                const e = this._workCell.getChars().length;
                                0 === this._workCell.getWidth() ? (l++, t--) : e > 1 && (_ += e - 1, a -= e - 1), a--, t--;
                            }
                            for(; i < n.length && h + 1 < o.length && !this._isCharWordSeparator(n.loadCell(i + 1, this._workCell));){
                                n.loadCell(i + 1, this._workCell);
                                const e = this._workCell.getChars().length;
                                2 === this._workCell.getWidth() ? (d++, i++) : e > 1 && (u += e - 1, h += e - 1), h++, i++;
                            }
                        }
                        h++;
                        let f = a + c - l + _, v = Math.min(this._bufferService.cols, h - a + l + d - _ - u);
                        if (t || "" !== o.slice(a, h).trim()) {
                            if (i && 0 === f && 32 !== n.getCodePoint(0)) {
                                const t = r.lines.get(e[1] - 1);
                                if (t && n.isWrapped && 32 !== t.getCodePoint(this._bufferService.cols - 1)) {
                                    const t = this._getWordAt([
                                        this._bufferService.cols - 1,
                                        e[1] - 1
                                    ], !1, !0, !1);
                                    if (t) {
                                        const e = this._bufferService.cols - t.start;
                                        f -= e, v += e;
                                    }
                                }
                            }
                            if (s && f + v === this._bufferService.cols && 32 !== n.getCodePoint(this._bufferService.cols - 1)) {
                                const t = r.lines.get(e[1] + 1);
                                if ((null == t ? void 0 : t.isWrapped) && 32 !== t.getCodePoint(0)) {
                                    const t = this._getWordAt([
                                        0,
                                        e[1] + 1
                                    ], !1, !1, !0);
                                    t && (v += t.length);
                                }
                            }
                            return {
                                start: f,
                                length: v
                            };
                        }
                    }
                    _selectWordAt(e, t) {
                        const i = this._getWordAt(e, t);
                        if (i) {
                            for(; i.start < 0;)i.start += this._bufferService.cols, e[1]--;
                            this._model.selectionStart = [
                                i.start,
                                e[1]
                            ], this._model.selectionStartLength = i.length;
                        }
                    }
                    _selectToWordAt(e) {
                        const t = this._getWordAt(e, !0);
                        if (t) {
                            let i = e[1];
                            for(; t.start < 0;)t.start += this._bufferService.cols, i--;
                            if (!this._model.areSelectionValuesReversed()) for(; t.start + t.length > this._bufferService.cols;)t.length -= this._bufferService.cols, i++;
                            this._model.selectionEnd = [
                                this._model.areSelectionValuesReversed() ? t.start : t.start + t.length,
                                i
                            ];
                        }
                    }
                    _isCharWordSeparator(e) {
                        return 0 !== e.getWidth() && this._optionsService.rawOptions.wordSeparator.indexOf(e.getChars()) >= 0;
                    }
                    _selectLineAt(e) {
                        const t = this._bufferService.buffer.getWrappedRangeForLine(e), i = {
                            start: {
                                x: 0,
                                y: t.first
                            },
                            end: {
                                x: this._bufferService.cols - 1,
                                y: t.last
                            }
                        };
                        this._model.selectionStart = [
                            0,
                            t.first
                        ], this._model.selectionEnd = void 0, this._model.selectionStartLength = (0, f.getRangeLength)(i, this._bufferService.cols);
                    }
                };
                p = s([
                    r(3, l.IBufferService),
                    r(4, l.ICoreService),
                    r(5, c.IMouseService),
                    r(6, l.IOptionsService),
                    r(7, c.IRenderService),
                    r(8, c.ICoreBrowserService)
                ], p), t.SelectionService = p;
            },
            4725: (e, t, i)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.IThemeService = t.ICharacterJoinerService = t.ISelectionService = t.IRenderService = t.IMouseService = t.ICoreBrowserService = t.ICharSizeService = void 0;
                const s = i(8343);
                t.ICharSizeService = (0, s.createDecorator)("CharSizeService"), t.ICoreBrowserService = (0, s.createDecorator)("CoreBrowserService"), t.IMouseService = (0, s.createDecorator)("MouseService"), t.IRenderService = (0, s.createDecorator)("RenderService"), t.ISelectionService = (0, s.createDecorator)("SelectionService"), t.ICharacterJoinerService = (0, s.createDecorator)("CharacterJoinerService"), t.IThemeService = (0, s.createDecorator)("ThemeService");
            },
            6731: function(e, t, i) {
                var s = this && this.__decorate || function(e, t, i, s) {
                    var r, n = arguments.length, o = n < 3 ? t : null === s ? s = Object.getOwnPropertyDescriptor(t, i) : s;
                    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, i, s);
                    else for(var a = e.length - 1; a >= 0; a--)(r = e[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(t, i, o) : r(t, i)) || o);
                    return n > 3 && o && Object.defineProperty(t, i, o), o;
                }, r = this && this.__param || function(e, t) {
                    return function(i, s) {
                        t(i, s, e);
                    };
                };
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.ThemeService = t.DEFAULT_ANSI_COLORS = void 0;
                const n = i(7239), o = i(8055), a = i(8460), h = i(844), c = i(2585), l = o.css.toColor("#ffffff"), d = o.css.toColor("#000000"), _ = o.css.toColor("#ffffff"), u = o.css.toColor("#000000"), f = {
                    css: "rgba(255, 255, 255, 0.3)",
                    rgba: 4294967117
                };
                t.DEFAULT_ANSI_COLORS = Object.freeze((()=>{
                    const e = [
                        o.css.toColor("#2e3436"),
                        o.css.toColor("#cc0000"),
                        o.css.toColor("#4e9a06"),
                        o.css.toColor("#c4a000"),
                        o.css.toColor("#3465a4"),
                        o.css.toColor("#75507b"),
                        o.css.toColor("#06989a"),
                        o.css.toColor("#d3d7cf"),
                        o.css.toColor("#555753"),
                        o.css.toColor("#ef2929"),
                        o.css.toColor("#8ae234"),
                        o.css.toColor("#fce94f"),
                        o.css.toColor("#729fcf"),
                        o.css.toColor("#ad7fa8"),
                        o.css.toColor("#34e2e2"),
                        o.css.toColor("#eeeeec")
                    ], t = [
                        0,
                        95,
                        135,
                        175,
                        215,
                        255
                    ];
                    for(let i = 0; i < 216; i++){
                        const s = t[i / 36 % 6 | 0], r = t[i / 6 % 6 | 0], n = t[i % 6];
                        e.push({
                            css: o.channels.toCss(s, r, n),
                            rgba: o.channels.toRgba(s, r, n)
                        });
                    }
                    for(let t = 0; t < 24; t++){
                        const i = 8 + 10 * t;
                        e.push({
                            css: o.channels.toCss(i, i, i),
                            rgba: o.channels.toRgba(i, i, i)
                        });
                    }
                    return e;
                })());
                let v = class extends h.Disposable {
                    constructor(e){
                        super(), this._optionsService = e, this._onChangeColors = this.register(new a.EventEmitter), this.onChangeColors = this._onChangeColors.event, this._contrastCache = new n.ColorContrastCache, this._colors = {
                            foreground: l,
                            background: d,
                            cursor: _,
                            cursorAccent: u,
                            selectionForeground: void 0,
                            selectionBackgroundTransparent: f,
                            selectionBackgroundOpaque: o.color.blend(d, f),
                            selectionInactiveBackgroundTransparent: f,
                            selectionInactiveBackgroundOpaque: o.color.blend(d, f),
                            ansi: t.DEFAULT_ANSI_COLORS.slice(),
                            contrastCache: this._contrastCache
                        }, this._updateRestoreColors(), this._setTheme(this._optionsService.rawOptions.theme), this.register(this._optionsService.onSpecificOptionChange("minimumContrastRatio", ()=>this._contrastCache.clear())), this.register(this._optionsService.onSpecificOptionChange("theme", ()=>this._setTheme(this._optionsService.rawOptions.theme)));
                    }
                    get colors() {
                        return this._colors;
                    }
                    _setTheme(e = {}) {
                        const i = this._colors;
                        if (i.foreground = g(e.foreground, l), i.background = g(e.background, d), i.cursor = g(e.cursor, _), i.cursorAccent = g(e.cursorAccent, u), i.selectionBackgroundTransparent = g(e.selectionBackground, f), i.selectionBackgroundOpaque = o.color.blend(i.background, i.selectionBackgroundTransparent), i.selectionInactiveBackgroundTransparent = g(e.selectionInactiveBackground, i.selectionBackgroundTransparent), i.selectionInactiveBackgroundOpaque = o.color.blend(i.background, i.selectionInactiveBackgroundTransparent), i.selectionForeground = e.selectionForeground ? g(e.selectionForeground, o.NULL_COLOR) : void 0, i.selectionForeground === o.NULL_COLOR && (i.selectionForeground = void 0), o.color.isOpaque(i.selectionBackgroundTransparent)) {
                            const e = .3;
                            i.selectionBackgroundTransparent = o.color.opacity(i.selectionBackgroundTransparent, e);
                        }
                        if (o.color.isOpaque(i.selectionInactiveBackgroundTransparent)) {
                            const e = .3;
                            i.selectionInactiveBackgroundTransparent = o.color.opacity(i.selectionInactiveBackgroundTransparent, e);
                        }
                        if (i.ansi = t.DEFAULT_ANSI_COLORS.slice(), i.ansi[0] = g(e.black, t.DEFAULT_ANSI_COLORS[0]), i.ansi[1] = g(e.red, t.DEFAULT_ANSI_COLORS[1]), i.ansi[2] = g(e.green, t.DEFAULT_ANSI_COLORS[2]), i.ansi[3] = g(e.yellow, t.DEFAULT_ANSI_COLORS[3]), i.ansi[4] = g(e.blue, t.DEFAULT_ANSI_COLORS[4]), i.ansi[5] = g(e.magenta, t.DEFAULT_ANSI_COLORS[5]), i.ansi[6] = g(e.cyan, t.DEFAULT_ANSI_COLORS[6]), i.ansi[7] = g(e.white, t.DEFAULT_ANSI_COLORS[7]), i.ansi[8] = g(e.brightBlack, t.DEFAULT_ANSI_COLORS[8]), i.ansi[9] = g(e.brightRed, t.DEFAULT_ANSI_COLORS[9]), i.ansi[10] = g(e.brightGreen, t.DEFAULT_ANSI_COLORS[10]), i.ansi[11] = g(e.brightYellow, t.DEFAULT_ANSI_COLORS[11]), i.ansi[12] = g(e.brightBlue, t.DEFAULT_ANSI_COLORS[12]), i.ansi[13] = g(e.brightMagenta, t.DEFAULT_ANSI_COLORS[13]), i.ansi[14] = g(e.brightCyan, t.DEFAULT_ANSI_COLORS[14]), i.ansi[15] = g(e.brightWhite, t.DEFAULT_ANSI_COLORS[15]), e.extendedAnsi) {
                            const s = Math.min(i.ansi.length - 16, e.extendedAnsi.length);
                            for(let r = 0; r < s; r++)i.ansi[r + 16] = g(e.extendedAnsi[r], t.DEFAULT_ANSI_COLORS[r + 16]);
                        }
                        this._contrastCache.clear(), this._updateRestoreColors(), this._onChangeColors.fire(this.colors);
                    }
                    restoreColor(e) {
                        this._restoreColor(e), this._onChangeColors.fire(this.colors);
                    }
                    _restoreColor(e) {
                        if (void 0 !== e) switch(e){
                            case 256:
                                this._colors.foreground = this._restoreColors.foreground;
                                break;
                            case 257:
                                this._colors.background = this._restoreColors.background;
                                break;
                            case 258:
                                this._colors.cursor = this._restoreColors.cursor;
                                break;
                            default:
                                this._colors.ansi[e] = this._restoreColors.ansi[e];
                        }
                        else for(let e = 0; e < this._restoreColors.ansi.length; ++e)this._colors.ansi[e] = this._restoreColors.ansi[e];
                    }
                    modifyColors(e) {
                        e(this._colors), this._onChangeColors.fire(this.colors);
                    }
                    _updateRestoreColors() {
                        this._restoreColors = {
                            foreground: this._colors.foreground,
                            background: this._colors.background,
                            cursor: this._colors.cursor,
                            ansi: this._colors.ansi.slice()
                        };
                    }
                };
                function g(e, t) {
                    if (void 0 !== e) try {
                        return o.css.toColor(e);
                    } catch (e) {}
                    return t;
                }
                v = s([
                    r(0, c.IOptionsService)
                ], v), t.ThemeService = v;
            },
            6349: (e, t, i)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.CircularList = void 0;
                const s = i(8460), r = i(844);
                class n extends r.Disposable {
                    constructor(e){
                        super(), this._maxLength = e, this.onDeleteEmitter = this.register(new s.EventEmitter), this.onDelete = this.onDeleteEmitter.event, this.onInsertEmitter = this.register(new s.EventEmitter), this.onInsert = this.onInsertEmitter.event, this.onTrimEmitter = this.register(new s.EventEmitter), this.onTrim = this.onTrimEmitter.event, this._array = new Array(this._maxLength), this._startIndex = 0, this._length = 0;
                    }
                    get maxLength() {
                        return this._maxLength;
                    }
                    set maxLength(e) {
                        if (this._maxLength === e) return;
                        const t = new Array(e);
                        for(let i = 0; i < Math.min(e, this.length); i++)t[i] = this._array[this._getCyclicIndex(i)];
                        this._array = t, this._maxLength = e, this._startIndex = 0;
                    }
                    get length() {
                        return this._length;
                    }
                    set length(e) {
                        if (e > this._length) for(let t = this._length; t < e; t++)this._array[t] = void 0;
                        this._length = e;
                    }
                    get(e) {
                        return this._array[this._getCyclicIndex(e)];
                    }
                    set(e, t) {
                        this._array[this._getCyclicIndex(e)] = t;
                    }
                    push(e) {
                        this._array[this._getCyclicIndex(this._length)] = e, this._length === this._maxLength ? (this._startIndex = ++this._startIndex % this._maxLength, this.onTrimEmitter.fire(1)) : this._length++;
                    }
                    recycle() {
                        if (this._length !== this._maxLength) throw new Error("Can only recycle when the buffer is full");
                        return this._startIndex = ++this._startIndex % this._maxLength, this.onTrimEmitter.fire(1), this._array[this._getCyclicIndex(this._length - 1)];
                    }
                    get isFull() {
                        return this._length === this._maxLength;
                    }
                    pop() {
                        return this._array[this._getCyclicIndex(this._length-- - 1)];
                    }
                    splice(e, t, ...i) {
                        if (t) {
                            for(let i = e; i < this._length - t; i++)this._array[this._getCyclicIndex(i)] = this._array[this._getCyclicIndex(i + t)];
                            this._length -= t, this.onDeleteEmitter.fire({
                                index: e,
                                amount: t
                            });
                        }
                        for(let t = this._length - 1; t >= e; t--)this._array[this._getCyclicIndex(t + i.length)] = this._array[this._getCyclicIndex(t)];
                        for(let t = 0; t < i.length; t++)this._array[this._getCyclicIndex(e + t)] = i[t];
                        if (i.length && this.onInsertEmitter.fire({
                            index: e,
                            amount: i.length
                        }), this._length + i.length > this._maxLength) {
                            const e = this._length + i.length - this._maxLength;
                            this._startIndex += e, this._length = this._maxLength, this.onTrimEmitter.fire(e);
                        } else this._length += i.length;
                    }
                    trimStart(e) {
                        e > this._length && (e = this._length), this._startIndex += e, this._length -= e, this.onTrimEmitter.fire(e);
                    }
                    shiftElements(e, t, i) {
                        if (!(t <= 0)) {
                            if (e < 0 || e >= this._length) throw new Error("start argument out of range");
                            if (e + i < 0) throw new Error("Cannot shift elements in list beyond index 0");
                            if (i > 0) {
                                for(let s = t - 1; s >= 0; s--)this.set(e + s + i, this.get(e + s));
                                const s = e + t + i - this._length;
                                if (s > 0) for(this._length += s; this._length > this._maxLength;)this._length--, this._startIndex++, this.onTrimEmitter.fire(1);
                            } else for(let s = 0; s < t; s++)this.set(e + s + i, this.get(e + s));
                        }
                    }
                    _getCyclicIndex(e) {
                        return (this._startIndex + e) % this._maxLength;
                    }
                }
                t.CircularList = n;
            },
            1439: (e, t)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.clone = void 0, t.clone = function e(t, i = 5) {
                    if ("object" != typeof t) return t;
                    const s = Array.isArray(t) ? [] : {};
                    for(const r in t)s[r] = i <= 1 ? t[r] : t[r] && e(t[r], i - 1);
                    return s;
                };
            },
            8055: (e, t, i)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.contrastRatio = t.toPaddedHex = t.rgba = t.rgb = t.css = t.color = t.channels = t.NULL_COLOR = void 0;
                const s = i(6114);
                let r = 0, n = 0, o = 0, a = 0;
                var h, c, l;
                function d(e) {
                    const t = e.toString(16);
                    return t.length < 2 ? "0" + t : t;
                }
                function _(e, t) {
                    return e < t ? (t + .05) / (e + .05) : (e + .05) / (t + .05);
                }
                t.NULL_COLOR = {
                    css: "#00000000",
                    rgba: 0
                }, function(e) {
                    e.toCss = function(e, t, i, s) {
                        return void 0 !== s ? `#${d(e)}${d(t)}${d(i)}${d(s)}` : `#${d(e)}${d(t)}${d(i)}`;
                    }, e.toRgba = function(e, t, i, s = 255) {
                        return (e << 24 | t << 16 | i << 8 | s) >>> 0;
                    };
                }(h = t.channels || (t.channels = {})), function(e) {
                    function t(e, t) {
                        return a = Math.round(255 * t), [r, n, o] = l.toChannels(e.rgba), {
                            css: h.toCss(r, n, o, a),
                            rgba: h.toRgba(r, n, o, a)
                        };
                    }
                    e.blend = function(e, t) {
                        if (a = (255 & t.rgba) / 255, 1 === a) return {
                            css: t.css,
                            rgba: t.rgba
                        };
                        const i = t.rgba >> 24 & 255, s = t.rgba >> 16 & 255, c = t.rgba >> 8 & 255, l = e.rgba >> 24 & 255, d = e.rgba >> 16 & 255, _ = e.rgba >> 8 & 255;
                        return r = l + Math.round((i - l) * a), n = d + Math.round((s - d) * a), o = _ + Math.round((c - _) * a), {
                            css: h.toCss(r, n, o),
                            rgba: h.toRgba(r, n, o)
                        };
                    }, e.isOpaque = function(e) {
                        return 255 == (255 & e.rgba);
                    }, e.ensureContrastRatio = function(e, t, i) {
                        const s = l.ensureContrastRatio(e.rgba, t.rgba, i);
                        if (s) return l.toColor(s >> 24 & 255, s >> 16 & 255, s >> 8 & 255);
                    }, e.opaque = function(e) {
                        const t = (255 | e.rgba) >>> 0;
                        return [r, n, o] = l.toChannels(t), {
                            css: h.toCss(r, n, o),
                            rgba: t
                        };
                    }, e.opacity = t, e.multiplyOpacity = function(e, i) {
                        return a = 255 & e.rgba, t(e, a * i / 255);
                    }, e.toColorRGB = function(e) {
                        return [
                            e.rgba >> 24 & 255,
                            e.rgba >> 16 & 255,
                            e.rgba >> 8 & 255
                        ];
                    };
                }(t.color || (t.color = {})), function(e) {
                    let t, i;
                    if (!s.isNode) {
                        const e = document.createElement("canvas");
                        e.width = 1, e.height = 1;
                        const s = e.getContext("2d", {
                            willReadFrequently: !0
                        });
                        s && (t = s, t.globalCompositeOperation = "copy", i = t.createLinearGradient(0, 0, 1, 1));
                    }
                    e.toColor = function(e) {
                        if (e.match(/#[\da-f]{3,8}/i)) switch(e.length){
                            case 4:
                                return r = parseInt(e.slice(1, 2).repeat(2), 16), n = parseInt(e.slice(2, 3).repeat(2), 16), o = parseInt(e.slice(3, 4).repeat(2), 16), l.toColor(r, n, o);
                            case 5:
                                return r = parseInt(e.slice(1, 2).repeat(2), 16), n = parseInt(e.slice(2, 3).repeat(2), 16), o = parseInt(e.slice(3, 4).repeat(2), 16), a = parseInt(e.slice(4, 5).repeat(2), 16), l.toColor(r, n, o, a);
                            case 7:
                                return {
                                    css: e,
                                    rgba: (parseInt(e.slice(1), 16) << 8 | 255) >>> 0
                                };
                            case 9:
                                return {
                                    css: e,
                                    rgba: parseInt(e.slice(1), 16) >>> 0
                                };
                        }
                        const s = e.match(/rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(,\s*(0|1|\d?\.(\d+))\s*)?\)/);
                        if (s) return r = parseInt(s[1]), n = parseInt(s[2]), o = parseInt(s[3]), a = Math.round(255 * (void 0 === s[5] ? 1 : parseFloat(s[5]))), l.toColor(r, n, o, a);
                        if (!t || !i) throw new Error("css.toColor: Unsupported css format");
                        if (t.fillStyle = i, t.fillStyle = e, "string" != typeof t.fillStyle) throw new Error("css.toColor: Unsupported css format");
                        if (t.fillRect(0, 0, 1, 1), [r, n, o, a] = t.getImageData(0, 0, 1, 1).data, 255 !== a) throw new Error("css.toColor: Unsupported css format");
                        return {
                            rgba: h.toRgba(r, n, o, a),
                            css: e
                        };
                    };
                }(t.css || (t.css = {})), function(e) {
                    function t(e, t, i) {
                        const s = e / 255, r = t / 255, n = i / 255;
                        return .2126 * (s <= .03928 ? s / 12.92 : Math.pow((s + .055) / 1.055, 2.4)) + .7152 * (r <= .03928 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4)) + .0722 * (n <= .03928 ? n / 12.92 : Math.pow((n + .055) / 1.055, 2.4));
                    }
                    e.relativeLuminance = function(e) {
                        return t(e >> 16 & 255, e >> 8 & 255, 255 & e);
                    }, e.relativeLuminance2 = t;
                }(c = t.rgb || (t.rgb = {})), function(e) {
                    function t(e, t, i) {
                        const s = e >> 24 & 255, r = e >> 16 & 255, n = e >> 8 & 255;
                        let o = t >> 24 & 255, a = t >> 16 & 255, h = t >> 8 & 255, l = _(c.relativeLuminance2(o, a, h), c.relativeLuminance2(s, r, n));
                        for(; l < i && (o > 0 || a > 0 || h > 0);)o -= Math.max(0, Math.ceil(.1 * o)), a -= Math.max(0, Math.ceil(.1 * a)), h -= Math.max(0, Math.ceil(.1 * h)), l = _(c.relativeLuminance2(o, a, h), c.relativeLuminance2(s, r, n));
                        return (o << 24 | a << 16 | h << 8 | 255) >>> 0;
                    }
                    function i(e, t, i) {
                        const s = e >> 24 & 255, r = e >> 16 & 255, n = e >> 8 & 255;
                        let o = t >> 24 & 255, a = t >> 16 & 255, h = t >> 8 & 255, l = _(c.relativeLuminance2(o, a, h), c.relativeLuminance2(s, r, n));
                        for(; l < i && (o < 255 || a < 255 || h < 255);)o = Math.min(255, o + Math.ceil(.1 * (255 - o))), a = Math.min(255, a + Math.ceil(.1 * (255 - a))), h = Math.min(255, h + Math.ceil(.1 * (255 - h))), l = _(c.relativeLuminance2(o, a, h), c.relativeLuminance2(s, r, n));
                        return (o << 24 | a << 16 | h << 8 | 255) >>> 0;
                    }
                    e.ensureContrastRatio = function(e, s, r) {
                        const n = c.relativeLuminance(e >> 8), o = c.relativeLuminance(s >> 8);
                        if (_(n, o) < r) {
                            if (o < n) {
                                const o = t(e, s, r), a = _(n, c.relativeLuminance(o >> 8));
                                if (a < r) {
                                    const t = i(e, s, r);
                                    return a > _(n, c.relativeLuminance(t >> 8)) ? o : t;
                                }
                                return o;
                            }
                            const a = i(e, s, r), h = _(n, c.relativeLuminance(a >> 8));
                            if (h < r) {
                                const i = t(e, s, r);
                                return h > _(n, c.relativeLuminance(i >> 8)) ? a : i;
                            }
                            return a;
                        }
                    }, e.reduceLuminance = t, e.increaseLuminance = i, e.toChannels = function(e) {
                        return [
                            e >> 24 & 255,
                            e >> 16 & 255,
                            e >> 8 & 255,
                            255 & e
                        ];
                    }, e.toColor = function(e, t, i, s) {
                        return {
                            css: h.toCss(e, t, i, s),
                            rgba: h.toRgba(e, t, i, s)
                        };
                    };
                }(l = t.rgba || (t.rgba = {})), t.toPaddedHex = d, t.contrastRatio = _;
            },
            8969: (e, t, i)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.CoreTerminal = void 0;
                const s = i(844), r = i(2585), n = i(4348), o = i(7866), a = i(744), h = i(7302), c = i(6975), l = i(8460), d = i(1753), _ = i(1480), u = i(7994), f = i(9282), v = i(5435), g = i(5981), p = i(2660);
                let S = !1;
                class m extends s.Disposable {
                    constructor(e){
                        super(), this._onBinary = this.register(new l.EventEmitter), this.onBinary = this._onBinary.event, this._onData = this.register(new l.EventEmitter), this.onData = this._onData.event, this._onLineFeed = this.register(new l.EventEmitter), this.onLineFeed = this._onLineFeed.event, this._onResize = this.register(new l.EventEmitter), this.onResize = this._onResize.event, this._onWriteParsed = this.register(new l.EventEmitter), this.onWriteParsed = this._onWriteParsed.event, this._onScroll = this.register(new l.EventEmitter), this._instantiationService = new n.InstantiationService, this.optionsService = this.register(new h.OptionsService(e)), this._instantiationService.setService(r.IOptionsService, this.optionsService), this._bufferService = this.register(this._instantiationService.createInstance(a.BufferService)), this._instantiationService.setService(r.IBufferService, this._bufferService), this._logService = this.register(this._instantiationService.createInstance(o.LogService)), this._instantiationService.setService(r.ILogService, this._logService), this.coreService = this.register(this._instantiationService.createInstance(c.CoreService)), this._instantiationService.setService(r.ICoreService, this.coreService), this.coreMouseService = this.register(this._instantiationService.createInstance(d.CoreMouseService)), this._instantiationService.setService(r.ICoreMouseService, this.coreMouseService), this.unicodeService = this.register(this._instantiationService.createInstance(_.UnicodeService)), this._instantiationService.setService(r.IUnicodeService, this.unicodeService), this._charsetService = this._instantiationService.createInstance(u.CharsetService), this._instantiationService.setService(r.ICharsetService, this._charsetService), this._oscLinkService = this._instantiationService.createInstance(p.OscLinkService), this._instantiationService.setService(r.IOscLinkService, this._oscLinkService), this._inputHandler = this.register(new v.InputHandler(this._bufferService, this._charsetService, this.coreService, this._logService, this.optionsService, this._oscLinkService, this.coreMouseService, this.unicodeService)), this.register((0, l.forwardEvent)(this._inputHandler.onLineFeed, this._onLineFeed)), this.register(this._inputHandler), this.register((0, l.forwardEvent)(this._bufferService.onResize, this._onResize)), this.register((0, l.forwardEvent)(this.coreService.onData, this._onData)), this.register((0, l.forwardEvent)(this.coreService.onBinary, this._onBinary)), this.register(this.coreService.onRequestScrollToBottom(()=>this.scrollToBottom())), this.register(this.coreService.onUserInput(()=>this._writeBuffer.handleUserInput())), this.register(this.optionsService.onMultipleOptionChange([
                            "windowsMode",
                            "windowsPty"
                        ], ()=>this._handleWindowsPtyOptionChange())), this.register(this._bufferService.onScroll((e)=>{
                            this._onScroll.fire({
                                position: this._bufferService.buffer.ydisp,
                                source: 0
                            }), this._inputHandler.markRangeDirty(this._bufferService.buffer.scrollTop, this._bufferService.buffer.scrollBottom);
                        })), this.register(this._inputHandler.onScroll((e)=>{
                            this._onScroll.fire({
                                position: this._bufferService.buffer.ydisp,
                                source: 0
                            }), this._inputHandler.markRangeDirty(this._bufferService.buffer.scrollTop, this._bufferService.buffer.scrollBottom);
                        })), this._writeBuffer = this.register(new g.WriteBuffer((e, t)=>this._inputHandler.parse(e, t))), this.register((0, l.forwardEvent)(this._writeBuffer.onWriteParsed, this._onWriteParsed)), this.register((0, s.toDisposable)(()=>{
                            var e;
                            null === (e = this._windowsWrappingHeuristics) || void 0 === e || e.dispose(), this._windowsWrappingHeuristics = void 0;
                        }));
                    }
                    get onScroll() {
                        return this._onScrollApi || (this._onScrollApi = this.register(new l.EventEmitter), this._onScroll.event((e)=>{
                            var t;
                            null === (t = this._onScrollApi) || void 0 === t || t.fire(e.position);
                        })), this._onScrollApi.event;
                    }
                    get cols() {
                        return this._bufferService.cols;
                    }
                    get rows() {
                        return this._bufferService.rows;
                    }
                    get buffers() {
                        return this._bufferService.buffers;
                    }
                    get options() {
                        return this.optionsService.options;
                    }
                    set options(e) {
                        for(const t in e)this.optionsService.options[t] = e[t];
                    }
                    write(e, t) {
                        this._writeBuffer.write(e, t);
                    }
                    writeSync(e, t) {
                        this._logService.logLevel <= r.LogLevelEnum.WARN && !S && (this._logService.warn("writeSync is unreliable and will be removed soon."), S = !0), this._writeBuffer.writeSync(e, t);
                    }
                    resize(e, t) {
                        isNaN(e) || isNaN(t) || (e = Math.max(e, a.MINIMUM_COLS), t = Math.max(t, a.MINIMUM_ROWS), this._bufferService.resize(e, t));
                    }
                    scroll(e, t = !1) {
                        this._bufferService.scroll(e, t);
                    }
                    scrollLines(e, t, i) {
                        this._bufferService.scrollLines(e, t, i);
                    }
                    scrollPages(e) {
                        this._bufferService.scrollPages(e);
                    }
                    scrollToTop() {
                        this._bufferService.scrollToTop();
                    }
                    scrollToBottom() {
                        this._bufferService.scrollToBottom();
                    }
                    scrollToLine(e) {
                        this._bufferService.scrollToLine(e);
                    }
                    registerEscHandler(e, t) {
                        return this._inputHandler.registerEscHandler(e, t);
                    }
                    registerDcsHandler(e, t) {
                        return this._inputHandler.registerDcsHandler(e, t);
                    }
                    registerCsiHandler(e, t) {
                        return this._inputHandler.registerCsiHandler(e, t);
                    }
                    registerOscHandler(e, t) {
                        return this._inputHandler.registerOscHandler(e, t);
                    }
                    _setup() {
                        this._handleWindowsPtyOptionChange();
                    }
                    reset() {
                        this._inputHandler.reset(), this._bufferService.reset(), this._charsetService.reset(), this.coreService.reset(), this.coreMouseService.reset();
                    }
                    _handleWindowsPtyOptionChange() {
                        var e;
                        let t = !1;
                        const i = this.optionsService.rawOptions.windowsPty;
                        i && void 0 !== i.buildNumber && void 0 !== i.buildNumber ? t = !!("conpty" === i.backend && i.buildNumber < 21376) : this.optionsService.rawOptions.windowsMode && (t = !0), t ? this._enableWindowsWrappingHeuristics() : (null === (e = this._windowsWrappingHeuristics) || void 0 === e || e.dispose(), this._windowsWrappingHeuristics = void 0);
                    }
                    _enableWindowsWrappingHeuristics() {
                        if (!this._windowsWrappingHeuristics) {
                            const e = [];
                            e.push(this.onLineFeed(f.updateWindowsModeWrappedState.bind(null, this._bufferService))), e.push(this.registerCsiHandler({
                                final: "H"
                            }, ()=>((0, f.updateWindowsModeWrappedState)(this._bufferService), !1))), this._windowsWrappingHeuristics = (0, s.toDisposable)(()=>{
                                for (const t of e)t.dispose();
                            });
                        }
                    }
                }
                t.CoreTerminal = m;
            },
            8460: (e, t)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.forwardEvent = t.EventEmitter = void 0, t.EventEmitter = class {
                    constructor(){
                        this._listeners = [], this._disposed = !1;
                    }
                    get event() {
                        return this._event || (this._event = (e)=>(this._listeners.push(e), {
                                dispose: ()=>{
                                    if (!this._disposed) {
                                        for(let t = 0; t < this._listeners.length; t++)if (this._listeners[t] === e) return void this._listeners.splice(t, 1);
                                    }
                                }
                            })), this._event;
                    }
                    fire(e, t) {
                        const i = [];
                        for(let e = 0; e < this._listeners.length; e++)i.push(this._listeners[e]);
                        for(let s = 0; s < i.length; s++)i[s].call(void 0, e, t);
                    }
                    dispose() {
                        this._listeners && (this._listeners.length = 0), this._disposed = !0;
                    }
                }, t.forwardEvent = function(e, t) {
                    return e((e)=>t.fire(e));
                };
            },
            5435: function(e, t, i) {
                var s = this && this.__decorate || function(e, t, i, s) {
                    var r, n = arguments.length, o = n < 3 ? t : null === s ? s = Object.getOwnPropertyDescriptor(t, i) : s;
                    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, i, s);
                    else for(var a = e.length - 1; a >= 0; a--)(r = e[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(t, i, o) : r(t, i)) || o);
                    return n > 3 && o && Object.defineProperty(t, i, o), o;
                }, r = this && this.__param || function(e, t) {
                    return function(i, s) {
                        t(i, s, e);
                    };
                };
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.InputHandler = t.WindowsOptionsReportType = void 0;
                const n = i(2584), o = i(7116), a = i(2015), h = i(844), c = i(482), l = i(8437), d = i(8460), _ = i(643), u = i(511), f = i(3734), v = i(2585), g = i(6242), p = i(6351), S = i(5941), m = {
                    "(": 0,
                    ")": 1,
                    "*": 2,
                    "+": 3,
                    "-": 1,
                    ".": 2
                }, C = 131072;
                function b(e, t) {
                    if (e > 24) return t.setWinLines || !1;
                    switch(e){
                        case 1:
                            return !!t.restoreWin;
                        case 2:
                            return !!t.minimizeWin;
                        case 3:
                            return !!t.setWinPosition;
                        case 4:
                            return !!t.setWinSizePixels;
                        case 5:
                            return !!t.raiseWin;
                        case 6:
                            return !!t.lowerWin;
                        case 7:
                            return !!t.refreshWin;
                        case 8:
                            return !!t.setWinSizeChars;
                        case 9:
                            return !!t.maximizeWin;
                        case 10:
                            return !!t.fullscreenWin;
                        case 11:
                            return !!t.getWinState;
                        case 13:
                            return !!t.getWinPosition;
                        case 14:
                            return !!t.getWinSizePixels;
                        case 15:
                            return !!t.getScreenSizePixels;
                        case 16:
                            return !!t.getCellSizePixels;
                        case 18:
                            return !!t.getWinSizeChars;
                        case 19:
                            return !!t.getScreenSizeChars;
                        case 20:
                            return !!t.getIconTitle;
                        case 21:
                            return !!t.getWinTitle;
                        case 22:
                            return !!t.pushTitle;
                        case 23:
                            return !!t.popTitle;
                        case 24:
                            return !!t.setWinLines;
                    }
                    return !1;
                }
                var y;
                !function(e) {
                    e[e.GET_WIN_SIZE_PIXELS = 0] = "GET_WIN_SIZE_PIXELS", e[e.GET_CELL_SIZE_PIXELS = 1] = "GET_CELL_SIZE_PIXELS";
                }(y = t.WindowsOptionsReportType || (t.WindowsOptionsReportType = {}));
                let w = 0;
                class E extends h.Disposable {
                    constructor(e, t, i, s, r, h, _, f, v = new a.EscapeSequenceParser){
                        super(), this._bufferService = e, this._charsetService = t, this._coreService = i, this._logService = s, this._optionsService = r, this._oscLinkService = h, this._coreMouseService = _, this._unicodeService = f, this._parser = v, this._parseBuffer = new Uint32Array(4096), this._stringDecoder = new c.StringToUtf32, this._utf8Decoder = new c.Utf8ToUtf32, this._workCell = new u.CellData, this._windowTitle = "", this._iconName = "", this._windowTitleStack = [], this._iconNameStack = [], this._curAttrData = l.DEFAULT_ATTR_DATA.clone(), this._eraseAttrDataInternal = l.DEFAULT_ATTR_DATA.clone(), this._onRequestBell = this.register(new d.EventEmitter), this.onRequestBell = this._onRequestBell.event, this._onRequestRefreshRows = this.register(new d.EventEmitter), this.onRequestRefreshRows = this._onRequestRefreshRows.event, this._onRequestReset = this.register(new d.EventEmitter), this.onRequestReset = this._onRequestReset.event, this._onRequestSendFocus = this.register(new d.EventEmitter), this.onRequestSendFocus = this._onRequestSendFocus.event, this._onRequestSyncScrollBar = this.register(new d.EventEmitter), this.onRequestSyncScrollBar = this._onRequestSyncScrollBar.event, this._onRequestWindowsOptionsReport = this.register(new d.EventEmitter), this.onRequestWindowsOptionsReport = this._onRequestWindowsOptionsReport.event, this._onA11yChar = this.register(new d.EventEmitter), this.onA11yChar = this._onA11yChar.event, this._onA11yTab = this.register(new d.EventEmitter), this.onA11yTab = this._onA11yTab.event, this._onCursorMove = this.register(new d.EventEmitter), this.onCursorMove = this._onCursorMove.event, this._onLineFeed = this.register(new d.EventEmitter), this.onLineFeed = this._onLineFeed.event, this._onScroll = this.register(new d.EventEmitter), this.onScroll = this._onScroll.event, this._onTitleChange = this.register(new d.EventEmitter), this.onTitleChange = this._onTitleChange.event, this._onColor = this.register(new d.EventEmitter), this.onColor = this._onColor.event, this._parseStack = {
                            paused: !1,
                            cursorStartX: 0,
                            cursorStartY: 0,
                            decodedLength: 0,
                            position: 0
                        }, this._specialColors = [
                            256,
                            257,
                            258
                        ], this.register(this._parser), this._dirtyRowTracker = new L(this._bufferService), this._activeBuffer = this._bufferService.buffer, this.register(this._bufferService.buffers.onBufferActivate((e)=>this._activeBuffer = e.activeBuffer)), this._parser.setCsiHandlerFallback((e, t)=>{
                            this._logService.debug("Unknown CSI code: ", {
                                identifier: this._parser.identToString(e),
                                params: t.toArray()
                            });
                        }), this._parser.setEscHandlerFallback((e)=>{
                            this._logService.debug("Unknown ESC code: ", {
                                identifier: this._parser.identToString(e)
                            });
                        }), this._parser.setExecuteHandlerFallback((e)=>{
                            this._logService.debug("Unknown EXECUTE code: ", {
                                code: e
                            });
                        }), this._parser.setOscHandlerFallback((e, t, i)=>{
                            this._logService.debug("Unknown OSC code: ", {
                                identifier: e,
                                action: t,
                                data: i
                            });
                        }), this._parser.setDcsHandlerFallback((e, t, i)=>{
                            "HOOK" === t && (i = i.toArray()), this._logService.debug("Unknown DCS code: ", {
                                identifier: this._parser.identToString(e),
                                action: t,
                                payload: i
                            });
                        }), this._parser.setPrintHandler((e, t, i)=>this.print(e, t, i)), this._parser.registerCsiHandler({
                            final: "@"
                        }, (e)=>this.insertChars(e)), this._parser.registerCsiHandler({
                            intermediates: " ",
                            final: "@"
                        }, (e)=>this.scrollLeft(e)), this._parser.registerCsiHandler({
                            final: "A"
                        }, (e)=>this.cursorUp(e)), this._parser.registerCsiHandler({
                            intermediates: " ",
                            final: "A"
                        }, (e)=>this.scrollRight(e)), this._parser.registerCsiHandler({
                            final: "B"
                        }, (e)=>this.cursorDown(e)), this._parser.registerCsiHandler({
                            final: "C"
                        }, (e)=>this.cursorForward(e)), this._parser.registerCsiHandler({
                            final: "D"
                        }, (e)=>this.cursorBackward(e)), this._parser.registerCsiHandler({
                            final: "E"
                        }, (e)=>this.cursorNextLine(e)), this._parser.registerCsiHandler({
                            final: "F"
                        }, (e)=>this.cursorPrecedingLine(e)), this._parser.registerCsiHandler({
                            final: "G"
                        }, (e)=>this.cursorCharAbsolute(e)), this._parser.registerCsiHandler({
                            final: "H"
                        }, (e)=>this.cursorPosition(e)), this._parser.registerCsiHandler({
                            final: "I"
                        }, (e)=>this.cursorForwardTab(e)), this._parser.registerCsiHandler({
                            final: "J"
                        }, (e)=>this.eraseInDisplay(e, !1)), this._parser.registerCsiHandler({
                            prefix: "?",
                            final: "J"
                        }, (e)=>this.eraseInDisplay(e, !0)), this._parser.registerCsiHandler({
                            final: "K"
                        }, (e)=>this.eraseInLine(e, !1)), this._parser.registerCsiHandler({
                            prefix: "?",
                            final: "K"
                        }, (e)=>this.eraseInLine(e, !0)), this._parser.registerCsiHandler({
                            final: "L"
                        }, (e)=>this.insertLines(e)), this._parser.registerCsiHandler({
                            final: "M"
                        }, (e)=>this.deleteLines(e)), this._parser.registerCsiHandler({
                            final: "P"
                        }, (e)=>this.deleteChars(e)), this._parser.registerCsiHandler({
                            final: "S"
                        }, (e)=>this.scrollUp(e)), this._parser.registerCsiHandler({
                            final: "T"
                        }, (e)=>this.scrollDown(e)), this._parser.registerCsiHandler({
                            final: "X"
                        }, (e)=>this.eraseChars(e)), this._parser.registerCsiHandler({
                            final: "Z"
                        }, (e)=>this.cursorBackwardTab(e)), this._parser.registerCsiHandler({
                            final: "`"
                        }, (e)=>this.charPosAbsolute(e)), this._parser.registerCsiHandler({
                            final: "a"
                        }, (e)=>this.hPositionRelative(e)), this._parser.registerCsiHandler({
                            final: "b"
                        }, (e)=>this.repeatPrecedingCharacter(e)), this._parser.registerCsiHandler({
                            final: "c"
                        }, (e)=>this.sendDeviceAttributesPrimary(e)), this._parser.registerCsiHandler({
                            prefix: ">",
                            final: "c"
                        }, (e)=>this.sendDeviceAttributesSecondary(e)), this._parser.registerCsiHandler({
                            final: "d"
                        }, (e)=>this.linePosAbsolute(e)), this._parser.registerCsiHandler({
                            final: "e"
                        }, (e)=>this.vPositionRelative(e)), this._parser.registerCsiHandler({
                            final: "f"
                        }, (e)=>this.hVPosition(e)), this._parser.registerCsiHandler({
                            final: "g"
                        }, (e)=>this.tabClear(e)), this._parser.registerCsiHandler({
                            final: "h"
                        }, (e)=>this.setMode(e)), this._parser.registerCsiHandler({
                            prefix: "?",
                            final: "h"
                        }, (e)=>this.setModePrivate(e)), this._parser.registerCsiHandler({
                            final: "l"
                        }, (e)=>this.resetMode(e)), this._parser.registerCsiHandler({
                            prefix: "?",
                            final: "l"
                        }, (e)=>this.resetModePrivate(e)), this._parser.registerCsiHandler({
                            final: "m"
                        }, (e)=>this.charAttributes(e)), this._parser.registerCsiHandler({
                            final: "n"
                        }, (e)=>this.deviceStatus(e)), this._parser.registerCsiHandler({
                            prefix: "?",
                            final: "n"
                        }, (e)=>this.deviceStatusPrivate(e)), this._parser.registerCsiHandler({
                            intermediates: "!",
                            final: "p"
                        }, (e)=>this.softReset(e)), this._parser.registerCsiHandler({
                            intermediates: " ",
                            final: "q"
                        }, (e)=>this.setCursorStyle(e)), this._parser.registerCsiHandler({
                            final: "r"
                        }, (e)=>this.setScrollRegion(e)), this._parser.registerCsiHandler({
                            final: "s"
                        }, (e)=>this.saveCursor(e)), this._parser.registerCsiHandler({
                            final: "t"
                        }, (e)=>this.windowOptions(e)), this._parser.registerCsiHandler({
                            final: "u"
                        }, (e)=>this.restoreCursor(e)), this._parser.registerCsiHandler({
                            intermediates: "'",
                            final: "}"
                        }, (e)=>this.insertColumns(e)), this._parser.registerCsiHandler({
                            intermediates: "'",
                            final: "~"
                        }, (e)=>this.deleteColumns(e)), this._parser.registerCsiHandler({
                            intermediates: '"',
                            final: "q"
                        }, (e)=>this.selectProtected(e)), this._parser.registerCsiHandler({
                            intermediates: "$",
                            final: "p"
                        }, (e)=>this.requestMode(e, !0)), this._parser.registerCsiHandler({
                            prefix: "?",
                            intermediates: "$",
                            final: "p"
                        }, (e)=>this.requestMode(e, !1)), this._parser.setExecuteHandler(n.C0.BEL, ()=>this.bell()), this._parser.setExecuteHandler(n.C0.LF, ()=>this.lineFeed()), this._parser.setExecuteHandler(n.C0.VT, ()=>this.lineFeed()), this._parser.setExecuteHandler(n.C0.FF, ()=>this.lineFeed()), this._parser.setExecuteHandler(n.C0.CR, ()=>this.carriageReturn()), this._parser.setExecuteHandler(n.C0.BS, ()=>this.backspace()), this._parser.setExecuteHandler(n.C0.HT, ()=>this.tab()), this._parser.setExecuteHandler(n.C0.SO, ()=>this.shiftOut()), this._parser.setExecuteHandler(n.C0.SI, ()=>this.shiftIn()), this._parser.setExecuteHandler(n.C1.IND, ()=>this.index()), this._parser.setExecuteHandler(n.C1.NEL, ()=>this.nextLine()), this._parser.setExecuteHandler(n.C1.HTS, ()=>this.tabSet()), this._parser.registerOscHandler(0, new g.OscHandler((e)=>(this.setTitle(e), this.setIconName(e), !0))), this._parser.registerOscHandler(1, new g.OscHandler((e)=>this.setIconName(e))), this._parser.registerOscHandler(2, new g.OscHandler((e)=>this.setTitle(e))), this._parser.registerOscHandler(4, new g.OscHandler((e)=>this.setOrReportIndexedColor(e))), this._parser.registerOscHandler(8, new g.OscHandler((e)=>this.setHyperlink(e))), this._parser.registerOscHandler(10, new g.OscHandler((e)=>this.setOrReportFgColor(e))), this._parser.registerOscHandler(11, new g.OscHandler((e)=>this.setOrReportBgColor(e))), this._parser.registerOscHandler(12, new g.OscHandler((e)=>this.setOrReportCursorColor(e))), this._parser.registerOscHandler(104, new g.OscHandler((e)=>this.restoreIndexedColor(e))), this._parser.registerOscHandler(110, new g.OscHandler((e)=>this.restoreFgColor(e))), this._parser.registerOscHandler(111, new g.OscHandler((e)=>this.restoreBgColor(e))), this._parser.registerOscHandler(112, new g.OscHandler((e)=>this.restoreCursorColor(e))), this._parser.registerEscHandler({
                            final: "7"
                        }, ()=>this.saveCursor()), this._parser.registerEscHandler({
                            final: "8"
                        }, ()=>this.restoreCursor()), this._parser.registerEscHandler({
                            final: "D"
                        }, ()=>this.index()), this._parser.registerEscHandler({
                            final: "E"
                        }, ()=>this.nextLine()), this._parser.registerEscHandler({
                            final: "H"
                        }, ()=>this.tabSet()), this._parser.registerEscHandler({
                            final: "M"
                        }, ()=>this.reverseIndex()), this._parser.registerEscHandler({
                            final: "="
                        }, ()=>this.keypadApplicationMode()), this._parser.registerEscHandler({
                            final: ">"
                        }, ()=>this.keypadNumericMode()), this._parser.registerEscHandler({
                            final: "c"
                        }, ()=>this.fullReset()), this._parser.registerEscHandler({
                            final: "n"
                        }, ()=>this.setgLevel(2)), this._parser.registerEscHandler({
                            final: "o"
                        }, ()=>this.setgLevel(3)), this._parser.registerEscHandler({
                            final: "|"
                        }, ()=>this.setgLevel(3)), this._parser.registerEscHandler({
                            final: "}"
                        }, ()=>this.setgLevel(2)), this._parser.registerEscHandler({
                            final: "~"
                        }, ()=>this.setgLevel(1)), this._parser.registerEscHandler({
                            intermediates: "%",
                            final: "@"
                        }, ()=>this.selectDefaultCharset()), this._parser.registerEscHandler({
                            intermediates: "%",
                            final: "G"
                        }, ()=>this.selectDefaultCharset());
                        for(const e in o.CHARSETS)this._parser.registerEscHandler({
                            intermediates: "(",
                            final: e
                        }, ()=>this.selectCharset("(" + e)), this._parser.registerEscHandler({
                            intermediates: ")",
                            final: e
                        }, ()=>this.selectCharset(")" + e)), this._parser.registerEscHandler({
                            intermediates: "*",
                            final: e
                        }, ()=>this.selectCharset("*" + e)), this._parser.registerEscHandler({
                            intermediates: "+",
                            final: e
                        }, ()=>this.selectCharset("+" + e)), this._parser.registerEscHandler({
                            intermediates: "-",
                            final: e
                        }, ()=>this.selectCharset("-" + e)), this._parser.registerEscHandler({
                            intermediates: ".",
                            final: e
                        }, ()=>this.selectCharset("." + e)), this._parser.registerEscHandler({
                            intermediates: "/",
                            final: e
                        }, ()=>this.selectCharset("/" + e));
                        this._parser.registerEscHandler({
                            intermediates: "#",
                            final: "8"
                        }, ()=>this.screenAlignmentPattern()), this._parser.setErrorHandler((e)=>(this._logService.error("Parsing error: ", e), e)), this._parser.registerDcsHandler({
                            intermediates: "$",
                            final: "q"
                        }, new p.DcsHandler((e, t)=>this.requestStatusString(e, t)));
                    }
                    getAttrData() {
                        return this._curAttrData;
                    }
                    _preserveStack(e, t, i, s) {
                        this._parseStack.paused = !0, this._parseStack.cursorStartX = e, this._parseStack.cursorStartY = t, this._parseStack.decodedLength = i, this._parseStack.position = s;
                    }
                    _logSlowResolvingAsync(e) {
                        this._logService.logLevel <= v.LogLevelEnum.WARN && Promise.race([
                            e,
                            new Promise((e, t)=>setTimeout(()=>t("#SLOW_TIMEOUT"), 5e3))
                        ]).catch((e)=>{
                            if ("#SLOW_TIMEOUT" !== e) throw e;
                            console.warn("async parser handler taking longer than 5000 ms");
                        });
                    }
                    _getCurrentLinkId() {
                        return this._curAttrData.extended.urlId;
                    }
                    parse(e, t) {
                        let i, s = this._activeBuffer.x, r = this._activeBuffer.y, n = 0;
                        const o = this._parseStack.paused;
                        if (o) {
                            if (i = this._parser.parse(this._parseBuffer, this._parseStack.decodedLength, t)) return this._logSlowResolvingAsync(i), i;
                            s = this._parseStack.cursorStartX, r = this._parseStack.cursorStartY, this._parseStack.paused = !1, e.length > C && (n = this._parseStack.position + C);
                        }
                        if (this._logService.logLevel <= v.LogLevelEnum.DEBUG && this._logService.debug("parsing data" + ("string" == typeof e ? ` "${e}"` : ` "${Array.prototype.map.call(e, (e)=>String.fromCharCode(e)).join("")}"`), "string" == typeof e ? e.split("").map((e)=>e.charCodeAt(0)) : e), this._parseBuffer.length < e.length && this._parseBuffer.length < C && (this._parseBuffer = new Uint32Array(Math.min(e.length, C))), o || this._dirtyRowTracker.clearRange(), e.length > C) for(let t = n; t < e.length; t += C){
                            const n = t + C < e.length ? t + C : e.length, o = "string" == typeof e ? this._stringDecoder.decode(e.substring(t, n), this._parseBuffer) : this._utf8Decoder.decode(e.subarray(t, n), this._parseBuffer);
                            if (i = this._parser.parse(this._parseBuffer, o)) return this._preserveStack(s, r, o, t), this._logSlowResolvingAsync(i), i;
                        }
                        else if (!o) {
                            const t = "string" == typeof e ? this._stringDecoder.decode(e, this._parseBuffer) : this._utf8Decoder.decode(e, this._parseBuffer);
                            if (i = this._parser.parse(this._parseBuffer, t)) return this._preserveStack(s, r, t, 0), this._logSlowResolvingAsync(i), i;
                        }
                        this._activeBuffer.x === s && this._activeBuffer.y === r || this._onCursorMove.fire(), this._onRequestRefreshRows.fire(this._dirtyRowTracker.start, this._dirtyRowTracker.end);
                    }
                    print(e, t, i) {
                        let s, r;
                        const n = this._charsetService.charset, o = this._optionsService.rawOptions.screenReaderMode, a = this._bufferService.cols, h = this._coreService.decPrivateModes.wraparound, l = this._coreService.modes.insertMode, d = this._curAttrData;
                        let u = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
                        this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._activeBuffer.x && i - t > 0 && 2 === u.getWidth(this._activeBuffer.x - 1) && u.setCellFromCodePoint(this._activeBuffer.x - 1, 0, 1, d.fg, d.bg, d.extended);
                        for(let f = t; f < i; ++f){
                            if (s = e[f], r = this._unicodeService.wcwidth(s), s < 127 && n) {
                                const e = n[String.fromCharCode(s)];
                                e && (s = e.charCodeAt(0));
                            }
                            if (o && this._onA11yChar.fire((0, c.stringFromCodePoint)(s)), this._getCurrentLinkId() && this._oscLinkService.addLineToLink(this._getCurrentLinkId(), this._activeBuffer.ybase + this._activeBuffer.y), r || !this._activeBuffer.x) {
                                if (this._activeBuffer.x + r - 1 >= a) {
                                    if (h) {
                                        for(; this._activeBuffer.x < a;)u.setCellFromCodePoint(this._activeBuffer.x++, 0, 1, d.fg, d.bg, d.extended);
                                        this._activeBuffer.x = 0, this._activeBuffer.y++, this._activeBuffer.y === this._activeBuffer.scrollBottom + 1 ? (this._activeBuffer.y--, this._bufferService.scroll(this._eraseAttrData(), !0)) : (this._activeBuffer.y >= this._bufferService.rows && (this._activeBuffer.y = this._bufferService.rows - 1), this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).isWrapped = !0), u = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
                                    } else if (this._activeBuffer.x = a - 1, 2 === r) continue;
                                }
                                if (l && (u.insertCells(this._activeBuffer.x, r, this._activeBuffer.getNullCell(d), d), 2 === u.getWidth(a - 1) && u.setCellFromCodePoint(a - 1, _.NULL_CELL_CODE, _.NULL_CELL_WIDTH, d.fg, d.bg, d.extended)), u.setCellFromCodePoint(this._activeBuffer.x++, s, r, d.fg, d.bg, d.extended), r > 0) for(; --r;)u.setCellFromCodePoint(this._activeBuffer.x++, 0, 0, d.fg, d.bg, d.extended);
                            } else u.getWidth(this._activeBuffer.x - 1) ? u.addCodepointToCell(this._activeBuffer.x - 1, s) : u.addCodepointToCell(this._activeBuffer.x - 2, s);
                        }
                        i - t > 0 && (u.loadCell(this._activeBuffer.x - 1, this._workCell), 2 === this._workCell.getWidth() || this._workCell.getCode() > 65535 ? this._parser.precedingCodepoint = 0 : this._workCell.isCombined() ? this._parser.precedingCodepoint = this._workCell.getChars().charCodeAt(0) : this._parser.precedingCodepoint = this._workCell.content), this._activeBuffer.x < a && i - t > 0 && 0 === u.getWidth(this._activeBuffer.x) && !u.hasContent(this._activeBuffer.x) && u.setCellFromCodePoint(this._activeBuffer.x, 0, 1, d.fg, d.bg, d.extended), this._dirtyRowTracker.markDirty(this._activeBuffer.y);
                    }
                    registerCsiHandler(e, t) {
                        return "t" !== e.final || e.prefix || e.intermediates ? this._parser.registerCsiHandler(e, t) : this._parser.registerCsiHandler(e, (e)=>!b(e.params[0], this._optionsService.rawOptions.windowOptions) || t(e));
                    }
                    registerDcsHandler(e, t) {
                        return this._parser.registerDcsHandler(e, new p.DcsHandler(t));
                    }
                    registerEscHandler(e, t) {
                        return this._parser.registerEscHandler(e, t);
                    }
                    registerOscHandler(e, t) {
                        return this._parser.registerOscHandler(e, new g.OscHandler(t));
                    }
                    bell() {
                        return this._onRequestBell.fire(), !0;
                    }
                    lineFeed() {
                        return this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._optionsService.rawOptions.convertEol && (this._activeBuffer.x = 0), this._activeBuffer.y++, this._activeBuffer.y === this._activeBuffer.scrollBottom + 1 ? (this._activeBuffer.y--, this._bufferService.scroll(this._eraseAttrData())) : this._activeBuffer.y >= this._bufferService.rows ? this._activeBuffer.y = this._bufferService.rows - 1 : this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).isWrapped = !1, this._activeBuffer.x >= this._bufferService.cols && this._activeBuffer.x--, this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._onLineFeed.fire(), !0;
                    }
                    carriageReturn() {
                        return this._activeBuffer.x = 0, !0;
                    }
                    backspace() {
                        var e;
                        if (!this._coreService.decPrivateModes.reverseWraparound) return this._restrictCursor(), this._activeBuffer.x > 0 && this._activeBuffer.x--, !0;
                        if (this._restrictCursor(this._bufferService.cols), this._activeBuffer.x > 0) this._activeBuffer.x--;
                        else if (0 === this._activeBuffer.x && this._activeBuffer.y > this._activeBuffer.scrollTop && this._activeBuffer.y <= this._activeBuffer.scrollBottom && (null === (e = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y)) || void 0 === e ? void 0 : e.isWrapped)) {
                            this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).isWrapped = !1, this._activeBuffer.y--, this._activeBuffer.x = this._bufferService.cols - 1;
                            const e = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
                            e.hasWidth(this._activeBuffer.x) && !e.hasContent(this._activeBuffer.x) && this._activeBuffer.x--;
                        }
                        return this._restrictCursor(), !0;
                    }
                    tab() {
                        if (this._activeBuffer.x >= this._bufferService.cols) return !0;
                        const e = this._activeBuffer.x;
                        return this._activeBuffer.x = this._activeBuffer.nextStop(), this._optionsService.rawOptions.screenReaderMode && this._onA11yTab.fire(this._activeBuffer.x - e), !0;
                    }
                    shiftOut() {
                        return this._charsetService.setgLevel(1), !0;
                    }
                    shiftIn() {
                        return this._charsetService.setgLevel(0), !0;
                    }
                    _restrictCursor(e = this._bufferService.cols - 1) {
                        this._activeBuffer.x = Math.min(e, Math.max(0, this._activeBuffer.x)), this._activeBuffer.y = this._coreService.decPrivateModes.origin ? Math.min(this._activeBuffer.scrollBottom, Math.max(this._activeBuffer.scrollTop, this._activeBuffer.y)) : Math.min(this._bufferService.rows - 1, Math.max(0, this._activeBuffer.y)), this._dirtyRowTracker.markDirty(this._activeBuffer.y);
                    }
                    _setCursor(e, t) {
                        this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._coreService.decPrivateModes.origin ? (this._activeBuffer.x = e, this._activeBuffer.y = this._activeBuffer.scrollTop + t) : (this._activeBuffer.x = e, this._activeBuffer.y = t), this._restrictCursor(), this._dirtyRowTracker.markDirty(this._activeBuffer.y);
                    }
                    _moveCursor(e, t) {
                        this._restrictCursor(), this._setCursor(this._activeBuffer.x + e, this._activeBuffer.y + t);
                    }
                    cursorUp(e) {
                        const t = this._activeBuffer.y - this._activeBuffer.scrollTop;
                        return t >= 0 ? this._moveCursor(0, -Math.min(t, e.params[0] || 1)) : this._moveCursor(0, -(e.params[0] || 1)), !0;
                    }
                    cursorDown(e) {
                        const t = this._activeBuffer.scrollBottom - this._activeBuffer.y;
                        return t >= 0 ? this._moveCursor(0, Math.min(t, e.params[0] || 1)) : this._moveCursor(0, e.params[0] || 1), !0;
                    }
                    cursorForward(e) {
                        return this._moveCursor(e.params[0] || 1, 0), !0;
                    }
                    cursorBackward(e) {
                        return this._moveCursor(-(e.params[0] || 1), 0), !0;
                    }
                    cursorNextLine(e) {
                        return this.cursorDown(e), this._activeBuffer.x = 0, !0;
                    }
                    cursorPrecedingLine(e) {
                        return this.cursorUp(e), this._activeBuffer.x = 0, !0;
                    }
                    cursorCharAbsolute(e) {
                        return this._setCursor((e.params[0] || 1) - 1, this._activeBuffer.y), !0;
                    }
                    cursorPosition(e) {
                        return this._setCursor(e.length >= 2 ? (e.params[1] || 1) - 1 : 0, (e.params[0] || 1) - 1), !0;
                    }
                    charPosAbsolute(e) {
                        return this._setCursor((e.params[0] || 1) - 1, this._activeBuffer.y), !0;
                    }
                    hPositionRelative(e) {
                        return this._moveCursor(e.params[0] || 1, 0), !0;
                    }
                    linePosAbsolute(e) {
                        return this._setCursor(this._activeBuffer.x, (e.params[0] || 1) - 1), !0;
                    }
                    vPositionRelative(e) {
                        return this._moveCursor(0, e.params[0] || 1), !0;
                    }
                    hVPosition(e) {
                        return this.cursorPosition(e), !0;
                    }
                    tabClear(e) {
                        const t = e.params[0];
                        return 0 === t ? delete this._activeBuffer.tabs[this._activeBuffer.x] : 3 === t && (this._activeBuffer.tabs = {}), !0;
                    }
                    cursorForwardTab(e) {
                        if (this._activeBuffer.x >= this._bufferService.cols) return !0;
                        let t = e.params[0] || 1;
                        for(; t--;)this._activeBuffer.x = this._activeBuffer.nextStop();
                        return !0;
                    }
                    cursorBackwardTab(e) {
                        if (this._activeBuffer.x >= this._bufferService.cols) return !0;
                        let t = e.params[0] || 1;
                        for(; t--;)this._activeBuffer.x = this._activeBuffer.prevStop();
                        return !0;
                    }
                    selectProtected(e) {
                        const t = e.params[0];
                        return 1 === t && (this._curAttrData.bg |= 536870912), 2 !== t && 0 !== t || (this._curAttrData.bg &= -536870913), !0;
                    }
                    _eraseInBufferLine(e, t, i, s = !1, r = !1) {
                        const n = this._activeBuffer.lines.get(this._activeBuffer.ybase + e);
                        n.replaceCells(t, i, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData(), r), s && (n.isWrapped = !1);
                    }
                    _resetBufferLine(e, t = !1) {
                        const i = this._activeBuffer.lines.get(this._activeBuffer.ybase + e);
                        i && (i.fill(this._activeBuffer.getNullCell(this._eraseAttrData()), t), this._bufferService.buffer.clearMarkers(this._activeBuffer.ybase + e), i.isWrapped = !1);
                    }
                    eraseInDisplay(e, t = !1) {
                        let i;
                        switch(this._restrictCursor(this._bufferService.cols), e.params[0]){
                            case 0:
                                for(i = this._activeBuffer.y, this._dirtyRowTracker.markDirty(i), this._eraseInBufferLine(i++, this._activeBuffer.x, this._bufferService.cols, 0 === this._activeBuffer.x, t); i < this._bufferService.rows; i++)this._resetBufferLine(i, t);
                                this._dirtyRowTracker.markDirty(i);
                                break;
                            case 1:
                                for(i = this._activeBuffer.y, this._dirtyRowTracker.markDirty(i), this._eraseInBufferLine(i, 0, this._activeBuffer.x + 1, !0, t), this._activeBuffer.x + 1 >= this._bufferService.cols && (this._activeBuffer.lines.get(i + 1).isWrapped = !1); i--;)this._resetBufferLine(i, t);
                                this._dirtyRowTracker.markDirty(0);
                                break;
                            case 2:
                                for(i = this._bufferService.rows, this._dirtyRowTracker.markDirty(i - 1); i--;)this._resetBufferLine(i, t);
                                this._dirtyRowTracker.markDirty(0);
                                break;
                            case 3:
                                const e1 = this._activeBuffer.lines.length - this._bufferService.rows;
                                e1 > 0 && (this._activeBuffer.lines.trimStart(e1), this._activeBuffer.ybase = Math.max(this._activeBuffer.ybase - e1, 0), this._activeBuffer.ydisp = Math.max(this._activeBuffer.ydisp - e1, 0), this._onScroll.fire(0));
                        }
                        return !0;
                    }
                    eraseInLine(e, t = !1) {
                        switch(this._restrictCursor(this._bufferService.cols), e.params[0]){
                            case 0:
                                this._eraseInBufferLine(this._activeBuffer.y, this._activeBuffer.x, this._bufferService.cols, 0 === this._activeBuffer.x, t);
                                break;
                            case 1:
                                this._eraseInBufferLine(this._activeBuffer.y, 0, this._activeBuffer.x + 1, !1, t);
                                break;
                            case 2:
                                this._eraseInBufferLine(this._activeBuffer.y, 0, this._bufferService.cols, !0, t);
                        }
                        return this._dirtyRowTracker.markDirty(this._activeBuffer.y), !0;
                    }
                    insertLines(e) {
                        this._restrictCursor();
                        let t = e.params[0] || 1;
                        if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return !0;
                        const i = this._activeBuffer.ybase + this._activeBuffer.y, s = this._bufferService.rows - 1 - this._activeBuffer.scrollBottom, r = this._bufferService.rows - 1 + this._activeBuffer.ybase - s + 1;
                        for(; t--;)this._activeBuffer.lines.splice(r - 1, 1), this._activeBuffer.lines.splice(i, 0, this._activeBuffer.getBlankLine(this._eraseAttrData()));
                        return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.y, this._activeBuffer.scrollBottom), this._activeBuffer.x = 0, !0;
                    }
                    deleteLines(e) {
                        this._restrictCursor();
                        let t = e.params[0] || 1;
                        if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return !0;
                        const i = this._activeBuffer.ybase + this._activeBuffer.y;
                        let s;
                        for(s = this._bufferService.rows - 1 - this._activeBuffer.scrollBottom, s = this._bufferService.rows - 1 + this._activeBuffer.ybase - s; t--;)this._activeBuffer.lines.splice(i, 1), this._activeBuffer.lines.splice(s, 0, this._activeBuffer.getBlankLine(this._eraseAttrData()));
                        return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.y, this._activeBuffer.scrollBottom), this._activeBuffer.x = 0, !0;
                    }
                    insertChars(e) {
                        this._restrictCursor();
                        const t = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
                        return t && (t.insertCells(this._activeBuffer.x, e.params[0] || 1, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), this._dirtyRowTracker.markDirty(this._activeBuffer.y)), !0;
                    }
                    deleteChars(e) {
                        this._restrictCursor();
                        const t = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
                        return t && (t.deleteCells(this._activeBuffer.x, e.params[0] || 1, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), this._dirtyRowTracker.markDirty(this._activeBuffer.y)), !0;
                    }
                    scrollUp(e) {
                        let t = e.params[0] || 1;
                        for(; t--;)this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollTop, 1), this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollBottom, 0, this._activeBuffer.getBlankLine(this._eraseAttrData()));
                        return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), !0;
                    }
                    scrollDown(e) {
                        let t = e.params[0] || 1;
                        for(; t--;)this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollBottom, 1), this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollTop, 0, this._activeBuffer.getBlankLine(l.DEFAULT_ATTR_DATA));
                        return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), !0;
                    }
                    scrollLeft(e) {
                        if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return !0;
                        const t = e.params[0] || 1;
                        for(let e = this._activeBuffer.scrollTop; e <= this._activeBuffer.scrollBottom; ++e){
                            const i = this._activeBuffer.lines.get(this._activeBuffer.ybase + e);
                            i.deleteCells(0, t, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), i.isWrapped = !1;
                        }
                        return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), !0;
                    }
                    scrollRight(e) {
                        if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return !0;
                        const t = e.params[0] || 1;
                        for(let e = this._activeBuffer.scrollTop; e <= this._activeBuffer.scrollBottom; ++e){
                            const i = this._activeBuffer.lines.get(this._activeBuffer.ybase + e);
                            i.insertCells(0, t, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), i.isWrapped = !1;
                        }
                        return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), !0;
                    }
                    insertColumns(e) {
                        if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return !0;
                        const t = e.params[0] || 1;
                        for(let e = this._activeBuffer.scrollTop; e <= this._activeBuffer.scrollBottom; ++e){
                            const i = this._activeBuffer.lines.get(this._activeBuffer.ybase + e);
                            i.insertCells(this._activeBuffer.x, t, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), i.isWrapped = !1;
                        }
                        return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), !0;
                    }
                    deleteColumns(e) {
                        if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return !0;
                        const t = e.params[0] || 1;
                        for(let e = this._activeBuffer.scrollTop; e <= this._activeBuffer.scrollBottom; ++e){
                            const i = this._activeBuffer.lines.get(this._activeBuffer.ybase + e);
                            i.deleteCells(this._activeBuffer.x, t, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), i.isWrapped = !1;
                        }
                        return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), !0;
                    }
                    eraseChars(e) {
                        this._restrictCursor();
                        const t = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
                        return t && (t.replaceCells(this._activeBuffer.x, this._activeBuffer.x + (e.params[0] || 1), this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), this._dirtyRowTracker.markDirty(this._activeBuffer.y)), !0;
                    }
                    repeatPrecedingCharacter(e) {
                        if (!this._parser.precedingCodepoint) return !0;
                        const t = e.params[0] || 1, i = new Uint32Array(t);
                        for(let e = 0; e < t; ++e)i[e] = this._parser.precedingCodepoint;
                        return this.print(i, 0, i.length), !0;
                    }
                    sendDeviceAttributesPrimary(e) {
                        return e.params[0] > 0 || (this._is("xterm") || this._is("rxvt-unicode") || this._is("screen") ? this._coreService.triggerDataEvent(n.C0.ESC + "[?1;2c") : this._is("linux") && this._coreService.triggerDataEvent(n.C0.ESC + "[?6c")), !0;
                    }
                    sendDeviceAttributesSecondary(e) {
                        return e.params[0] > 0 || (this._is("xterm") ? this._coreService.triggerDataEvent(n.C0.ESC + "[>0;276;0c") : this._is("rxvt-unicode") ? this._coreService.triggerDataEvent(n.C0.ESC + "[>85;95;0c") : this._is("linux") ? this._coreService.triggerDataEvent(e.params[0] + "c") : this._is("screen") && this._coreService.triggerDataEvent(n.C0.ESC + "[>83;40003;0c")), !0;
                    }
                    _is(e) {
                        return 0 === (this._optionsService.rawOptions.termName + "").indexOf(e);
                    }
                    setMode(e) {
                        for(let t = 0; t < e.length; t++)switch(e.params[t]){
                            case 4:
                                this._coreService.modes.insertMode = !0;
                                break;
                            case 20:
                                this._optionsService.options.convertEol = !0;
                        }
                        return !0;
                    }
                    setModePrivate(e) {
                        for(let t = 0; t < e.length; t++)switch(e.params[t]){
                            case 1:
                                this._coreService.decPrivateModes.applicationCursorKeys = !0;
                                break;
                            case 2:
                                this._charsetService.setgCharset(0, o.DEFAULT_CHARSET), this._charsetService.setgCharset(1, o.DEFAULT_CHARSET), this._charsetService.setgCharset(2, o.DEFAULT_CHARSET), this._charsetService.setgCharset(3, o.DEFAULT_CHARSET);
                                break;
                            case 3:
                                this._optionsService.rawOptions.windowOptions.setWinLines && (this._bufferService.resize(132, this._bufferService.rows), this._onRequestReset.fire());
                                break;
                            case 6:
                                this._coreService.decPrivateModes.origin = !0, this._setCursor(0, 0);
                                break;
                            case 7:
                                this._coreService.decPrivateModes.wraparound = !0;
                                break;
                            case 12:
                                this._optionsService.options.cursorBlink = !0;
                                break;
                            case 45:
                                this._coreService.decPrivateModes.reverseWraparound = !0;
                                break;
                            case 66:
                                this._logService.debug("Serial port requested application keypad."), this._coreService.decPrivateModes.applicationKeypad = !0, this._onRequestSyncScrollBar.fire();
                                break;
                            case 9:
                                this._coreMouseService.activeProtocol = "X10";
                                break;
                            case 1e3:
                                this._coreMouseService.activeProtocol = "VT200";
                                break;
                            case 1002:
                                this._coreMouseService.activeProtocol = "DRAG";
                                break;
                            case 1003:
                                this._coreMouseService.activeProtocol = "ANY";
                                break;
                            case 1004:
                                this._coreService.decPrivateModes.sendFocus = !0, this._onRequestSendFocus.fire();
                                break;
                            case 1005:
                                this._logService.debug("DECSET 1005 not supported (see #2507)");
                                break;
                            case 1006:
                                this._coreMouseService.activeEncoding = "SGR";
                                break;
                            case 1015:
                                this._logService.debug("DECSET 1015 not supported (see #2507)");
                                break;
                            case 1016:
                                this._coreMouseService.activeEncoding = "SGR_PIXELS";
                                break;
                            case 25:
                                this._coreService.isCursorHidden = !1;
                                break;
                            case 1048:
                                this.saveCursor();
                                break;
                            case 1049:
                                this.saveCursor();
                            case 47:
                            case 1047:
                                this._bufferService.buffers.activateAltBuffer(this._eraseAttrData()), this._coreService.isCursorInitialized = !0, this._onRequestRefreshRows.fire(0, this._bufferService.rows - 1), this._onRequestSyncScrollBar.fire();
                                break;
                            case 2004:
                                this._coreService.decPrivateModes.bracketedPasteMode = !0;
                        }
                        return !0;
                    }
                    resetMode(e) {
                        for(let t = 0; t < e.length; t++)switch(e.params[t]){
                            case 4:
                                this._coreService.modes.insertMode = !1;
                                break;
                            case 20:
                                this._optionsService.options.convertEol = !1;
                        }
                        return !0;
                    }
                    resetModePrivate(e) {
                        for(let t = 0; t < e.length; t++)switch(e.params[t]){
                            case 1:
                                this._coreService.decPrivateModes.applicationCursorKeys = !1;
                                break;
                            case 3:
                                this._optionsService.rawOptions.windowOptions.setWinLines && (this._bufferService.resize(80, this._bufferService.rows), this._onRequestReset.fire());
                                break;
                            case 6:
                                this._coreService.decPrivateModes.origin = !1, this._setCursor(0, 0);
                                break;
                            case 7:
                                this._coreService.decPrivateModes.wraparound = !1;
                                break;
                            case 12:
                                this._optionsService.options.cursorBlink = !1;
                                break;
                            case 45:
                                this._coreService.decPrivateModes.reverseWraparound = !1;
                                break;
                            case 66:
                                this._logService.debug("Switching back to normal keypad."), this._coreService.decPrivateModes.applicationKeypad = !1, this._onRequestSyncScrollBar.fire();
                                break;
                            case 9:
                            case 1e3:
                            case 1002:
                            case 1003:
                                this._coreMouseService.activeProtocol = "NONE";
                                break;
                            case 1004:
                                this._coreService.decPrivateModes.sendFocus = !1;
                                break;
                            case 1005:
                                this._logService.debug("DECRST 1005 not supported (see #2507)");
                                break;
                            case 1006:
                            case 1016:
                                this._coreMouseService.activeEncoding = "DEFAULT";
                                break;
                            case 1015:
                                this._logService.debug("DECRST 1015 not supported (see #2507)");
                                break;
                            case 25:
                                this._coreService.isCursorHidden = !0;
                                break;
                            case 1048:
                                this.restoreCursor();
                                break;
                            case 1049:
                            case 47:
                            case 1047:
                                this._bufferService.buffers.activateNormalBuffer(), 1049 === e.params[t] && this.restoreCursor(), this._coreService.isCursorInitialized = !0, this._onRequestRefreshRows.fire(0, this._bufferService.rows - 1), this._onRequestSyncScrollBar.fire();
                                break;
                            case 2004:
                                this._coreService.decPrivateModes.bracketedPasteMode = !1;
                        }
                        return !0;
                    }
                    requestMode(e, t) {
                        const i = this._coreService.decPrivateModes, { activeProtocol: s, activeEncoding: r } = this._coreMouseService, o = this._coreService, { buffers: a, cols: h } = this._bufferService, { active: c, alt: l } = a, d = this._optionsService.rawOptions, _ = (e)=>e ? 1 : 2, u = e.params[0];
                        var f, v;
                        return f = u, v = t ? 2 === u ? 4 : 4 === u ? _(o.modes.insertMode) : 12 === u ? 3 : 20 === u ? _(d.convertEol) : 0 : 1 === u ? _(i.applicationCursorKeys) : 3 === u ? d.windowOptions.setWinLines ? 80 === h ? 2 : 132 === h ? 1 : 0 : 0 : 6 === u ? _(i.origin) : 7 === u ? _(i.wraparound) : 8 === u ? 3 : 9 === u ? _("X10" === s) : 12 === u ? _(d.cursorBlink) : 25 === u ? _(!o.isCursorHidden) : 45 === u ? _(i.reverseWraparound) : 66 === u ? _(i.applicationKeypad) : 67 === u ? 4 : 1e3 === u ? _("VT200" === s) : 1002 === u ? _("DRAG" === s) : 1003 === u ? _("ANY" === s) : 1004 === u ? _(i.sendFocus) : 1005 === u ? 4 : 1006 === u ? _("SGR" === r) : 1015 === u ? 4 : 1016 === u ? _("SGR_PIXELS" === r) : 1048 === u ? 1 : 47 === u || 1047 === u || 1049 === u ? _(c === l) : 2004 === u ? _(i.bracketedPasteMode) : 0, o.triggerDataEvent(`${n.C0.ESC}[${t ? "" : "?"}${f};${v}$y`), !0;
                    }
                    _updateAttrColor(e, t, i, s, r) {
                        return 2 === t ? (e |= 50331648, e &= -16777216, e |= f.AttributeData.fromColorRGB([
                            i,
                            s,
                            r
                        ])) : 5 === t && (e &= -50331904, e |= 33554432 | 255 & i), e;
                    }
                    _extractColor(e, t, i) {
                        const s = [
                            0,
                            0,
                            -1,
                            0,
                            0,
                            0
                        ];
                        let r = 0, n = 0;
                        do {
                            if (s[n + r] = e.params[t + n], e.hasSubParams(t + n)) {
                                const i = e.getSubParams(t + n);
                                let o = 0;
                                do 5 === s[1] && (r = 1), s[n + o + 1 + r] = i[o];
                                while (++o < i.length && o + n + 1 + r < s.length);
                                break;
                            }
                            if (5 === s[1] && n + r >= 2 || 2 === s[1] && n + r >= 5) break;
                            s[1] && (r = 1);
                        }while (++n + t < e.length && n + r < s.length);
                        for(let e = 2; e < s.length; ++e)-1 === s[e] && (s[e] = 0);
                        switch(s[0]){
                            case 38:
                                i.fg = this._updateAttrColor(i.fg, s[1], s[3], s[4], s[5]);
                                break;
                            case 48:
                                i.bg = this._updateAttrColor(i.bg, s[1], s[3], s[4], s[5]);
                                break;
                            case 58:
                                i.extended = i.extended.clone(), i.extended.underlineColor = this._updateAttrColor(i.extended.underlineColor, s[1], s[3], s[4], s[5]);
                        }
                        return n;
                    }
                    _processUnderline(e, t) {
                        t.extended = t.extended.clone(), (!~e || e > 5) && (e = 1), t.extended.underlineStyle = e, t.fg |= 268435456, 0 === e && (t.fg &= -268435457), t.updateExtended();
                    }
                    _processSGR0(e) {
                        e.fg = l.DEFAULT_ATTR_DATA.fg, e.bg = l.DEFAULT_ATTR_DATA.bg, e.extended = e.extended.clone(), e.extended.underlineStyle = 0, e.extended.underlineColor &= -67108864, e.updateExtended();
                    }
                    charAttributes(e) {
                        if (1 === e.length && 0 === e.params[0]) return this._processSGR0(this._curAttrData), !0;
                        const t = e.length;
                        let i;
                        const s = this._curAttrData;
                        for(let r = 0; r < t; r++)i = e.params[r], i >= 30 && i <= 37 ? (s.fg &= -50331904, s.fg |= 16777216 | i - 30) : i >= 40 && i <= 47 ? (s.bg &= -50331904, s.bg |= 16777216 | i - 40) : i >= 90 && i <= 97 ? (s.fg &= -50331904, s.fg |= 16777224 | i - 90) : i >= 100 && i <= 107 ? (s.bg &= -50331904, s.bg |= 16777224 | i - 100) : 0 === i ? this._processSGR0(s) : 1 === i ? s.fg |= 134217728 : 3 === i ? s.bg |= 67108864 : 4 === i ? (s.fg |= 268435456, this._processUnderline(e.hasSubParams(r) ? e.getSubParams(r)[0] : 1, s)) : 5 === i ? s.fg |= 536870912 : 7 === i ? s.fg |= 67108864 : 8 === i ? s.fg |= 1073741824 : 9 === i ? s.fg |= 2147483648 : 2 === i ? s.bg |= 134217728 : 21 === i ? this._processUnderline(2, s) : 22 === i ? (s.fg &= -134217729, s.bg &= -134217729) : 23 === i ? s.bg &= -67108865 : 24 === i ? (s.fg &= -268435457, this._processUnderline(0, s)) : 25 === i ? s.fg &= -536870913 : 27 === i ? s.fg &= -67108865 : 28 === i ? s.fg &= -1073741825 : 29 === i ? s.fg &= 2147483647 : 39 === i ? (s.fg &= -67108864, s.fg |= 16777215 & l.DEFAULT_ATTR_DATA.fg) : 49 === i ? (s.bg &= -67108864, s.bg |= 16777215 & l.DEFAULT_ATTR_DATA.bg) : 38 === i || 48 === i || 58 === i ? r += this._extractColor(e, r, s) : 53 === i ? s.bg |= 1073741824 : 55 === i ? s.bg &= -1073741825 : 59 === i ? (s.extended = s.extended.clone(), s.extended.underlineColor = -1, s.updateExtended()) : 100 === i ? (s.fg &= -67108864, s.fg |= 16777215 & l.DEFAULT_ATTR_DATA.fg, s.bg &= -67108864, s.bg |= 16777215 & l.DEFAULT_ATTR_DATA.bg) : this._logService.debug("Unknown SGR attribute: %d.", i);
                        return !0;
                    }
                    deviceStatus(e) {
                        switch(e.params[0]){
                            case 5:
                                this._coreService.triggerDataEvent(`${n.C0.ESC}[0n`);
                                break;
                            case 6:
                                const e1 = this._activeBuffer.y + 1, t = this._activeBuffer.x + 1;
                                this._coreService.triggerDataEvent(`${n.C0.ESC}[${e1};${t}R`);
                        }
                        return !0;
                    }
                    deviceStatusPrivate(e) {
                        if (6 === e.params[0]) {
                            const e = this._activeBuffer.y + 1, t = this._activeBuffer.x + 1;
                            this._coreService.triggerDataEvent(`${n.C0.ESC}[?${e};${t}R`);
                        }
                        return !0;
                    }
                    softReset(e) {
                        return this._coreService.isCursorHidden = !1, this._onRequestSyncScrollBar.fire(), this._activeBuffer.scrollTop = 0, this._activeBuffer.scrollBottom = this._bufferService.rows - 1, this._curAttrData = l.DEFAULT_ATTR_DATA.clone(), this._coreService.reset(), this._charsetService.reset(), this._activeBuffer.savedX = 0, this._activeBuffer.savedY = this._activeBuffer.ybase, this._activeBuffer.savedCurAttrData.fg = this._curAttrData.fg, this._activeBuffer.savedCurAttrData.bg = this._curAttrData.bg, this._activeBuffer.savedCharset = this._charsetService.charset, this._coreService.decPrivateModes.origin = !1, !0;
                    }
                    setCursorStyle(e) {
                        const t = e.params[0] || 1;
                        switch(t){
                            case 1:
                            case 2:
                                this._optionsService.options.cursorStyle = "block";
                                break;
                            case 3:
                            case 4:
                                this._optionsService.options.cursorStyle = "underline";
                                break;
                            case 5:
                            case 6:
                                this._optionsService.options.cursorStyle = "bar";
                        }
                        const i = t % 2 == 1;
                        return this._optionsService.options.cursorBlink = i, !0;
                    }
                    setScrollRegion(e) {
                        const t = e.params[0] || 1;
                        let i;
                        return (e.length < 2 || (i = e.params[1]) > this._bufferService.rows || 0 === i) && (i = this._bufferService.rows), i > t && (this._activeBuffer.scrollTop = t - 1, this._activeBuffer.scrollBottom = i - 1, this._setCursor(0, 0)), !0;
                    }
                    windowOptions(e) {
                        if (!b(e.params[0], this._optionsService.rawOptions.windowOptions)) return !0;
                        const t = e.length > 1 ? e.params[1] : 0;
                        switch(e.params[0]){
                            case 14:
                                2 !== t && this._onRequestWindowsOptionsReport.fire(y.GET_WIN_SIZE_PIXELS);
                                break;
                            case 16:
                                this._onRequestWindowsOptionsReport.fire(y.GET_CELL_SIZE_PIXELS);
                                break;
                            case 18:
                                this._bufferService && this._coreService.triggerDataEvent(`${n.C0.ESC}[8;${this._bufferService.rows};${this._bufferService.cols}t`);
                                break;
                            case 22:
                                0 !== t && 2 !== t || (this._windowTitleStack.push(this._windowTitle), this._windowTitleStack.length > 10 && this._windowTitleStack.shift()), 0 !== t && 1 !== t || (this._iconNameStack.push(this._iconName), this._iconNameStack.length > 10 && this._iconNameStack.shift());
                                break;
                            case 23:
                                0 !== t && 2 !== t || this._windowTitleStack.length && this.setTitle(this._windowTitleStack.pop()), 0 !== t && 1 !== t || this._iconNameStack.length && this.setIconName(this._iconNameStack.pop());
                        }
                        return !0;
                    }
                    saveCursor(e) {
                        return this._activeBuffer.savedX = this._activeBuffer.x, this._activeBuffer.savedY = this._activeBuffer.ybase + this._activeBuffer.y, this._activeBuffer.savedCurAttrData.fg = this._curAttrData.fg, this._activeBuffer.savedCurAttrData.bg = this._curAttrData.bg, this._activeBuffer.savedCharset = this._charsetService.charset, !0;
                    }
                    restoreCursor(e) {
                        return this._activeBuffer.x = this._activeBuffer.savedX || 0, this._activeBuffer.y = Math.max(this._activeBuffer.savedY - this._activeBuffer.ybase, 0), this._curAttrData.fg = this._activeBuffer.savedCurAttrData.fg, this._curAttrData.bg = this._activeBuffer.savedCurAttrData.bg, this._charsetService.charset = this._savedCharset, this._activeBuffer.savedCharset && (this._charsetService.charset = this._activeBuffer.savedCharset), this._restrictCursor(), !0;
                    }
                    setTitle(e) {
                        return this._windowTitle = e, this._onTitleChange.fire(e), !0;
                    }
                    setIconName(e) {
                        return this._iconName = e, !0;
                    }
                    setOrReportIndexedColor(e) {
                        const t = [], i = e.split(";");
                        for(; i.length > 1;){
                            const e = i.shift(), s = i.shift();
                            if (/^\d+$/.exec(e)) {
                                const i = parseInt(e);
                                if (0 <= i && i < 256) {
                                    if ("?" === s) t.push({
                                        type: 0,
                                        index: i
                                    });
                                    else {
                                        const e = (0, S.parseColor)(s);
                                        e && t.push({
                                            type: 1,
                                            index: i,
                                            color: e
                                        });
                                    }
                                }
                            }
                        }
                        return t.length && this._onColor.fire(t), !0;
                    }
                    setHyperlink(e) {
                        const t = e.split(";");
                        return !(t.length < 2) && (t[1] ? this._createHyperlink(t[0], t[1]) : !t[0] && this._finishHyperlink());
                    }
                    _createHyperlink(e, t) {
                        this._getCurrentLinkId() && this._finishHyperlink();
                        const i = e.split(":");
                        let s;
                        const r = i.findIndex((e)=>e.startsWith("id="));
                        return -1 !== r && (s = i[r].slice(3) || void 0), this._curAttrData.extended = this._curAttrData.extended.clone(), this._curAttrData.extended.urlId = this._oscLinkService.registerLink({
                            id: s,
                            uri: t
                        }), this._curAttrData.updateExtended(), !0;
                    }
                    _finishHyperlink() {
                        return this._curAttrData.extended = this._curAttrData.extended.clone(), this._curAttrData.extended.urlId = 0, this._curAttrData.updateExtended(), !0;
                    }
                    _setOrReportSpecialColor(e, t) {
                        const i = e.split(";");
                        for(let e = 0; e < i.length && !(t >= this._specialColors.length); ++e, ++t)if ("?" === i[e]) this._onColor.fire([
                            {
                                type: 0,
                                index: this._specialColors[t]
                            }
                        ]);
                        else {
                            const s = (0, S.parseColor)(i[e]);
                            s && this._onColor.fire([
                                {
                                    type: 1,
                                    index: this._specialColors[t],
                                    color: s
                                }
                            ]);
                        }
                        return !0;
                    }
                    setOrReportFgColor(e) {
                        return this._setOrReportSpecialColor(e, 0);
                    }
                    setOrReportBgColor(e) {
                        return this._setOrReportSpecialColor(e, 1);
                    }
                    setOrReportCursorColor(e) {
                        return this._setOrReportSpecialColor(e, 2);
                    }
                    restoreIndexedColor(e) {
                        if (!e) return this._onColor.fire([
                            {
                                type: 2
                            }
                        ]), !0;
                        const t = [], i = e.split(";");
                        for(let e = 0; e < i.length; ++e)if (/^\d+$/.exec(i[e])) {
                            const s = parseInt(i[e]);
                            0 <= s && s < 256 && t.push({
                                type: 2,
                                index: s
                            });
                        }
                        return t.length && this._onColor.fire(t), !0;
                    }
                    restoreFgColor(e) {
                        return this._onColor.fire([
                            {
                                type: 2,
                                index: 256
                            }
                        ]), !0;
                    }
                    restoreBgColor(e) {
                        return this._onColor.fire([
                            {
                                type: 2,
                                index: 257
                            }
                        ]), !0;
                    }
                    restoreCursorColor(e) {
                        return this._onColor.fire([
                            {
                                type: 2,
                                index: 258
                            }
                        ]), !0;
                    }
                    nextLine() {
                        return this._activeBuffer.x = 0, this.index(), !0;
                    }
                    keypadApplicationMode() {
                        return this._logService.debug("Serial port requested application keypad."), this._coreService.decPrivateModes.applicationKeypad = !0, this._onRequestSyncScrollBar.fire(), !0;
                    }
                    keypadNumericMode() {
                        return this._logService.debug("Switching back to normal keypad."), this._coreService.decPrivateModes.applicationKeypad = !1, this._onRequestSyncScrollBar.fire(), !0;
                    }
                    selectDefaultCharset() {
                        return this._charsetService.setgLevel(0), this._charsetService.setgCharset(0, o.DEFAULT_CHARSET), !0;
                    }
                    selectCharset(e) {
                        return 2 !== e.length ? (this.selectDefaultCharset(), !0) : ("/" === e[0] || this._charsetService.setgCharset(m[e[0]], o.CHARSETS[e[1]] || o.DEFAULT_CHARSET), !0);
                    }
                    index() {
                        return this._restrictCursor(), this._activeBuffer.y++, this._activeBuffer.y === this._activeBuffer.scrollBottom + 1 ? (this._activeBuffer.y--, this._bufferService.scroll(this._eraseAttrData())) : this._activeBuffer.y >= this._bufferService.rows && (this._activeBuffer.y = this._bufferService.rows - 1), this._restrictCursor(), !0;
                    }
                    tabSet() {
                        return this._activeBuffer.tabs[this._activeBuffer.x] = !0, !0;
                    }
                    reverseIndex() {
                        if (this._restrictCursor(), this._activeBuffer.y === this._activeBuffer.scrollTop) {
                            const e = this._activeBuffer.scrollBottom - this._activeBuffer.scrollTop;
                            this._activeBuffer.lines.shiftElements(this._activeBuffer.ybase + this._activeBuffer.y, e, 1), this._activeBuffer.lines.set(this._activeBuffer.ybase + this._activeBuffer.y, this._activeBuffer.getBlankLine(this._eraseAttrData())), this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom);
                        } else this._activeBuffer.y--, this._restrictCursor();
                        return !0;
                    }
                    fullReset() {
                        return this._parser.reset(), this._onRequestReset.fire(), !0;
                    }
                    reset() {
                        this._curAttrData = l.DEFAULT_ATTR_DATA.clone(), this._eraseAttrDataInternal = l.DEFAULT_ATTR_DATA.clone();
                    }
                    _eraseAttrData() {
                        return this._eraseAttrDataInternal.bg &= -67108864, this._eraseAttrDataInternal.bg |= 67108863 & this._curAttrData.bg, this._eraseAttrDataInternal;
                    }
                    setgLevel(e) {
                        return this._charsetService.setgLevel(e), !0;
                    }
                    screenAlignmentPattern() {
                        const e = new u.CellData;
                        e.content = 4194304 | "E".charCodeAt(0), e.fg = this._curAttrData.fg, e.bg = this._curAttrData.bg, this._setCursor(0, 0);
                        for(let t = 0; t < this._bufferService.rows; ++t){
                            const i = this._activeBuffer.ybase + this._activeBuffer.y + t, s = this._activeBuffer.lines.get(i);
                            s && (s.fill(e), s.isWrapped = !1);
                        }
                        return this._dirtyRowTracker.markAllDirty(), this._setCursor(0, 0), !0;
                    }
                    requestStatusString(e, t) {
                        const i = this._bufferService.buffer, s = this._optionsService.rawOptions;
                        return ((e)=>(this._coreService.triggerDataEvent(`${n.C0.ESC}${e}${n.C0.ESC}\\`), !0))('"q' === e ? `P1$r${this._curAttrData.isProtected() ? 1 : 0}"q` : '"p' === e ? 'P1$r61;1"p' : "r" === e ? `P1$r${i.scrollTop + 1};${i.scrollBottom + 1}r` : "m" === e ? "P1$r0m" : " q" === e ? `P1$r${({
                            block: 2,
                            underline: 4,
                            bar: 6
                        })[s.cursorStyle] - (s.cursorBlink ? 1 : 0)} q` : "P0$r");
                    }
                    markRangeDirty(e, t) {
                        this._dirtyRowTracker.markRangeDirty(e, t);
                    }
                }
                t.InputHandler = E;
                let L = class {
                    constructor(e){
                        this._bufferService = e, this.clearRange();
                    }
                    clearRange() {
                        this.start = this._bufferService.buffer.y, this.end = this._bufferService.buffer.y;
                    }
                    markDirty(e) {
                        e < this.start ? this.start = e : e > this.end && (this.end = e);
                    }
                    markRangeDirty(e, t) {
                        e > t && (w = e, e = t, t = w), e < this.start && (this.start = e), t > this.end && (this.end = t);
                    }
                    markAllDirty() {
                        this.markRangeDirty(0, this._bufferService.rows - 1);
                    }
                };
                L = s([
                    r(0, v.IBufferService)
                ], L);
            },
            844: (e, t)=>{
                function i(e) {
                    for (const t of e)t.dispose();
                    e.length = 0;
                }
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.getDisposeArrayDisposable = t.disposeArray = t.toDisposable = t.Disposable = void 0, t.Disposable = class {
                    constructor(){
                        this._disposables = [], this._isDisposed = !1;
                    }
                    dispose() {
                        this._isDisposed = !0;
                        for (const e of this._disposables)e.dispose();
                        this._disposables.length = 0;
                    }
                    register(e) {
                        return this._disposables.push(e), e;
                    }
                    unregister(e) {
                        const t = this._disposables.indexOf(e);
                        -1 !== t && this._disposables.splice(t, 1);
                    }
                }, t.toDisposable = function(e) {
                    return {
                        dispose: e
                    };
                }, t.disposeArray = i, t.getDisposeArrayDisposable = function(e) {
                    return {
                        dispose: ()=>i(e)
                    };
                };
            },
            1505: (e, t)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.FourKeyMap = t.TwoKeyMap = void 0;
                class i {
                    constructor(){
                        this._data = {};
                    }
                    set(e, t, i) {
                        this._data[e] || (this._data[e] = {}), this._data[e][t] = i;
                    }
                    get(e, t) {
                        return this._data[e] ? this._data[e][t] : void 0;
                    }
                    clear() {
                        this._data = {};
                    }
                }
                t.TwoKeyMap = i, t.FourKeyMap = class {
                    constructor(){
                        this._data = new i;
                    }
                    set(e, t, s, r, n) {
                        this._data.get(e, t) || this._data.set(e, t, new i), this._data.get(e, t).set(s, r, n);
                    }
                    get(e, t, i, s) {
                        var r;
                        return null === (r = this._data.get(e, t)) || void 0 === r ? void 0 : r.get(i, s);
                    }
                    clear() {
                        this._data.clear();
                    }
                };
            },
            6114: (e, t)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.isChromeOS = t.isLinux = t.isWindows = t.isIphone = t.isIpad = t.isMac = t.getSafariVersion = t.isSafari = t.isLegacyEdge = t.isFirefox = t.isNode = void 0, t.isNode = "undefined" == typeof navigator;
                const i = t.isNode ? "node" : navigator.userAgent, s = t.isNode ? "node" : navigator.platform;
                t.isFirefox = i.includes("Firefox"), t.isLegacyEdge = i.includes("Edge"), t.isSafari = /^((?!chrome|android).)*safari/i.test(i), t.getSafariVersion = function() {
                    if (!t.isSafari) return 0;
                    const e = i.match(/Version\/(\d+)/);
                    return null === e || e.length < 2 ? 0 : parseInt(e[1]);
                }, t.isMac = [
                    "Macintosh",
                    "MacIntel",
                    "MacPPC",
                    "Mac68K"
                ].includes(s), t.isIpad = "iPad" === s, t.isIphone = "iPhone" === s, t.isWindows = [
                    "Windows",
                    "Win16",
                    "Win32",
                    "WinCE"
                ].includes(s), t.isLinux = s.indexOf("Linux") >= 0, t.isChromeOS = /\bCrOS\b/.test(i);
            },
            6106: (e, t)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.SortedList = void 0;
                let i = 0;
                t.SortedList = class {
                    constructor(e){
                        this._getKey = e, this._array = [];
                    }
                    clear() {
                        this._array.length = 0;
                    }
                    insert(e) {
                        0 !== this._array.length ? (i = this._search(this._getKey(e), 0, this._array.length - 1), this._array.splice(i, 0, e)) : this._array.push(e);
                    }
                    delete(e) {
                        if (0 === this._array.length) return !1;
                        const t = this._getKey(e);
                        if (void 0 === t) return !1;
                        if (i = this._search(t, 0, this._array.length - 1), -1 === i) return !1;
                        if (this._getKey(this._array[i]) !== t) return !1;
                        do {
                            if (this._array[i] === e) return this._array.splice(i, 1), !0;
                        }while (++i < this._array.length && this._getKey(this._array[i]) === t);
                        return !1;
                    }
                    *getKeyIterator(e) {
                        if (0 !== this._array.length && (i = this._search(e, 0, this._array.length - 1), !(i < 0 || i >= this._array.length) && this._getKey(this._array[i]) === e)) do yield this._array[i];
                        while (++i < this._array.length && this._getKey(this._array[i]) === e);
                    }
                    forEachByKey(e, t) {
                        if (0 !== this._array.length && (i = this._search(e, 0, this._array.length - 1), !(i < 0 || i >= this._array.length) && this._getKey(this._array[i]) === e)) do t(this._array[i]);
                        while (++i < this._array.length && this._getKey(this._array[i]) === e);
                    }
                    values() {
                        return this._array.values();
                    }
                    _search(e, t, i) {
                        if (i < t) return t;
                        let s = Math.floor((t + i) / 2);
                        const r = this._getKey(this._array[s]);
                        if (r > e) return this._search(e, t, s - 1);
                        if (r < e) return this._search(e, s + 1, i);
                        for(; s > 0 && this._getKey(this._array[s - 1]) === e;)s--;
                        return s;
                    }
                };
            },
            7226: (e, t, i)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.DebouncedIdleTask = t.IdleTaskQueue = t.PriorityTaskQueue = void 0;
                const s = i(6114);
                class r {
                    constructor(){
                        this._tasks = [], this._i = 0;
                    }
                    enqueue(e) {
                        this._tasks.push(e), this._start();
                    }
                    flush() {
                        for(; this._i < this._tasks.length;)this._tasks[this._i]() || this._i++;
                        this.clear();
                    }
                    clear() {
                        this._idleCallback && (this._cancelCallback(this._idleCallback), this._idleCallback = void 0), this._i = 0, this._tasks.length = 0;
                    }
                    _start() {
                        this._idleCallback || (this._idleCallback = this._requestCallback(this._process.bind(this)));
                    }
                    _process(e) {
                        this._idleCallback = void 0;
                        let t = 0, i = 0, s = e.timeRemaining(), r = 0;
                        for(; this._i < this._tasks.length;){
                            if (t = Date.now(), this._tasks[this._i]() || this._i++, t = Math.max(1, Date.now() - t), i = Math.max(t, i), r = e.timeRemaining(), 1.5 * i > r) return s - t < -20 && console.warn(`task queue exceeded allotted deadline by ${Math.abs(Math.round(s - t))}ms`), void this._start();
                            s = r;
                        }
                        this.clear();
                    }
                }
                class n extends r {
                    _requestCallback(e) {
                        return setTimeout(()=>e(this._createDeadline(16)));
                    }
                    _cancelCallback(e) {
                        clearTimeout(e);
                    }
                    _createDeadline(e) {
                        const t = Date.now() + e;
                        return {
                            timeRemaining: ()=>Math.max(0, t - Date.now())
                        };
                    }
                }
                t.PriorityTaskQueue = n, t.IdleTaskQueue = !s.isNode && "requestIdleCallback" in window ? class extends r {
                    _requestCallback(e) {
                        return requestIdleCallback(e);
                    }
                    _cancelCallback(e) {
                        cancelIdleCallback(e);
                    }
                } : n, t.DebouncedIdleTask = class {
                    constructor(){
                        this._queue = new t.IdleTaskQueue;
                    }
                    set(e) {
                        this._queue.clear(), this._queue.enqueue(e);
                    }
                    flush() {
                        this._queue.flush();
                    }
                };
            },
            9282: (e, t, i)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.updateWindowsModeWrappedState = void 0;
                const s = i(643);
                t.updateWindowsModeWrappedState = function(e) {
                    const t = e.buffer.lines.get(e.buffer.ybase + e.buffer.y - 1), i = null == t ? void 0 : t.get(e.cols - 1), r = e.buffer.lines.get(e.buffer.ybase + e.buffer.y);
                    r && i && (r.isWrapped = i[s.CHAR_DATA_CODE_INDEX] !== s.NULL_CELL_CODE && i[s.CHAR_DATA_CODE_INDEX] !== s.WHITESPACE_CELL_CODE);
                };
            },
            3734: (e, t)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.ExtendedAttrs = t.AttributeData = void 0;
                class i {
                    constructor(){
                        this.fg = 0, this.bg = 0, this.extended = new s;
                    }
                    static toColorRGB(e) {
                        return [
                            e >>> 16 & 255,
                            e >>> 8 & 255,
                            255 & e
                        ];
                    }
                    static fromColorRGB(e) {
                        return (255 & e[0]) << 16 | (255 & e[1]) << 8 | 255 & e[2];
                    }
                    clone() {
                        const e = new i;
                        return e.fg = this.fg, e.bg = this.bg, e.extended = this.extended.clone(), e;
                    }
                    isInverse() {
                        return 67108864 & this.fg;
                    }
                    isBold() {
                        return 134217728 & this.fg;
                    }
                    isUnderline() {
                        return this.hasExtendedAttrs() && 0 !== this.extended.underlineStyle ? 1 : 268435456 & this.fg;
                    }
                    isBlink() {
                        return 536870912 & this.fg;
                    }
                    isInvisible() {
                        return 1073741824 & this.fg;
                    }
                    isItalic() {
                        return 67108864 & this.bg;
                    }
                    isDim() {
                        return 134217728 & this.bg;
                    }
                    isStrikethrough() {
                        return 2147483648 & this.fg;
                    }
                    isProtected() {
                        return 536870912 & this.bg;
                    }
                    isOverline() {
                        return 1073741824 & this.bg;
                    }
                    getFgColorMode() {
                        return 50331648 & this.fg;
                    }
                    getBgColorMode() {
                        return 50331648 & this.bg;
                    }
                    isFgRGB() {
                        return 50331648 == (50331648 & this.fg);
                    }
                    isBgRGB() {
                        return 50331648 == (50331648 & this.bg);
                    }
                    isFgPalette() {
                        return 16777216 == (50331648 & this.fg) || 33554432 == (50331648 & this.fg);
                    }
                    isBgPalette() {
                        return 16777216 == (50331648 & this.bg) || 33554432 == (50331648 & this.bg);
                    }
                    isFgDefault() {
                        return 0 == (50331648 & this.fg);
                    }
                    isBgDefault() {
                        return 0 == (50331648 & this.bg);
                    }
                    isAttributeDefault() {
                        return 0 === this.fg && 0 === this.bg;
                    }
                    getFgColor() {
                        switch(50331648 & this.fg){
                            case 16777216:
                            case 33554432:
                                return 255 & this.fg;
                            case 50331648:
                                return 16777215 & this.fg;
                            default:
                                return -1;
                        }
                    }
                    getBgColor() {
                        switch(50331648 & this.bg){
                            case 16777216:
                            case 33554432:
                                return 255 & this.bg;
                            case 50331648:
                                return 16777215 & this.bg;
                            default:
                                return -1;
                        }
                    }
                    hasExtendedAttrs() {
                        return 268435456 & this.bg;
                    }
                    updateExtended() {
                        this.extended.isEmpty() ? this.bg &= -268435457 : this.bg |= 268435456;
                    }
                    getUnderlineColor() {
                        if (268435456 & this.bg && ~this.extended.underlineColor) switch(50331648 & this.extended.underlineColor){
                            case 16777216:
                            case 33554432:
                                return 255 & this.extended.underlineColor;
                            case 50331648:
                                return 16777215 & this.extended.underlineColor;
                            default:
                                return this.getFgColor();
                        }
                        return this.getFgColor();
                    }
                    getUnderlineColorMode() {
                        return 268435456 & this.bg && ~this.extended.underlineColor ? 50331648 & this.extended.underlineColor : this.getFgColorMode();
                    }
                    isUnderlineColorRGB() {
                        return 268435456 & this.bg && ~this.extended.underlineColor ? 50331648 == (50331648 & this.extended.underlineColor) : this.isFgRGB();
                    }
                    isUnderlineColorPalette() {
                        return 268435456 & this.bg && ~this.extended.underlineColor ? 16777216 == (50331648 & this.extended.underlineColor) || 33554432 == (50331648 & this.extended.underlineColor) : this.isFgPalette();
                    }
                    isUnderlineColorDefault() {
                        return 268435456 & this.bg && ~this.extended.underlineColor ? 0 == (50331648 & this.extended.underlineColor) : this.isFgDefault();
                    }
                    getUnderlineStyle() {
                        return 268435456 & this.fg ? 268435456 & this.bg ? this.extended.underlineStyle : 1 : 0;
                    }
                }
                t.AttributeData = i;
                class s {
                    constructor(e = 0, t = 0){
                        this._ext = 0, this._urlId = 0, this._ext = e, this._urlId = t;
                    }
                    get ext() {
                        return this._urlId ? -469762049 & this._ext | this.underlineStyle << 26 : this._ext;
                    }
                    set ext(e) {
                        this._ext = e;
                    }
                    get underlineStyle() {
                        return this._urlId ? 5 : (469762048 & this._ext) >> 26;
                    }
                    set underlineStyle(e) {
                        this._ext &= -469762049, this._ext |= e << 26 & 469762048;
                    }
                    get underlineColor() {
                        return 67108863 & this._ext;
                    }
                    set underlineColor(e) {
                        this._ext &= -67108864, this._ext |= 67108863 & e;
                    }
                    get urlId() {
                        return this._urlId;
                    }
                    set urlId(e) {
                        this._urlId = e;
                    }
                    clone() {
                        return new s(this._ext, this._urlId);
                    }
                    isEmpty() {
                        return 0 === this.underlineStyle && 0 === this._urlId;
                    }
                }
                t.ExtendedAttrs = s;
            },
            9092: (e, t, i)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.Buffer = t.MAX_BUFFER_SIZE = void 0;
                const s = i(6349), r = i(8437), n = i(511), o = i(643), a = i(4634), h = i(4863), c = i(7116), l = i(3734), d = i(7226);
                t.MAX_BUFFER_SIZE = 4294967295, t.Buffer = class {
                    constructor(e, t, i){
                        this._hasScrollback = e, this._optionsService = t, this._bufferService = i, this.ydisp = 0, this.ybase = 0, this.y = 0, this.x = 0, this.tabs = {}, this.savedY = 0, this.savedX = 0, this.savedCurAttrData = r.DEFAULT_ATTR_DATA.clone(), this.savedCharset = c.DEFAULT_CHARSET, this.markers = [], this._nullCell = n.CellData.fromCharData([
                            0,
                            o.NULL_CELL_CHAR,
                            o.NULL_CELL_WIDTH,
                            o.NULL_CELL_CODE
                        ]), this._whitespaceCell = n.CellData.fromCharData([
                            0,
                            o.WHITESPACE_CELL_CHAR,
                            o.WHITESPACE_CELL_WIDTH,
                            o.WHITESPACE_CELL_CODE
                        ]), this._isClearing = !1, this._memoryCleanupQueue = new d.IdleTaskQueue, this._memoryCleanupPosition = 0, this._cols = this._bufferService.cols, this._rows = this._bufferService.rows, this.lines = new s.CircularList(this._getCorrectBufferLength(this._rows)), this.scrollTop = 0, this.scrollBottom = this._rows - 1, this.setupTabStops();
                    }
                    getNullCell(e) {
                        return e ? (this._nullCell.fg = e.fg, this._nullCell.bg = e.bg, this._nullCell.extended = e.extended) : (this._nullCell.fg = 0, this._nullCell.bg = 0, this._nullCell.extended = new l.ExtendedAttrs), this._nullCell;
                    }
                    getWhitespaceCell(e) {
                        return e ? (this._whitespaceCell.fg = e.fg, this._whitespaceCell.bg = e.bg, this._whitespaceCell.extended = e.extended) : (this._whitespaceCell.fg = 0, this._whitespaceCell.bg = 0, this._whitespaceCell.extended = new l.ExtendedAttrs), this._whitespaceCell;
                    }
                    getBlankLine(e, t) {
                        return new r.BufferLine(this._bufferService.cols, this.getNullCell(e), t);
                    }
                    get hasScrollback() {
                        return this._hasScrollback && this.lines.maxLength > this._rows;
                    }
                    get isCursorInViewport() {
                        const e = this.ybase + this.y - this.ydisp;
                        return e >= 0 && e < this._rows;
                    }
                    _getCorrectBufferLength(e) {
                        if (!this._hasScrollback) return e;
                        const i = e + this._optionsService.rawOptions.scrollback;
                        return i > t.MAX_BUFFER_SIZE ? t.MAX_BUFFER_SIZE : i;
                    }
                    fillViewportRows(e) {
                        if (0 === this.lines.length) {
                            void 0 === e && (e = r.DEFAULT_ATTR_DATA);
                            let t = this._rows;
                            for(; t--;)this.lines.push(this.getBlankLine(e));
                        }
                    }
                    clear() {
                        this.ydisp = 0, this.ybase = 0, this.y = 0, this.x = 0, this.lines = new s.CircularList(this._getCorrectBufferLength(this._rows)), this.scrollTop = 0, this.scrollBottom = this._rows - 1, this.setupTabStops();
                    }
                    resize(e, t) {
                        const i = this.getNullCell(r.DEFAULT_ATTR_DATA);
                        let s = 0;
                        const n = this._getCorrectBufferLength(t);
                        if (n > this.lines.maxLength && (this.lines.maxLength = n), this.lines.length > 0) {
                            if (this._cols < e) for(let t = 0; t < this.lines.length; t++)s += +this.lines.get(t).resize(e, i);
                            let o = 0;
                            if (this._rows < t) for(let s = this._rows; s < t; s++)this.lines.length < t + this.ybase && (this._optionsService.rawOptions.windowsMode || void 0 !== this._optionsService.rawOptions.windowsPty.backend || void 0 !== this._optionsService.rawOptions.windowsPty.buildNumber ? this.lines.push(new r.BufferLine(e, i)) : this.ybase > 0 && this.lines.length <= this.ybase + this.y + o + 1 ? (this.ybase--, o++, this.ydisp > 0 && this.ydisp--) : this.lines.push(new r.BufferLine(e, i)));
                            else for(let e = this._rows; e > t; e--)this.lines.length > t + this.ybase && (this.lines.length > this.ybase + this.y + 1 ? this.lines.pop() : (this.ybase++, this.ydisp++));
                            if (n < this.lines.maxLength) {
                                const e = this.lines.length - n;
                                e > 0 && (this.lines.trimStart(e), this.ybase = Math.max(this.ybase - e, 0), this.ydisp = Math.max(this.ydisp - e, 0), this.savedY = Math.max(this.savedY - e, 0)), this.lines.maxLength = n;
                            }
                            this.x = Math.min(this.x, e - 1), this.y = Math.min(this.y, t - 1), o && (this.y += o), this.savedX = Math.min(this.savedX, e - 1), this.scrollTop = 0;
                        }
                        if (this.scrollBottom = t - 1, this._isReflowEnabled && (this._reflow(e, t), this._cols > e)) for(let t = 0; t < this.lines.length; t++)s += +this.lines.get(t).resize(e, i);
                        this._cols = e, this._rows = t, this._memoryCleanupQueue.clear(), s > .1 * this.lines.length && (this._memoryCleanupPosition = 0, this._memoryCleanupQueue.enqueue(()=>this._batchedMemoryCleanup()));
                    }
                    _batchedMemoryCleanup() {
                        let e = !0;
                        this._memoryCleanupPosition >= this.lines.length && (this._memoryCleanupPosition = 0, e = !1);
                        let t = 0;
                        for(; this._memoryCleanupPosition < this.lines.length;)if (t += this.lines.get(this._memoryCleanupPosition++).cleanupMemory(), t > 100) return !0;
                        return e;
                    }
                    get _isReflowEnabled() {
                        const e = this._optionsService.rawOptions.windowsPty;
                        return e && e.buildNumber ? this._hasScrollback && "conpty" === e.backend && e.buildNumber >= 21376 : this._hasScrollback && !this._optionsService.rawOptions.windowsMode;
                    }
                    _reflow(e, t) {
                        this._cols !== e && (e > this._cols ? this._reflowLarger(e, t) : this._reflowSmaller(e, t));
                    }
                    _reflowLarger(e, t) {
                        const i = (0, a.reflowLargerGetLinesToRemove)(this.lines, this._cols, e, this.ybase + this.y, this.getNullCell(r.DEFAULT_ATTR_DATA));
                        if (i.length > 0) {
                            const s = (0, a.reflowLargerCreateNewLayout)(this.lines, i);
                            (0, a.reflowLargerApplyNewLayout)(this.lines, s.layout), this._reflowLargerAdjustViewport(e, t, s.countRemoved);
                        }
                    }
                    _reflowLargerAdjustViewport(e, t, i) {
                        const s = this.getNullCell(r.DEFAULT_ATTR_DATA);
                        let n = i;
                        for(; n-- > 0;)0 === this.ybase ? (this.y > 0 && this.y--, this.lines.length < t && this.lines.push(new r.BufferLine(e, s))) : (this.ydisp === this.ybase && this.ydisp--, this.ybase--);
                        this.savedY = Math.max(this.savedY - i, 0);
                    }
                    _reflowSmaller(e, t) {
                        const i = this.getNullCell(r.DEFAULT_ATTR_DATA), s = [];
                        let n = 0;
                        for(let o = this.lines.length - 1; o >= 0; o--){
                            let h = this.lines.get(o);
                            if (!h || !h.isWrapped && h.getTrimmedLength() <= e) continue;
                            const c = [
                                h
                            ];
                            for(; h.isWrapped && o > 0;)h = this.lines.get(--o), c.unshift(h);
                            const l = this.ybase + this.y;
                            if (l >= o && l < o + c.length) continue;
                            const d = c[c.length - 1].getTrimmedLength(), _ = (0, a.reflowSmallerGetNewLineLengths)(c, this._cols, e), u = _.length - c.length;
                            let f;
                            f = 0 === this.ybase && this.y !== this.lines.length - 1 ? Math.max(0, this.y - this.lines.maxLength + u) : Math.max(0, this.lines.length - this.lines.maxLength + u);
                            const v = [];
                            for(let e = 0; e < u; e++){
                                const e = this.getBlankLine(r.DEFAULT_ATTR_DATA, !0);
                                v.push(e);
                            }
                            v.length > 0 && (s.push({
                                start: o + c.length + n,
                                newLines: v
                            }), n += v.length), c.push(...v);
                            let g = _.length - 1, p = _[g];
                            0 === p && (g--, p = _[g]);
                            let S = c.length - u - 1, m = d;
                            for(; S >= 0;){
                                const e = Math.min(m, p);
                                if (void 0 === c[g]) break;
                                if (c[g].copyCellsFrom(c[S], m - e, p - e, e, !0), p -= e, 0 === p && (g--, p = _[g]), m -= e, 0 === m) {
                                    S--;
                                    const e = Math.max(S, 0);
                                    m = (0, a.getWrappedLineTrimmedLength)(c, e, this._cols);
                                }
                            }
                            for(let t = 0; t < c.length; t++)_[t] < e && c[t].setCell(_[t], i);
                            let C = u - f;
                            for(; C-- > 0;)0 === this.ybase ? this.y < t - 1 ? (this.y++, this.lines.pop()) : (this.ybase++, this.ydisp++) : this.ybase < Math.min(this.lines.maxLength, this.lines.length + n) - t && (this.ybase === this.ydisp && this.ydisp++, this.ybase++);
                            this.savedY = Math.min(this.savedY + u, this.ybase + t - 1);
                        }
                        if (s.length > 0) {
                            const e = [], t = [];
                            for(let e = 0; e < this.lines.length; e++)t.push(this.lines.get(e));
                            const i = this.lines.length;
                            let r = i - 1, o = 0, a = s[o];
                            this.lines.length = Math.min(this.lines.maxLength, this.lines.length + n);
                            let h = 0;
                            for(let c = Math.min(this.lines.maxLength - 1, i + n - 1); c >= 0; c--)if (a && a.start > r + h) {
                                for(let e = a.newLines.length - 1; e >= 0; e--)this.lines.set(c--, a.newLines[e]);
                                c++, e.push({
                                    index: r + 1,
                                    amount: a.newLines.length
                                }), h += a.newLines.length, a = s[++o];
                            } else this.lines.set(c, t[r--]);
                            let c = 0;
                            for(let t = e.length - 1; t >= 0; t--)e[t].index += c, this.lines.onInsertEmitter.fire(e[t]), c += e[t].amount;
                            const l = Math.max(0, i + n - this.lines.maxLength);
                            l > 0 && this.lines.onTrimEmitter.fire(l);
                        }
                    }
                    translateBufferLineToString(e, t, i = 0, s) {
                        const r = this.lines.get(e);
                        return r ? r.translateToString(t, i, s) : "";
                    }
                    getWrappedRangeForLine(e) {
                        let t = e, i = e;
                        for(; t > 0 && this.lines.get(t).isWrapped;)t--;
                        for(; i + 1 < this.lines.length && this.lines.get(i + 1).isWrapped;)i++;
                        return {
                            first: t,
                            last: i
                        };
                    }
                    setupTabStops(e) {
                        for(null != e ? this.tabs[e] || (e = this.prevStop(e)) : (this.tabs = {}, e = 0); e < this._cols; e += this._optionsService.rawOptions.tabStopWidth)this.tabs[e] = !0;
                    }
                    prevStop(e) {
                        for(null == e && (e = this.x); !this.tabs[--e] && e > 0;);
                        return e >= this._cols ? this._cols - 1 : e < 0 ? 0 : e;
                    }
                    nextStop(e) {
                        for(null == e && (e = this.x); !this.tabs[++e] && e < this._cols;);
                        return e >= this._cols ? this._cols - 1 : e < 0 ? 0 : e;
                    }
                    clearMarkers(e) {
                        this._isClearing = !0;
                        for(let t = 0; t < this.markers.length; t++)this.markers[t].line === e && (this.markers[t].dispose(), this.markers.splice(t--, 1));
                        this._isClearing = !1;
                    }
                    clearAllMarkers() {
                        this._isClearing = !0;
                        for(let e = 0; e < this.markers.length; e++)this.markers[e].dispose(), this.markers.splice(e--, 1);
                        this._isClearing = !1;
                    }
                    addMarker(e) {
                        const t = new h.Marker(e);
                        return this.markers.push(t), t.register(this.lines.onTrim((e)=>{
                            t.line -= e, t.line < 0 && t.dispose();
                        })), t.register(this.lines.onInsert((e)=>{
                            t.line >= e.index && (t.line += e.amount);
                        })), t.register(this.lines.onDelete((e)=>{
                            t.line >= e.index && t.line < e.index + e.amount && t.dispose(), t.line > e.index && (t.line -= e.amount);
                        })), t.register(t.onDispose(()=>this._removeMarker(t))), t;
                    }
                    _removeMarker(e) {
                        this._isClearing || this.markers.splice(this.markers.indexOf(e), 1);
                    }
                };
            },
            8437: (e, t, i)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.BufferLine = t.DEFAULT_ATTR_DATA = void 0;
                const s = i(482), r = i(643), n = i(511), o = i(3734);
                t.DEFAULT_ATTR_DATA = Object.freeze(new o.AttributeData);
                let a = 0;
                class h {
                    constructor(e, t, i = !1){
                        this.isWrapped = i, this._combined = {}, this._extendedAttrs = {}, this._data = new Uint32Array(3 * e);
                        const s = t || n.CellData.fromCharData([
                            0,
                            r.NULL_CELL_CHAR,
                            r.NULL_CELL_WIDTH,
                            r.NULL_CELL_CODE
                        ]);
                        for(let t = 0; t < e; ++t)this.setCell(t, s);
                        this.length = e;
                    }
                    get(e) {
                        const t = this._data[3 * e + 0], i = 2097151 & t;
                        return [
                            this._data[3 * e + 1],
                            2097152 & t ? this._combined[e] : i ? (0, s.stringFromCodePoint)(i) : "",
                            t >> 22,
                            2097152 & t ? this._combined[e].charCodeAt(this._combined[e].length - 1) : i
                        ];
                    }
                    set(e, t) {
                        this._data[3 * e + 1] = t[r.CHAR_DATA_ATTR_INDEX], t[r.CHAR_DATA_CHAR_INDEX].length > 1 ? (this._combined[e] = t[1], this._data[3 * e + 0] = 2097152 | e | t[r.CHAR_DATA_WIDTH_INDEX] << 22) : this._data[3 * e + 0] = t[r.CHAR_DATA_CHAR_INDEX].charCodeAt(0) | t[r.CHAR_DATA_WIDTH_INDEX] << 22;
                    }
                    getWidth(e) {
                        return this._data[3 * e + 0] >> 22;
                    }
                    hasWidth(e) {
                        return 12582912 & this._data[3 * e + 0];
                    }
                    getFg(e) {
                        return this._data[3 * e + 1];
                    }
                    getBg(e) {
                        return this._data[3 * e + 2];
                    }
                    hasContent(e) {
                        return 4194303 & this._data[3 * e + 0];
                    }
                    getCodePoint(e) {
                        const t = this._data[3 * e + 0];
                        return 2097152 & t ? this._combined[e].charCodeAt(this._combined[e].length - 1) : 2097151 & t;
                    }
                    isCombined(e) {
                        return 2097152 & this._data[3 * e + 0];
                    }
                    getString(e) {
                        const t = this._data[3 * e + 0];
                        return 2097152 & t ? this._combined[e] : 2097151 & t ? (0, s.stringFromCodePoint)(2097151 & t) : "";
                    }
                    isProtected(e) {
                        return 536870912 & this._data[3 * e + 2];
                    }
                    loadCell(e, t) {
                        return a = 3 * e, t.content = this._data[a + 0], t.fg = this._data[a + 1], t.bg = this._data[a + 2], 2097152 & t.content && (t.combinedData = this._combined[e]), 268435456 & t.bg && (t.extended = this._extendedAttrs[e]), t;
                    }
                    setCell(e, t) {
                        2097152 & t.content && (this._combined[e] = t.combinedData), 268435456 & t.bg && (this._extendedAttrs[e] = t.extended), this._data[3 * e + 0] = t.content, this._data[3 * e + 1] = t.fg, this._data[3 * e + 2] = t.bg;
                    }
                    setCellFromCodePoint(e, t, i, s, r, n) {
                        268435456 & r && (this._extendedAttrs[e] = n), this._data[3 * e + 0] = t | i << 22, this._data[3 * e + 1] = s, this._data[3 * e + 2] = r;
                    }
                    addCodepointToCell(e, t) {
                        let i = this._data[3 * e + 0];
                        2097152 & i ? this._combined[e] += (0, s.stringFromCodePoint)(t) : (2097151 & i ? (this._combined[e] = (0, s.stringFromCodePoint)(2097151 & i) + (0, s.stringFromCodePoint)(t), i &= -2097152, i |= 2097152) : i = t | 4194304, this._data[3 * e + 0] = i);
                    }
                    insertCells(e, t, i, s) {
                        if ((e %= this.length) && 2 === this.getWidth(e - 1) && this.setCellFromCodePoint(e - 1, 0, 1, (null == s ? void 0 : s.fg) || 0, (null == s ? void 0 : s.bg) || 0, (null == s ? void 0 : s.extended) || new o.ExtendedAttrs), t < this.length - e) {
                            const s = new n.CellData;
                            for(let i = this.length - e - t - 1; i >= 0; --i)this.setCell(e + t + i, this.loadCell(e + i, s));
                            for(let s = 0; s < t; ++s)this.setCell(e + s, i);
                        } else for(let t = e; t < this.length; ++t)this.setCell(t, i);
                        2 === this.getWidth(this.length - 1) && this.setCellFromCodePoint(this.length - 1, 0, 1, (null == s ? void 0 : s.fg) || 0, (null == s ? void 0 : s.bg) || 0, (null == s ? void 0 : s.extended) || new o.ExtendedAttrs);
                    }
                    deleteCells(e, t, i, s) {
                        if (e %= this.length, t < this.length - e) {
                            const s = new n.CellData;
                            for(let i = 0; i < this.length - e - t; ++i)this.setCell(e + i, this.loadCell(e + t + i, s));
                            for(let e = this.length - t; e < this.length; ++e)this.setCell(e, i);
                        } else for(let t = e; t < this.length; ++t)this.setCell(t, i);
                        e && 2 === this.getWidth(e - 1) && this.setCellFromCodePoint(e - 1, 0, 1, (null == s ? void 0 : s.fg) || 0, (null == s ? void 0 : s.bg) || 0, (null == s ? void 0 : s.extended) || new o.ExtendedAttrs), 0 !== this.getWidth(e) || this.hasContent(e) || this.setCellFromCodePoint(e, 0, 1, (null == s ? void 0 : s.fg) || 0, (null == s ? void 0 : s.bg) || 0, (null == s ? void 0 : s.extended) || new o.ExtendedAttrs);
                    }
                    replaceCells(e, t, i, s, r = !1) {
                        if (r) for(e && 2 === this.getWidth(e - 1) && !this.isProtected(e - 1) && this.setCellFromCodePoint(e - 1, 0, 1, (null == s ? void 0 : s.fg) || 0, (null == s ? void 0 : s.bg) || 0, (null == s ? void 0 : s.extended) || new o.ExtendedAttrs), t < this.length && 2 === this.getWidth(t - 1) && !this.isProtected(t) && this.setCellFromCodePoint(t, 0, 1, (null == s ? void 0 : s.fg) || 0, (null == s ? void 0 : s.bg) || 0, (null == s ? void 0 : s.extended) || new o.ExtendedAttrs); e < t && e < this.length;)this.isProtected(e) || this.setCell(e, i), e++;
                        else for(e && 2 === this.getWidth(e - 1) && this.setCellFromCodePoint(e - 1, 0, 1, (null == s ? void 0 : s.fg) || 0, (null == s ? void 0 : s.bg) || 0, (null == s ? void 0 : s.extended) || new o.ExtendedAttrs), t < this.length && 2 === this.getWidth(t - 1) && this.setCellFromCodePoint(t, 0, 1, (null == s ? void 0 : s.fg) || 0, (null == s ? void 0 : s.bg) || 0, (null == s ? void 0 : s.extended) || new o.ExtendedAttrs); e < t && e < this.length;)this.setCell(e++, i);
                    }
                    resize(e, t) {
                        if (e === this.length) return 4 * this._data.length * 2 < this._data.buffer.byteLength;
                        const i = 3 * e;
                        if (e > this.length) {
                            if (this._data.buffer.byteLength >= 4 * i) this._data = new Uint32Array(this._data.buffer, 0, i);
                            else {
                                const e = new Uint32Array(i);
                                e.set(this._data), this._data = e;
                            }
                            for(let i = this.length; i < e; ++i)this.setCell(i, t);
                        } else {
                            this._data = this._data.subarray(0, i);
                            const t = Object.keys(this._combined);
                            for(let i = 0; i < t.length; i++){
                                const s = parseInt(t[i], 10);
                                s >= e && delete this._combined[s];
                            }
                            const s = Object.keys(this._extendedAttrs);
                            for(let t = 0; t < s.length; t++){
                                const i = parseInt(s[t], 10);
                                i >= e && delete this._extendedAttrs[i];
                            }
                        }
                        return this.length = e, 4 * i * 2 < this._data.buffer.byteLength;
                    }
                    cleanupMemory() {
                        if (4 * this._data.length * 2 < this._data.buffer.byteLength) {
                            const e = new Uint32Array(this._data.length);
                            return e.set(this._data), this._data = e, 1;
                        }
                        return 0;
                    }
                    fill(e, t = !1) {
                        if (t) for(let t = 0; t < this.length; ++t)this.isProtected(t) || this.setCell(t, e);
                        else {
                            this._combined = {}, this._extendedAttrs = {};
                            for(let t = 0; t < this.length; ++t)this.setCell(t, e);
                        }
                    }
                    copyFrom(e) {
                        this.length !== e.length ? this._data = new Uint32Array(e._data) : this._data.set(e._data), this.length = e.length, this._combined = {};
                        for(const t in e._combined)this._combined[t] = e._combined[t];
                        this._extendedAttrs = {};
                        for(const t in e._extendedAttrs)this._extendedAttrs[t] = e._extendedAttrs[t];
                        this.isWrapped = e.isWrapped;
                    }
                    clone() {
                        const e = new h(0);
                        e._data = new Uint32Array(this._data), e.length = this.length;
                        for(const t in this._combined)e._combined[t] = this._combined[t];
                        for(const t in this._extendedAttrs)e._extendedAttrs[t] = this._extendedAttrs[t];
                        return e.isWrapped = this.isWrapped, e;
                    }
                    getTrimmedLength() {
                        for(let e = this.length - 1; e >= 0; --e)if (4194303 & this._data[3 * e + 0]) return e + (this._data[3 * e + 0] >> 22);
                        return 0;
                    }
                    copyCellsFrom(e, t, i, s, r) {
                        const n = e._data;
                        if (r) for(let r = s - 1; r >= 0; r--){
                            for(let e = 0; e < 3; e++)this._data[3 * (i + r) + e] = n[3 * (t + r) + e];
                            268435456 & n[3 * (t + r) + 2] && (this._extendedAttrs[i + r] = e._extendedAttrs[t + r]);
                        }
                        else for(let r = 0; r < s; r++){
                            for(let e = 0; e < 3; e++)this._data[3 * (i + r) + e] = n[3 * (t + r) + e];
                            268435456 & n[3 * (t + r) + 2] && (this._extendedAttrs[i + r] = e._extendedAttrs[t + r]);
                        }
                        const o = Object.keys(e._combined);
                        for(let s = 0; s < o.length; s++){
                            const r = parseInt(o[s], 10);
                            r >= t && (this._combined[r - t + i] = e._combined[r]);
                        }
                    }
                    translateToString(e = !1, t = 0, i = this.length) {
                        e && (i = Math.min(i, this.getTrimmedLength()));
                        let n = "";
                        for(; t < i;){
                            const e = this._data[3 * t + 0], i = 2097151 & e;
                            n += 2097152 & e ? this._combined[t] : i ? (0, s.stringFromCodePoint)(i) : r.WHITESPACE_CELL_CHAR, t += e >> 22 || 1;
                        }
                        return n;
                    }
                }
                t.BufferLine = h;
            },
            4841: (e, t)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.getRangeLength = void 0, t.getRangeLength = function(e, t) {
                    if (e.start.y > e.end.y) throw new Error(`Buffer range end (${e.end.x}, ${e.end.y}) cannot be before start (${e.start.x}, ${e.start.y})`);
                    return t * (e.end.y - e.start.y) + (e.end.x - e.start.x + 1);
                };
            },
            4634: (e, t)=>{
                function i(e, t, i) {
                    if (t === e.length - 1) return e[t].getTrimmedLength();
                    const s = !e[t].hasContent(i - 1) && 1 === e[t].getWidth(i - 1), r = 2 === e[t + 1].getWidth(0);
                    return s && r ? i - 1 : i;
                }
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.getWrappedLineTrimmedLength = t.reflowSmallerGetNewLineLengths = t.reflowLargerApplyNewLayout = t.reflowLargerCreateNewLayout = t.reflowLargerGetLinesToRemove = void 0, t.reflowLargerGetLinesToRemove = function(e, t, s, r, n) {
                    const o = [];
                    for(let a = 0; a < e.length - 1; a++){
                        let h = a, c = e.get(++h);
                        if (!c.isWrapped) continue;
                        const l = [
                            e.get(a)
                        ];
                        for(; h < e.length && c.isWrapped;)l.push(c), c = e.get(++h);
                        if (r >= a && r < h) {
                            a += l.length - 1;
                            continue;
                        }
                        let d = 0, _ = i(l, d, t), u = 1, f = 0;
                        for(; u < l.length;){
                            const e = i(l, u, t), r = e - f, o = s - _, a = Math.min(r, o);
                            l[d].copyCellsFrom(l[u], f, _, a, !1), _ += a, _ === s && (d++, _ = 0), f += a, f === e && (u++, f = 0), 0 === _ && 0 !== d && 2 === l[d - 1].getWidth(s - 1) && (l[d].copyCellsFrom(l[d - 1], s - 1, _++, 1, !1), l[d - 1].setCell(s - 1, n));
                        }
                        l[d].replaceCells(_, s, n);
                        let v = 0;
                        for(let e = l.length - 1; e > 0 && (e > d || 0 === l[e].getTrimmedLength()); e--)v++;
                        v > 0 && (o.push(a + l.length - v), o.push(v)), a += l.length - 1;
                    }
                    return o;
                }, t.reflowLargerCreateNewLayout = function(e, t) {
                    const i = [];
                    let s = 0, r = t[s], n = 0;
                    for(let o = 0; o < e.length; o++)if (r === o) {
                        const i = t[++s];
                        e.onDeleteEmitter.fire({
                            index: o - n,
                            amount: i
                        }), o += i - 1, n += i, r = t[++s];
                    } else i.push(o);
                    return {
                        layout: i,
                        countRemoved: n
                    };
                }, t.reflowLargerApplyNewLayout = function(e, t) {
                    const i = [];
                    for(let s = 0; s < t.length; s++)i.push(e.get(t[s]));
                    for(let t = 0; t < i.length; t++)e.set(t, i[t]);
                    e.length = t.length;
                }, t.reflowSmallerGetNewLineLengths = function(e, t, s) {
                    const r = [], n = e.map((s, r)=>i(e, r, t)).reduce((e, t)=>e + t);
                    let o = 0, a = 0, h = 0;
                    for(; h < n;){
                        if (n - h < s) {
                            r.push(n - h);
                            break;
                        }
                        o += s;
                        const c = i(e, a, t);
                        o > c && (o -= c, a++);
                        const l = 2 === e[a].getWidth(o - 1);
                        l && o--;
                        const d = l ? s - 1 : s;
                        r.push(d), h += d;
                    }
                    return r;
                }, t.getWrappedLineTrimmedLength = i;
            },
            5295: (e, t, i)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.BufferSet = void 0;
                const s = i(9092), r = i(8460), n = i(844);
                class o extends n.Disposable {
                    constructor(e, t){
                        super(), this._optionsService = e, this._bufferService = t, this._onBufferActivate = this.register(new r.EventEmitter), this.onBufferActivate = this._onBufferActivate.event, this.reset(), this.register(this._optionsService.onSpecificOptionChange("scrollback", ()=>this.resize(this._bufferService.cols, this._bufferService.rows))), this.register(this._optionsService.onSpecificOptionChange("tabStopWidth", ()=>this.setupTabStops()));
                    }
                    reset() {
                        this._normal = new s.Buffer(!0, this._optionsService, this._bufferService), this._normal.fillViewportRows(), this._alt = new s.Buffer(!1, this._optionsService, this._bufferService), this._activeBuffer = this._normal, this._onBufferActivate.fire({
                            activeBuffer: this._normal,
                            inactiveBuffer: this._alt
                        }), this.setupTabStops();
                    }
                    get alt() {
                        return this._alt;
                    }
                    get active() {
                        return this._activeBuffer;
                    }
                    get normal() {
                        return this._normal;
                    }
                    activateNormalBuffer() {
                        this._activeBuffer !== this._normal && (this._normal.x = this._alt.x, this._normal.y = this._alt.y, this._alt.clearAllMarkers(), this._alt.clear(), this._activeBuffer = this._normal, this._onBufferActivate.fire({
                            activeBuffer: this._normal,
                            inactiveBuffer: this._alt
                        }));
                    }
                    activateAltBuffer(e) {
                        this._activeBuffer !== this._alt && (this._alt.fillViewportRows(e), this._alt.x = this._normal.x, this._alt.y = this._normal.y, this._activeBuffer = this._alt, this._onBufferActivate.fire({
                            activeBuffer: this._alt,
                            inactiveBuffer: this._normal
                        }));
                    }
                    resize(e, t) {
                        this._normal.resize(e, t), this._alt.resize(e, t), this.setupTabStops(e);
                    }
                    setupTabStops(e) {
                        this._normal.setupTabStops(e), this._alt.setupTabStops(e);
                    }
                }
                t.BufferSet = o;
            },
            511: (e, t, i)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.CellData = void 0;
                const s = i(482), r = i(643), n = i(3734);
                class o extends n.AttributeData {
                    constructor(){
                        super(...arguments), this.content = 0, this.fg = 0, this.bg = 0, this.extended = new n.ExtendedAttrs, this.combinedData = "";
                    }
                    static fromCharData(e) {
                        const t = new o;
                        return t.setFromCharData(e), t;
                    }
                    isCombined() {
                        return 2097152 & this.content;
                    }
                    getWidth() {
                        return this.content >> 22;
                    }
                    getChars() {
                        return 2097152 & this.content ? this.combinedData : 2097151 & this.content ? (0, s.stringFromCodePoint)(2097151 & this.content) : "";
                    }
                    getCode() {
                        return this.isCombined() ? this.combinedData.charCodeAt(this.combinedData.length - 1) : 2097151 & this.content;
                    }
                    setFromCharData(e) {
                        this.fg = e[r.CHAR_DATA_ATTR_INDEX], this.bg = 0;
                        let t = !1;
                        if (e[r.CHAR_DATA_CHAR_INDEX].length > 2) t = !0;
                        else if (2 === e[r.CHAR_DATA_CHAR_INDEX].length) {
                            const i = e[r.CHAR_DATA_CHAR_INDEX].charCodeAt(0);
                            if (55296 <= i && i <= 56319) {
                                const s = e[r.CHAR_DATA_CHAR_INDEX].charCodeAt(1);
                                56320 <= s && s <= 57343 ? this.content = 1024 * (i - 55296) + s - 56320 + 65536 | e[r.CHAR_DATA_WIDTH_INDEX] << 22 : t = !0;
                            } else t = !0;
                        } else this.content = e[r.CHAR_DATA_CHAR_INDEX].charCodeAt(0) | e[r.CHAR_DATA_WIDTH_INDEX] << 22;
                        t && (this.combinedData = e[r.CHAR_DATA_CHAR_INDEX], this.content = 2097152 | e[r.CHAR_DATA_WIDTH_INDEX] << 22);
                    }
                    getAsCharData() {
                        return [
                            this.fg,
                            this.getChars(),
                            this.getWidth(),
                            this.getCode()
                        ];
                    }
                }
                t.CellData = o;
            },
            643: (e, t)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.WHITESPACE_CELL_CODE = t.WHITESPACE_CELL_WIDTH = t.WHITESPACE_CELL_CHAR = t.NULL_CELL_CODE = t.NULL_CELL_WIDTH = t.NULL_CELL_CHAR = t.CHAR_DATA_CODE_INDEX = t.CHAR_DATA_WIDTH_INDEX = t.CHAR_DATA_CHAR_INDEX = t.CHAR_DATA_ATTR_INDEX = t.DEFAULT_EXT = t.DEFAULT_ATTR = t.DEFAULT_COLOR = void 0, t.DEFAULT_COLOR = 0, t.DEFAULT_ATTR = 256 | t.DEFAULT_COLOR << 9, t.DEFAULT_EXT = 0, t.CHAR_DATA_ATTR_INDEX = 0, t.CHAR_DATA_CHAR_INDEX = 1, t.CHAR_DATA_WIDTH_INDEX = 2, t.CHAR_DATA_CODE_INDEX = 3, t.NULL_CELL_CHAR = "", t.NULL_CELL_WIDTH = 1, t.NULL_CELL_CODE = 0, t.WHITESPACE_CELL_CHAR = " ", t.WHITESPACE_CELL_WIDTH = 1, t.WHITESPACE_CELL_CODE = 32;
            },
            4863: (e, t, i)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.Marker = void 0;
                const s = i(8460), r = i(844);
                class n {
                    constructor(e){
                        this.line = e, this.isDisposed = !1, this._disposables = [], this._id = n._nextId++, this._onDispose = this.register(new s.EventEmitter), this.onDispose = this._onDispose.event;
                    }
                    get id() {
                        return this._id;
                    }
                    dispose() {
                        this.isDisposed || (this.isDisposed = !0, this.line = -1, this._onDispose.fire(), (0, r.disposeArray)(this._disposables), this._disposables.length = 0);
                    }
                    register(e) {
                        return this._disposables.push(e), e;
                    }
                }
                t.Marker = n, n._nextId = 1;
            },
            7116: (e, t)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.DEFAULT_CHARSET = t.CHARSETS = void 0, t.CHARSETS = {}, t.DEFAULT_CHARSET = t.CHARSETS.B, t.CHARSETS[0] = {
                    "`": "◆",
                    a: "▒",
                    b: "␉",
                    c: "␌",
                    d: "␍",
                    e: "␊",
                    f: "\xb0",
                    g: "\xb1",
                    h: "␤",
                    i: "␋",
                    j: "┘",
                    k: "┐",
                    l: "┌",
                    m: "└",
                    n: "┼",
                    o: "⎺",
                    p: "⎻",
                    q: "─",
                    r: "⎼",
                    s: "⎽",
                    t: "├",
                    u: "┤",
                    v: "┴",
                    w: "┬",
                    x: "│",
                    y: "≤",
                    z: "≥",
                    "{": "π",
                    "|": "≠",
                    "}": "\xa3",
                    "~": "\xb7"
                }, t.CHARSETS.A = {
                    "#": "\xa3"
                }, t.CHARSETS.B = void 0, t.CHARSETS[4] = {
                    "#": "\xa3",
                    "@": "\xbe",
                    "[": "ij",
                    "\\": "\xbd",
                    "]": "|",
                    "{": "\xa8",
                    "|": "f",
                    "}": "\xbc",
                    "~": "\xb4"
                }, t.CHARSETS.C = t.CHARSETS[5] = {
                    "[": "\xc4",
                    "\\": "\xd6",
                    "]": "\xc5",
                    "^": "\xdc",
                    "`": "\xe9",
                    "{": "\xe4",
                    "|": "\xf6",
                    "}": "\xe5",
                    "~": "\xfc"
                }, t.CHARSETS.R = {
                    "#": "\xa3",
                    "@": "\xe0",
                    "[": "\xb0",
                    "\\": "\xe7",
                    "]": "\xa7",
                    "{": "\xe9",
                    "|": "\xf9",
                    "}": "\xe8",
                    "~": "\xa8"
                }, t.CHARSETS.Q = {
                    "@": "\xe0",
                    "[": "\xe2",
                    "\\": "\xe7",
                    "]": "\xea",
                    "^": "\xee",
                    "`": "\xf4",
                    "{": "\xe9",
                    "|": "\xf9",
                    "}": "\xe8",
                    "~": "\xfb"
                }, t.CHARSETS.K = {
                    "@": "\xa7",
                    "[": "\xc4",
                    "\\": "\xd6",
                    "]": "\xdc",
                    "{": "\xe4",
                    "|": "\xf6",
                    "}": "\xfc",
                    "~": "\xdf"
                }, t.CHARSETS.Y = {
                    "#": "\xa3",
                    "@": "\xa7",
                    "[": "\xb0",
                    "\\": "\xe7",
                    "]": "\xe9",
                    "`": "\xf9",
                    "{": "\xe0",
                    "|": "\xf2",
                    "}": "\xe8",
                    "~": "\xec"
                }, t.CHARSETS.E = t.CHARSETS[6] = {
                    "@": "\xc4",
                    "[": "\xc6",
                    "\\": "\xd8",
                    "]": "\xc5",
                    "^": "\xdc",
                    "`": "\xe4",
                    "{": "\xe6",
                    "|": "\xf8",
                    "}": "\xe5",
                    "~": "\xfc"
                }, t.CHARSETS.Z = {
                    "#": "\xa3",
                    "@": "\xa7",
                    "[": "\xa1",
                    "\\": "\xd1",
                    "]": "\xbf",
                    "{": "\xb0",
                    "|": "\xf1",
                    "}": "\xe7"
                }, t.CHARSETS.H = t.CHARSETS[7] = {
                    "@": "\xc9",
                    "[": "\xc4",
                    "\\": "\xd6",
                    "]": "\xc5",
                    "^": "\xdc",
                    "`": "\xe9",
                    "{": "\xe4",
                    "|": "\xf6",
                    "}": "\xe5",
                    "~": "\xfc"
                }, t.CHARSETS["="] = {
                    "#": "\xf9",
                    "@": "\xe0",
                    "[": "\xe9",
                    "\\": "\xe7",
                    "]": "\xea",
                    "^": "\xee",
                    _: "\xe8",
                    "`": "\xf4",
                    "{": "\xe4",
                    "|": "\xf6",
                    "}": "\xfc",
                    "~": "\xfb"
                };
            },
            2584: (e, t)=>{
                var i, s;
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.C1_ESCAPED = t.C1 = t.C0 = void 0, function(e) {
                    e.NUL = "\x00", e.SOH = "\x01", e.STX = "\x02", e.ETX = "\x03", e.EOT = "\x04", e.ENQ = "\x05", e.ACK = "\x06", e.BEL = "\x07", e.BS = "\b", e.HT = "	", e.LF = "\n", e.VT = "\v", e.FF = "\f", e.CR = "\r", e.SO = "\x0e", e.SI = "\x0f", e.DLE = "\x10", e.DC1 = "\x11", e.DC2 = "\x12", e.DC3 = "\x13", e.DC4 = "\x14", e.NAK = "\x15", e.SYN = "\x16", e.ETB = "\x17", e.CAN = "\x18", e.EM = "\x19", e.SUB = "\x1a", e.ESC = "\x1b", e.FS = "\x1c", e.GS = "\x1d", e.RS = "\x1e", e.US = "\x1f", e.SP = " ", e.DEL = "\x7f";
                }(i = t.C0 || (t.C0 = {})), (s = t.C1 || (t.C1 = {})).PAD = "\x80", s.HOP = "\x81", s.BPH = "\x82", s.NBH = "\x83", s.IND = "\x84", s.NEL = "\x85", s.SSA = "\x86", s.ESA = "\x87", s.HTS = "\x88", s.HTJ = "\x89", s.VTS = "\x8a", s.PLD = "\x8b", s.PLU = "\x8c", s.RI = "\x8d", s.SS2 = "\x8e", s.SS3 = "\x8f", s.DCS = "\x90", s.PU1 = "\x91", s.PU2 = "\x92", s.STS = "\x93", s.CCH = "\x94", s.MW = "\x95", s.SPA = "\x96", s.EPA = "\x97", s.SOS = "\x98", s.SGCI = "\x99", s.SCI = "\x9a", s.CSI = "\x9b", s.ST = "\x9c", s.OSC = "\x9d", s.PM = "\x9e", s.APC = "\x9f", (t.C1_ESCAPED || (t.C1_ESCAPED = {})).ST = `${i.ESC}\\`;
            },
            7399: (e, t, i)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.evaluateKeyboardEvent = void 0;
                const s = i(2584), r = {
                    48: [
                        "0",
                        ")"
                    ],
                    49: [
                        "1",
                        "!"
                    ],
                    50: [
                        "2",
                        "@"
                    ],
                    51: [
                        "3",
                        "#"
                    ],
                    52: [
                        "4",
                        "$"
                    ],
                    53: [
                        "5",
                        "%"
                    ],
                    54: [
                        "6",
                        "^"
                    ],
                    55: [
                        "7",
                        "&"
                    ],
                    56: [
                        "8",
                        "*"
                    ],
                    57: [
                        "9",
                        "("
                    ],
                    186: [
                        ";",
                        ":"
                    ],
                    187: [
                        "=",
                        "+"
                    ],
                    188: [
                        ",",
                        "<"
                    ],
                    189: [
                        "-",
                        "_"
                    ],
                    190: [
                        ".",
                        ">"
                    ],
                    191: [
                        "/",
                        "?"
                    ],
                    192: [
                        "`",
                        "~"
                    ],
                    219: [
                        "[",
                        "{"
                    ],
                    220: [
                        "\\",
                        "|"
                    ],
                    221: [
                        "]",
                        "}"
                    ],
                    222: [
                        "'",
                        '"'
                    ]
                };
                t.evaluateKeyboardEvent = function(e, t, i, n) {
                    const o = {
                        type: 0,
                        cancel: !1,
                        key: void 0
                    }, a = (e.shiftKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.ctrlKey ? 4 : 0) | (e.metaKey ? 8 : 0);
                    switch(e.keyCode){
                        case 0:
                            "UIKeyInputUpArrow" === e.key ? o.key = t ? s.C0.ESC + "OA" : s.C0.ESC + "[A" : "UIKeyInputLeftArrow" === e.key ? o.key = t ? s.C0.ESC + "OD" : s.C0.ESC + "[D" : "UIKeyInputRightArrow" === e.key ? o.key = t ? s.C0.ESC + "OC" : s.C0.ESC + "[C" : "UIKeyInputDownArrow" === e.key && (o.key = t ? s.C0.ESC + "OB" : s.C0.ESC + "[B");
                            break;
                        case 8:
                            if (e.altKey) {
                                o.key = s.C0.ESC + s.C0.DEL;
                                break;
                            }
                            o.key = s.C0.DEL;
                            break;
                        case 9:
                            if (e.shiftKey) {
                                o.key = s.C0.ESC + "[Z";
                                break;
                            }
                            o.key = s.C0.HT, o.cancel = !0;
                            break;
                        case 13:
                            o.key = e.altKey ? s.C0.ESC + s.C0.CR : s.C0.CR, o.cancel = !0;
                            break;
                        case 27:
                            o.key = s.C0.ESC, e.altKey && (o.key = s.C0.ESC + s.C0.ESC), o.cancel = !0;
                            break;
                        case 37:
                            if (e.metaKey) break;
                            a ? (o.key = s.C0.ESC + "[1;" + (a + 1) + "D", o.key === s.C0.ESC + "[1;3D" && (o.key = s.C0.ESC + (i ? "b" : "[1;5D"))) : o.key = t ? s.C0.ESC + "OD" : s.C0.ESC + "[D";
                            break;
                        case 39:
                            if (e.metaKey) break;
                            a ? (o.key = s.C0.ESC + "[1;" + (a + 1) + "C", o.key === s.C0.ESC + "[1;3C" && (o.key = s.C0.ESC + (i ? "f" : "[1;5C"))) : o.key = t ? s.C0.ESC + "OC" : s.C0.ESC + "[C";
                            break;
                        case 38:
                            if (e.metaKey) break;
                            a ? (o.key = s.C0.ESC + "[1;" + (a + 1) + "A", i || o.key !== s.C0.ESC + "[1;3A" || (o.key = s.C0.ESC + "[1;5A")) : o.key = t ? s.C0.ESC + "OA" : s.C0.ESC + "[A";
                            break;
                        case 40:
                            if (e.metaKey) break;
                            a ? (o.key = s.C0.ESC + "[1;" + (a + 1) + "B", i || o.key !== s.C0.ESC + "[1;3B" || (o.key = s.C0.ESC + "[1;5B")) : o.key = t ? s.C0.ESC + "OB" : s.C0.ESC + "[B";
                            break;
                        case 45:
                            e.shiftKey || e.ctrlKey || (o.key = s.C0.ESC + "[2~");
                            break;
                        case 46:
                            o.key = a ? s.C0.ESC + "[3;" + (a + 1) + "~" : s.C0.ESC + "[3~";
                            break;
                        case 36:
                            o.key = a ? s.C0.ESC + "[1;" + (a + 1) + "H" : t ? s.C0.ESC + "OH" : s.C0.ESC + "[H";
                            break;
                        case 35:
                            o.key = a ? s.C0.ESC + "[1;" + (a + 1) + "F" : t ? s.C0.ESC + "OF" : s.C0.ESC + "[F";
                            break;
                        case 33:
                            e.shiftKey ? o.type = 2 : e.ctrlKey ? o.key = s.C0.ESC + "[5;" + (a + 1) + "~" : o.key = s.C0.ESC + "[5~";
                            break;
                        case 34:
                            e.shiftKey ? o.type = 3 : e.ctrlKey ? o.key = s.C0.ESC + "[6;" + (a + 1) + "~" : o.key = s.C0.ESC + "[6~";
                            break;
                        case 112:
                            o.key = a ? s.C0.ESC + "[1;" + (a + 1) + "P" : s.C0.ESC + "OP";
                            break;
                        case 113:
                            o.key = a ? s.C0.ESC + "[1;" + (a + 1) + "Q" : s.C0.ESC + "OQ";
                            break;
                        case 114:
                            o.key = a ? s.C0.ESC + "[1;" + (a + 1) + "R" : s.C0.ESC + "OR";
                            break;
                        case 115:
                            o.key = a ? s.C0.ESC + "[1;" + (a + 1) + "S" : s.C0.ESC + "OS";
                            break;
                        case 116:
                            o.key = a ? s.C0.ESC + "[15;" + (a + 1) + "~" : s.C0.ESC + "[15~";
                            break;
                        case 117:
                            o.key = a ? s.C0.ESC + "[17;" + (a + 1) + "~" : s.C0.ESC + "[17~";
                            break;
                        case 118:
                            o.key = a ? s.C0.ESC + "[18;" + (a + 1) + "~" : s.C0.ESC + "[18~";
                            break;
                        case 119:
                            o.key = a ? s.C0.ESC + "[19;" + (a + 1) + "~" : s.C0.ESC + "[19~";
                            break;
                        case 120:
                            o.key = a ? s.C0.ESC + "[20;" + (a + 1) + "~" : s.C0.ESC + "[20~";
                            break;
                        case 121:
                            o.key = a ? s.C0.ESC + "[21;" + (a + 1) + "~" : s.C0.ESC + "[21~";
                            break;
                        case 122:
                            o.key = a ? s.C0.ESC + "[23;" + (a + 1) + "~" : s.C0.ESC + "[23~";
                            break;
                        case 123:
                            o.key = a ? s.C0.ESC + "[24;" + (a + 1) + "~" : s.C0.ESC + "[24~";
                            break;
                        default:
                            if (!e.ctrlKey || e.shiftKey || e.altKey || e.metaKey) {
                                if (i && !n || !e.altKey || e.metaKey) !i || e.altKey || e.ctrlKey || e.shiftKey || !e.metaKey ? e.key && !e.ctrlKey && !e.altKey && !e.metaKey && e.keyCode >= 48 && 1 === e.key.length ? o.key = e.key : e.key && e.ctrlKey && ("_" === e.key && (o.key = s.C0.US), "@" === e.key && (o.key = s.C0.NUL)) : 65 === e.keyCode && (o.type = 1);
                                else {
                                    const t = r[e.keyCode], i = null == t ? void 0 : t[e.shiftKey ? 1 : 0];
                                    if (i) o.key = s.C0.ESC + i;
                                    else if (e.keyCode >= 65 && e.keyCode <= 90) {
                                        const t = e.ctrlKey ? e.keyCode - 64 : e.keyCode + 32;
                                        let i = String.fromCharCode(t);
                                        e.shiftKey && (i = i.toUpperCase()), o.key = s.C0.ESC + i;
                                    } else if (32 === e.keyCode) o.key = s.C0.ESC + (e.ctrlKey ? s.C0.NUL : " ");
                                    else if ("Dead" === e.key && e.code.startsWith("Key")) {
                                        let t = e.code.slice(3, 4);
                                        e.shiftKey || (t = t.toLowerCase()), o.key = s.C0.ESC + t, o.cancel = !0;
                                    }
                                }
                            } else e.keyCode >= 65 && e.keyCode <= 90 ? o.key = String.fromCharCode(e.keyCode - 64) : 32 === e.keyCode ? o.key = s.C0.NUL : e.keyCode >= 51 && e.keyCode <= 55 ? o.key = String.fromCharCode(e.keyCode - 51 + 27) : 56 === e.keyCode ? o.key = s.C0.DEL : 219 === e.keyCode ? o.key = s.C0.ESC : 220 === e.keyCode ? o.key = s.C0.FS : 221 === e.keyCode && (o.key = s.C0.GS);
                    }
                    return o;
                };
            },
            482: (e, t)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.Utf8ToUtf32 = t.StringToUtf32 = t.utf32ToString = t.stringFromCodePoint = void 0, t.stringFromCodePoint = function(e) {
                    return e > 65535 ? (e -= 65536, String.fromCharCode(55296 + (e >> 10)) + String.fromCharCode(e % 1024 + 56320)) : String.fromCharCode(e);
                }, t.utf32ToString = function(e, t = 0, i = e.length) {
                    let s = "";
                    for(let r = t; r < i; ++r){
                        let t = e[r];
                        t > 65535 ? (t -= 65536, s += String.fromCharCode(55296 + (t >> 10)) + String.fromCharCode(t % 1024 + 56320)) : s += String.fromCharCode(t);
                    }
                    return s;
                }, t.StringToUtf32 = class {
                    constructor(){
                        this._interim = 0;
                    }
                    clear() {
                        this._interim = 0;
                    }
                    decode(e, t) {
                        const i = e.length;
                        if (!i) return 0;
                        let s = 0, r = 0;
                        if (this._interim) {
                            const i = e.charCodeAt(r++);
                            56320 <= i && i <= 57343 ? t[s++] = 1024 * (this._interim - 55296) + i - 56320 + 65536 : (t[s++] = this._interim, t[s++] = i), this._interim = 0;
                        }
                        for(let n = r; n < i; ++n){
                            const r = e.charCodeAt(n);
                            if (55296 <= r && r <= 56319) {
                                if (++n >= i) return this._interim = r, s;
                                const o = e.charCodeAt(n);
                                56320 <= o && o <= 57343 ? t[s++] = 1024 * (r - 55296) + o - 56320 + 65536 : (t[s++] = r, t[s++] = o);
                            } else 65279 !== r && (t[s++] = r);
                        }
                        return s;
                    }
                }, t.Utf8ToUtf32 = class {
                    constructor(){
                        this.interim = new Uint8Array(3);
                    }
                    clear() {
                        this.interim.fill(0);
                    }
                    decode(e, t) {
                        const i = e.length;
                        if (!i) return 0;
                        let s, r, n, o, a = 0, h = 0, c = 0;
                        if (this.interim[0]) {
                            let s = !1, r = this.interim[0];
                            r &= 192 == (224 & r) ? 31 : 224 == (240 & r) ? 15 : 7;
                            let n, o = 0;
                            for(; (n = 63 & this.interim[++o]) && o < 4;)r <<= 6, r |= n;
                            const h = 192 == (224 & this.interim[0]) ? 2 : 224 == (240 & this.interim[0]) ? 3 : 4, l = h - o;
                            for(; c < l;){
                                if (c >= i) return 0;
                                if (n = e[c++], 128 != (192 & n)) {
                                    c--, s = !0;
                                    break;
                                }
                                this.interim[o++] = n, r <<= 6, r |= 63 & n;
                            }
                            s || (2 === h ? r < 128 ? c-- : t[a++] = r : 3 === h ? r < 2048 || r >= 55296 && r <= 57343 || 65279 === r || (t[a++] = r) : r < 65536 || r > 1114111 || (t[a++] = r)), this.interim.fill(0);
                        }
                        const l = i - 4;
                        let d = c;
                        for(; d < i;){
                            for(; !(!(d < l) || 128 & (s = e[d]) || 128 & (r = e[d + 1]) || 128 & (n = e[d + 2]) || 128 & (o = e[d + 3]));)t[a++] = s, t[a++] = r, t[a++] = n, t[a++] = o, d += 4;
                            if (s = e[d++], s < 128) t[a++] = s;
                            else if (192 == (224 & s)) {
                                if (d >= i) return this.interim[0] = s, a;
                                if (r = e[d++], 128 != (192 & r)) {
                                    d--;
                                    continue;
                                }
                                if (h = (31 & s) << 6 | 63 & r, h < 128) {
                                    d--;
                                    continue;
                                }
                                t[a++] = h;
                            } else if (224 == (240 & s)) {
                                if (d >= i) return this.interim[0] = s, a;
                                if (r = e[d++], 128 != (192 & r)) {
                                    d--;
                                    continue;
                                }
                                if (d >= i) return this.interim[0] = s, this.interim[1] = r, a;
                                if (n = e[d++], 128 != (192 & n)) {
                                    d--;
                                    continue;
                                }
                                if (h = (15 & s) << 12 | (63 & r) << 6 | 63 & n, h < 2048 || h >= 55296 && h <= 57343 || 65279 === h) continue;
                                t[a++] = h;
                            } else if (240 == (248 & s)) {
                                if (d >= i) return this.interim[0] = s, a;
                                if (r = e[d++], 128 != (192 & r)) {
                                    d--;
                                    continue;
                                }
                                if (d >= i) return this.interim[0] = s, this.interim[1] = r, a;
                                if (n = e[d++], 128 != (192 & n)) {
                                    d--;
                                    continue;
                                }
                                if (d >= i) return this.interim[0] = s, this.interim[1] = r, this.interim[2] = n, a;
                                if (o = e[d++], 128 != (192 & o)) {
                                    d--;
                                    continue;
                                }
                                if (h = (7 & s) << 18 | (63 & r) << 12 | (63 & n) << 6 | 63 & o, h < 65536 || h > 1114111) continue;
                                t[a++] = h;
                            }
                        }
                        return a;
                    }
                };
            },
            225: (e, t)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.UnicodeV6 = void 0;
                const i = [
                    [
                        768,
                        879
                    ],
                    [
                        1155,
                        1158
                    ],
                    [
                        1160,
                        1161
                    ],
                    [
                        1425,
                        1469
                    ],
                    [
                        1471,
                        1471
                    ],
                    [
                        1473,
                        1474
                    ],
                    [
                        1476,
                        1477
                    ],
                    [
                        1479,
                        1479
                    ],
                    [
                        1536,
                        1539
                    ],
                    [
                        1552,
                        1557
                    ],
                    [
                        1611,
                        1630
                    ],
                    [
                        1648,
                        1648
                    ],
                    [
                        1750,
                        1764
                    ],
                    [
                        1767,
                        1768
                    ],
                    [
                        1770,
                        1773
                    ],
                    [
                        1807,
                        1807
                    ],
                    [
                        1809,
                        1809
                    ],
                    [
                        1840,
                        1866
                    ],
                    [
                        1958,
                        1968
                    ],
                    [
                        2027,
                        2035
                    ],
                    [
                        2305,
                        2306
                    ],
                    [
                        2364,
                        2364
                    ],
                    [
                        2369,
                        2376
                    ],
                    [
                        2381,
                        2381
                    ],
                    [
                        2385,
                        2388
                    ],
                    [
                        2402,
                        2403
                    ],
                    [
                        2433,
                        2433
                    ],
                    [
                        2492,
                        2492
                    ],
                    [
                        2497,
                        2500
                    ],
                    [
                        2509,
                        2509
                    ],
                    [
                        2530,
                        2531
                    ],
                    [
                        2561,
                        2562
                    ],
                    [
                        2620,
                        2620
                    ],
                    [
                        2625,
                        2626
                    ],
                    [
                        2631,
                        2632
                    ],
                    [
                        2635,
                        2637
                    ],
                    [
                        2672,
                        2673
                    ],
                    [
                        2689,
                        2690
                    ],
                    [
                        2748,
                        2748
                    ],
                    [
                        2753,
                        2757
                    ],
                    [
                        2759,
                        2760
                    ],
                    [
                        2765,
                        2765
                    ],
                    [
                        2786,
                        2787
                    ],
                    [
                        2817,
                        2817
                    ],
                    [
                        2876,
                        2876
                    ],
                    [
                        2879,
                        2879
                    ],
                    [
                        2881,
                        2883
                    ],
                    [
                        2893,
                        2893
                    ],
                    [
                        2902,
                        2902
                    ],
                    [
                        2946,
                        2946
                    ],
                    [
                        3008,
                        3008
                    ],
                    [
                        3021,
                        3021
                    ],
                    [
                        3134,
                        3136
                    ],
                    [
                        3142,
                        3144
                    ],
                    [
                        3146,
                        3149
                    ],
                    [
                        3157,
                        3158
                    ],
                    [
                        3260,
                        3260
                    ],
                    [
                        3263,
                        3263
                    ],
                    [
                        3270,
                        3270
                    ],
                    [
                        3276,
                        3277
                    ],
                    [
                        3298,
                        3299
                    ],
                    [
                        3393,
                        3395
                    ],
                    [
                        3405,
                        3405
                    ],
                    [
                        3530,
                        3530
                    ],
                    [
                        3538,
                        3540
                    ],
                    [
                        3542,
                        3542
                    ],
                    [
                        3633,
                        3633
                    ],
                    [
                        3636,
                        3642
                    ],
                    [
                        3655,
                        3662
                    ],
                    [
                        3761,
                        3761
                    ],
                    [
                        3764,
                        3769
                    ],
                    [
                        3771,
                        3772
                    ],
                    [
                        3784,
                        3789
                    ],
                    [
                        3864,
                        3865
                    ],
                    [
                        3893,
                        3893
                    ],
                    [
                        3895,
                        3895
                    ],
                    [
                        3897,
                        3897
                    ],
                    [
                        3953,
                        3966
                    ],
                    [
                        3968,
                        3972
                    ],
                    [
                        3974,
                        3975
                    ],
                    [
                        3984,
                        3991
                    ],
                    [
                        3993,
                        4028
                    ],
                    [
                        4038,
                        4038
                    ],
                    [
                        4141,
                        4144
                    ],
                    [
                        4146,
                        4146
                    ],
                    [
                        4150,
                        4151
                    ],
                    [
                        4153,
                        4153
                    ],
                    [
                        4184,
                        4185
                    ],
                    [
                        4448,
                        4607
                    ],
                    [
                        4959,
                        4959
                    ],
                    [
                        5906,
                        5908
                    ],
                    [
                        5938,
                        5940
                    ],
                    [
                        5970,
                        5971
                    ],
                    [
                        6002,
                        6003
                    ],
                    [
                        6068,
                        6069
                    ],
                    [
                        6071,
                        6077
                    ],
                    [
                        6086,
                        6086
                    ],
                    [
                        6089,
                        6099
                    ],
                    [
                        6109,
                        6109
                    ],
                    [
                        6155,
                        6157
                    ],
                    [
                        6313,
                        6313
                    ],
                    [
                        6432,
                        6434
                    ],
                    [
                        6439,
                        6440
                    ],
                    [
                        6450,
                        6450
                    ],
                    [
                        6457,
                        6459
                    ],
                    [
                        6679,
                        6680
                    ],
                    [
                        6912,
                        6915
                    ],
                    [
                        6964,
                        6964
                    ],
                    [
                        6966,
                        6970
                    ],
                    [
                        6972,
                        6972
                    ],
                    [
                        6978,
                        6978
                    ],
                    [
                        7019,
                        7027
                    ],
                    [
                        7616,
                        7626
                    ],
                    [
                        7678,
                        7679
                    ],
                    [
                        8203,
                        8207
                    ],
                    [
                        8234,
                        8238
                    ],
                    [
                        8288,
                        8291
                    ],
                    [
                        8298,
                        8303
                    ],
                    [
                        8400,
                        8431
                    ],
                    [
                        12330,
                        12335
                    ],
                    [
                        12441,
                        12442
                    ],
                    [
                        43014,
                        43014
                    ],
                    [
                        43019,
                        43019
                    ],
                    [
                        43045,
                        43046
                    ],
                    [
                        64286,
                        64286
                    ],
                    [
                        65024,
                        65039
                    ],
                    [
                        65056,
                        65059
                    ],
                    [
                        65279,
                        65279
                    ],
                    [
                        65529,
                        65531
                    ]
                ], s = [
                    [
                        68097,
                        68099
                    ],
                    [
                        68101,
                        68102
                    ],
                    [
                        68108,
                        68111
                    ],
                    [
                        68152,
                        68154
                    ],
                    [
                        68159,
                        68159
                    ],
                    [
                        119143,
                        119145
                    ],
                    [
                        119155,
                        119170
                    ],
                    [
                        119173,
                        119179
                    ],
                    [
                        119210,
                        119213
                    ],
                    [
                        119362,
                        119364
                    ],
                    [
                        917505,
                        917505
                    ],
                    [
                        917536,
                        917631
                    ],
                    [
                        917760,
                        917999
                    ]
                ];
                let r;
                t.UnicodeV6 = class {
                    constructor(){
                        if (this.version = "6", !r) {
                            r = new Uint8Array(65536), r.fill(1), r[0] = 0, r.fill(0, 1, 32), r.fill(0, 127, 160), r.fill(2, 4352, 4448), r[9001] = 2, r[9002] = 2, r.fill(2, 11904, 42192), r[12351] = 1, r.fill(2, 44032, 55204), r.fill(2, 63744, 64256), r.fill(2, 65040, 65050), r.fill(2, 65072, 65136), r.fill(2, 65280, 65377), r.fill(2, 65504, 65511);
                            for(let e = 0; e < i.length; ++e)r.fill(0, i[e][0], i[e][1] + 1);
                        }
                    }
                    wcwidth(e) {
                        return e < 32 ? 0 : e < 127 ? 1 : e < 65536 ? r[e] : function(e, t) {
                            let i, s = 0, r = t.length - 1;
                            if (e < t[0][0] || e > t[r][1]) return !1;
                            for(; r >= s;)if (i = s + r >> 1, e > t[i][1]) s = i + 1;
                            else {
                                if (!(e < t[i][0])) return !0;
                                r = i - 1;
                            }
                            return !1;
                        }(e, s) ? 0 : e >= 131072 && e <= 196605 || e >= 196608 && e <= 262141 ? 2 : 1;
                    }
                };
            },
            5981: (e, t, i)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.WriteBuffer = void 0;
                const s = i(8460), r = i(844);
                class n extends r.Disposable {
                    constructor(e){
                        super(), this._action = e, this._writeBuffer = [], this._callbacks = [], this._pendingData = 0, this._bufferOffset = 0, this._isSyncWriting = !1, this._syncCalls = 0, this._didUserInput = !1, this._onWriteParsed = this.register(new s.EventEmitter), this.onWriteParsed = this._onWriteParsed.event;
                    }
                    handleUserInput() {
                        this._didUserInput = !0;
                    }
                    writeSync(e, t) {
                        if (void 0 !== t && this._syncCalls > t) return void (this._syncCalls = 0);
                        if (this._pendingData += e.length, this._writeBuffer.push(e), this._callbacks.push(void 0), this._syncCalls++, this._isSyncWriting) return;
                        let i;
                        for(this._isSyncWriting = !0; i = this._writeBuffer.shift();){
                            this._action(i);
                            const e = this._callbacks.shift();
                            e && e();
                        }
                        this._pendingData = 0, this._bufferOffset = 2147483647, this._isSyncWriting = !1, this._syncCalls = 0;
                    }
                    write(e, t) {
                        if (this._pendingData > 5e7) throw new Error("write data discarded, use flow control to avoid losing data");
                        if (!this._writeBuffer.length) {
                            if (this._bufferOffset = 0, this._didUserInput) return this._didUserInput = !1, this._pendingData += e.length, this._writeBuffer.push(e), this._callbacks.push(t), void this._innerWrite();
                            setTimeout(()=>this._innerWrite());
                        }
                        this._pendingData += e.length, this._writeBuffer.push(e), this._callbacks.push(t);
                    }
                    _innerWrite(e = 0, t = !0) {
                        const i = e || Date.now();
                        for(; this._writeBuffer.length > this._bufferOffset;){
                            const e = this._writeBuffer[this._bufferOffset], s = this._action(e, t);
                            if (s) {
                                const e = (e)=>Date.now() - i >= 12 ? setTimeout(()=>this._innerWrite(0, e)) : this._innerWrite(i, e);
                                return void s.catch((e)=>(queueMicrotask(()=>{
                                        throw e;
                                    }), Promise.resolve(!1))).then(e);
                            }
                            const r = this._callbacks[this._bufferOffset];
                            if (r && r(), this._bufferOffset++, this._pendingData -= e.length, Date.now() - i >= 12) break;
                        }
                        this._writeBuffer.length > this._bufferOffset ? (this._bufferOffset > 50 && (this._writeBuffer = this._writeBuffer.slice(this._bufferOffset), this._callbacks = this._callbacks.slice(this._bufferOffset), this._bufferOffset = 0), setTimeout(()=>this._innerWrite())) : (this._writeBuffer.length = 0, this._callbacks.length = 0, this._pendingData = 0, this._bufferOffset = 0), this._onWriteParsed.fire();
                    }
                }
                t.WriteBuffer = n;
            },
            5941: (e, t)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.toRgbString = t.parseColor = void 0;
                const i = /^([\da-f])\/([\da-f])\/([\da-f])$|^([\da-f]{2})\/([\da-f]{2})\/([\da-f]{2})$|^([\da-f]{3})\/([\da-f]{3})\/([\da-f]{3})$|^([\da-f]{4})\/([\da-f]{4})\/([\da-f]{4})$/, s = /^[\da-f]+$/;
                function r(e, t) {
                    const i = e.toString(16), s = i.length < 2 ? "0" + i : i;
                    switch(t){
                        case 4:
                            return i[0];
                        case 8:
                            return s;
                        case 12:
                            return (s + s).slice(0, 3);
                        default:
                            return s + s;
                    }
                }
                t.parseColor = function(e) {
                    if (!e) return;
                    let t = e.toLowerCase();
                    if (0 === t.indexOf("rgb:")) {
                        t = t.slice(4);
                        const e = i.exec(t);
                        if (e) {
                            const t = e[1] ? 15 : e[4] ? 255 : e[7] ? 4095 : 65535;
                            return [
                                Math.round(parseInt(e[1] || e[4] || e[7] || e[10], 16) / t * 255),
                                Math.round(parseInt(e[2] || e[5] || e[8] || e[11], 16) / t * 255),
                                Math.round(parseInt(e[3] || e[6] || e[9] || e[12], 16) / t * 255)
                            ];
                        }
                    } else if (0 === t.indexOf("#") && (t = t.slice(1), s.exec(t) && [
                        3,
                        6,
                        9,
                        12
                    ].includes(t.length))) {
                        const e = t.length / 3, i = [
                            0,
                            0,
                            0
                        ];
                        for(let s = 0; s < 3; ++s){
                            const r = parseInt(t.slice(e * s, e * s + e), 16);
                            i[s] = 1 === e ? r << 4 : 2 === e ? r : 3 === e ? r >> 4 : r >> 8;
                        }
                        return i;
                    }
                }, t.toRgbString = function(e, t = 16) {
                    const [i, s, n] = e;
                    return `rgb:${r(i, t)}/${r(s, t)}/${r(n, t)}`;
                };
            },
            5770: (e, t)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.PAYLOAD_LIMIT = void 0, t.PAYLOAD_LIMIT = 1e7;
            },
            6351: (e, t, i)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.DcsHandler = t.DcsParser = void 0;
                const s = i(482), r = i(8742), n = i(5770), o = [];
                t.DcsParser = class {
                    constructor(){
                        this._handlers = Object.create(null), this._active = o, this._ident = 0, this._handlerFb = ()=>{}, this._stack = {
                            paused: !1,
                            loopPosition: 0,
                            fallThrough: !1
                        };
                    }
                    dispose() {
                        this._handlers = Object.create(null), this._handlerFb = ()=>{}, this._active = o;
                    }
                    registerHandler(e, t) {
                        void 0 === this._handlers[e] && (this._handlers[e] = []);
                        const i = this._handlers[e];
                        return i.push(t), {
                            dispose: ()=>{
                                const e = i.indexOf(t);
                                -1 !== e && i.splice(e, 1);
                            }
                        };
                    }
                    clearHandler(e) {
                        this._handlers[e] && delete this._handlers[e];
                    }
                    setHandlerFallback(e) {
                        this._handlerFb = e;
                    }
                    reset() {
                        if (this._active.length) for(let e = this._stack.paused ? this._stack.loopPosition - 1 : this._active.length - 1; e >= 0; --e)this._active[e].unhook(!1);
                        this._stack.paused = !1, this._active = o, this._ident = 0;
                    }
                    hook(e, t) {
                        if (this.reset(), this._ident = e, this._active = this._handlers[e] || o, this._active.length) for(let e = this._active.length - 1; e >= 0; e--)this._active[e].hook(t);
                        else this._handlerFb(this._ident, "HOOK", t);
                    }
                    put(e, t, i) {
                        if (this._active.length) for(let s = this._active.length - 1; s >= 0; s--)this._active[s].put(e, t, i);
                        else this._handlerFb(this._ident, "PUT", (0, s.utf32ToString)(e, t, i));
                    }
                    unhook(e, t = !0) {
                        if (this._active.length) {
                            let i = !1, s = this._active.length - 1, r = !1;
                            if (this._stack.paused && (s = this._stack.loopPosition - 1, i = t, r = this._stack.fallThrough, this._stack.paused = !1), !r && !1 === i) {
                                for(; s >= 0 && (i = this._active[s].unhook(e), !0 !== i); s--)if (i instanceof Promise) return this._stack.paused = !0, this._stack.loopPosition = s, this._stack.fallThrough = !1, i;
                                s--;
                            }
                            for(; s >= 0; s--)if (i = this._active[s].unhook(!1), i instanceof Promise) return this._stack.paused = !0, this._stack.loopPosition = s, this._stack.fallThrough = !0, i;
                        } else this._handlerFb(this._ident, "UNHOOK", e);
                        this._active = o, this._ident = 0;
                    }
                };
                const a = new r.Params;
                a.addParam(0), t.DcsHandler = class {
                    constructor(e){
                        this._handler = e, this._data = "", this._params = a, this._hitLimit = !1;
                    }
                    hook(e) {
                        this._params = e.length > 1 || e.params[0] ? e.clone() : a, this._data = "", this._hitLimit = !1;
                    }
                    put(e, t, i) {
                        this._hitLimit || (this._data += (0, s.utf32ToString)(e, t, i), this._data.length > n.PAYLOAD_LIMIT && (this._data = "", this._hitLimit = !0));
                    }
                    unhook(e) {
                        let t = !1;
                        if (this._hitLimit) t = !1;
                        else if (e && (t = this._handler(this._data, this._params), t instanceof Promise)) return t.then((e)=>(this._params = a, this._data = "", this._hitLimit = !1, e));
                        return this._params = a, this._data = "", this._hitLimit = !1, t;
                    }
                };
            },
            2015: (e, t, i)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.EscapeSequenceParser = t.VT500_TRANSITION_TABLE = t.TransitionTable = void 0;
                const s = i(844), r = i(8742), n = i(6242), o = i(6351);
                class a {
                    constructor(e){
                        this.table = new Uint8Array(e);
                    }
                    setDefault(e, t) {
                        this.table.fill(e << 4 | t);
                    }
                    add(e, t, i, s) {
                        this.table[t << 8 | e] = i << 4 | s;
                    }
                    addMany(e, t, i, s) {
                        for(let r = 0; r < e.length; r++)this.table[t << 8 | e[r]] = i << 4 | s;
                    }
                }
                t.TransitionTable = a;
                const h = 160;
                t.VT500_TRANSITION_TABLE = function() {
                    const e = new a(4095), t = Array.apply(null, Array(256)).map((e, t)=>t), i = (e, i)=>t.slice(e, i), s = i(32, 127), r = i(0, 24);
                    r.push(25), r.push.apply(r, i(28, 32));
                    const n = i(0, 14);
                    let o;
                    for(o in e.setDefault(1, 0), e.addMany(s, 0, 2, 0), n)e.addMany([
                        24,
                        26,
                        153,
                        154
                    ], o, 3, 0), e.addMany(i(128, 144), o, 3, 0), e.addMany(i(144, 152), o, 3, 0), e.add(156, o, 0, 0), e.add(27, o, 11, 1), e.add(157, o, 4, 8), e.addMany([
                        152,
                        158,
                        159
                    ], o, 0, 7), e.add(155, o, 11, 3), e.add(144, o, 11, 9);
                    return e.addMany(r, 0, 3, 0), e.addMany(r, 1, 3, 1), e.add(127, 1, 0, 1), e.addMany(r, 8, 0, 8), e.addMany(r, 3, 3, 3), e.add(127, 3, 0, 3), e.addMany(r, 4, 3, 4), e.add(127, 4, 0, 4), e.addMany(r, 6, 3, 6), e.addMany(r, 5, 3, 5), e.add(127, 5, 0, 5), e.addMany(r, 2, 3, 2), e.add(127, 2, 0, 2), e.add(93, 1, 4, 8), e.addMany(s, 8, 5, 8), e.add(127, 8, 5, 8), e.addMany([
                        156,
                        27,
                        24,
                        26,
                        7
                    ], 8, 6, 0), e.addMany(i(28, 32), 8, 0, 8), e.addMany([
                        88,
                        94,
                        95
                    ], 1, 0, 7), e.addMany(s, 7, 0, 7), e.addMany(r, 7, 0, 7), e.add(156, 7, 0, 0), e.add(127, 7, 0, 7), e.add(91, 1, 11, 3), e.addMany(i(64, 127), 3, 7, 0), e.addMany(i(48, 60), 3, 8, 4), e.addMany([
                        60,
                        61,
                        62,
                        63
                    ], 3, 9, 4), e.addMany(i(48, 60), 4, 8, 4), e.addMany(i(64, 127), 4, 7, 0), e.addMany([
                        60,
                        61,
                        62,
                        63
                    ], 4, 0, 6), e.addMany(i(32, 64), 6, 0, 6), e.add(127, 6, 0, 6), e.addMany(i(64, 127), 6, 0, 0), e.addMany(i(32, 48), 3, 9, 5), e.addMany(i(32, 48), 5, 9, 5), e.addMany(i(48, 64), 5, 0, 6), e.addMany(i(64, 127), 5, 7, 0), e.addMany(i(32, 48), 4, 9, 5), e.addMany(i(32, 48), 1, 9, 2), e.addMany(i(32, 48), 2, 9, 2), e.addMany(i(48, 127), 2, 10, 0), e.addMany(i(48, 80), 1, 10, 0), e.addMany(i(81, 88), 1, 10, 0), e.addMany([
                        89,
                        90,
                        92
                    ], 1, 10, 0), e.addMany(i(96, 127), 1, 10, 0), e.add(80, 1, 11, 9), e.addMany(r, 9, 0, 9), e.add(127, 9, 0, 9), e.addMany(i(28, 32), 9, 0, 9), e.addMany(i(32, 48), 9, 9, 12), e.addMany(i(48, 60), 9, 8, 10), e.addMany([
                        60,
                        61,
                        62,
                        63
                    ], 9, 9, 10), e.addMany(r, 11, 0, 11), e.addMany(i(32, 128), 11, 0, 11), e.addMany(i(28, 32), 11, 0, 11), e.addMany(r, 10, 0, 10), e.add(127, 10, 0, 10), e.addMany(i(28, 32), 10, 0, 10), e.addMany(i(48, 60), 10, 8, 10), e.addMany([
                        60,
                        61,
                        62,
                        63
                    ], 10, 0, 11), e.addMany(i(32, 48), 10, 9, 12), e.addMany(r, 12, 0, 12), e.add(127, 12, 0, 12), e.addMany(i(28, 32), 12, 0, 12), e.addMany(i(32, 48), 12, 9, 12), e.addMany(i(48, 64), 12, 0, 11), e.addMany(i(64, 127), 12, 12, 13), e.addMany(i(64, 127), 10, 12, 13), e.addMany(i(64, 127), 9, 12, 13), e.addMany(r, 13, 13, 13), e.addMany(s, 13, 13, 13), e.add(127, 13, 0, 13), e.addMany([
                        27,
                        156,
                        24,
                        26
                    ], 13, 14, 0), e.add(h, 0, 2, 0), e.add(h, 8, 5, 8), e.add(h, 6, 0, 6), e.add(h, 11, 0, 11), e.add(h, 13, 13, 13), e;
                }();
                class c extends s.Disposable {
                    constructor(e = t.VT500_TRANSITION_TABLE){
                        super(), this._transitions = e, this._parseStack = {
                            state: 0,
                            handlers: [],
                            handlerPos: 0,
                            transition: 0,
                            chunkPos: 0
                        }, this.initialState = 0, this.currentState = this.initialState, this._params = new r.Params, this._params.addParam(0), this._collect = 0, this.precedingCodepoint = 0, this._printHandlerFb = (e, t, i)=>{}, this._executeHandlerFb = (e)=>{}, this._csiHandlerFb = (e, t)=>{}, this._escHandlerFb = (e)=>{}, this._errorHandlerFb = (e)=>e, this._printHandler = this._printHandlerFb, this._executeHandlers = Object.create(null), this._csiHandlers = Object.create(null), this._escHandlers = Object.create(null), this.register((0, s.toDisposable)(()=>{
                            this._csiHandlers = Object.create(null), this._executeHandlers = Object.create(null), this._escHandlers = Object.create(null);
                        })), this._oscParser = this.register(new n.OscParser), this._dcsParser = this.register(new o.DcsParser), this._errorHandler = this._errorHandlerFb, this.registerEscHandler({
                            final: "\\"
                        }, ()=>!0);
                    }
                    _identifier(e, t = [
                        64,
                        126
                    ]) {
                        let i = 0;
                        if (e.prefix) {
                            if (e.prefix.length > 1) throw new Error("only one byte as prefix supported");
                            if (i = e.prefix.charCodeAt(0), i && 60 > i || i > 63) throw new Error("prefix must be in range 0x3c .. 0x3f");
                        }
                        if (e.intermediates) {
                            if (e.intermediates.length > 2) throw new Error("only two bytes as intermediates are supported");
                            for(let t = 0; t < e.intermediates.length; ++t){
                                const s = e.intermediates.charCodeAt(t);
                                if (32 > s || s > 47) throw new Error("intermediate must be in range 0x20 .. 0x2f");
                                i <<= 8, i |= s;
                            }
                        }
                        if (1 !== e.final.length) throw new Error("final must be a single byte");
                        const s = e.final.charCodeAt(0);
                        if (t[0] > s || s > t[1]) throw new Error(`final must be in range ${t[0]} .. ${t[1]}`);
                        return i <<= 8, i |= s, i;
                    }
                    identToString(e) {
                        const t = [];
                        for(; e;)t.push(String.fromCharCode(255 & e)), e >>= 8;
                        return t.reverse().join("");
                    }
                    setPrintHandler(e) {
                        this._printHandler = e;
                    }
                    clearPrintHandler() {
                        this._printHandler = this._printHandlerFb;
                    }
                    registerEscHandler(e, t) {
                        const i = this._identifier(e, [
                            48,
                            126
                        ]);
                        void 0 === this._escHandlers[i] && (this._escHandlers[i] = []);
                        const s = this._escHandlers[i];
                        return s.push(t), {
                            dispose: ()=>{
                                const e = s.indexOf(t);
                                -1 !== e && s.splice(e, 1);
                            }
                        };
                    }
                    clearEscHandler(e) {
                        this._escHandlers[this._identifier(e, [
                            48,
                            126
                        ])] && delete this._escHandlers[this._identifier(e, [
                            48,
                            126
                        ])];
                    }
                    setEscHandlerFallback(e) {
                        this._escHandlerFb = e;
                    }
                    setExecuteHandler(e, t) {
                        this._executeHandlers[e.charCodeAt(0)] = t;
                    }
                    clearExecuteHandler(e) {
                        this._executeHandlers[e.charCodeAt(0)] && delete this._executeHandlers[e.charCodeAt(0)];
                    }
                    setExecuteHandlerFallback(e) {
                        this._executeHandlerFb = e;
                    }
                    registerCsiHandler(e, t) {
                        const i = this._identifier(e);
                        void 0 === this._csiHandlers[i] && (this._csiHandlers[i] = []);
                        const s = this._csiHandlers[i];
                        return s.push(t), {
                            dispose: ()=>{
                                const e = s.indexOf(t);
                                -1 !== e && s.splice(e, 1);
                            }
                        };
                    }
                    clearCsiHandler(e) {
                        this._csiHandlers[this._identifier(e)] && delete this._csiHandlers[this._identifier(e)];
                    }
                    setCsiHandlerFallback(e) {
                        this._csiHandlerFb = e;
                    }
                    registerDcsHandler(e, t) {
                        return this._dcsParser.registerHandler(this._identifier(e), t);
                    }
                    clearDcsHandler(e) {
                        this._dcsParser.clearHandler(this._identifier(e));
                    }
                    setDcsHandlerFallback(e) {
                        this._dcsParser.setHandlerFallback(e);
                    }
                    registerOscHandler(e, t) {
                        return this._oscParser.registerHandler(e, t);
                    }
                    clearOscHandler(e) {
                        this._oscParser.clearHandler(e);
                    }
                    setOscHandlerFallback(e) {
                        this._oscParser.setHandlerFallback(e);
                    }
                    setErrorHandler(e) {
                        this._errorHandler = e;
                    }
                    clearErrorHandler() {
                        this._errorHandler = this._errorHandlerFb;
                    }
                    reset() {
                        this.currentState = this.initialState, this._oscParser.reset(), this._dcsParser.reset(), this._params.reset(), this._params.addParam(0), this._collect = 0, this.precedingCodepoint = 0, 0 !== this._parseStack.state && (this._parseStack.state = 2, this._parseStack.handlers = []);
                    }
                    _preserveStack(e, t, i, s, r) {
                        this._parseStack.state = e, this._parseStack.handlers = t, this._parseStack.handlerPos = i, this._parseStack.transition = s, this._parseStack.chunkPos = r;
                    }
                    parse(e, t, i) {
                        let s, r = 0, n = 0, o = 0;
                        if (this._parseStack.state) {
                            if (2 === this._parseStack.state) this._parseStack.state = 0, o = this._parseStack.chunkPos + 1;
                            else {
                                if (void 0 === i || 1 === this._parseStack.state) throw this._parseStack.state = 1, new Error("improper continuation due to previous async handler, giving up parsing");
                                const t = this._parseStack.handlers;
                                let n = this._parseStack.handlerPos - 1;
                                switch(this._parseStack.state){
                                    case 3:
                                        if (!1 === i && n > -1) {
                                            for(; n >= 0 && (s = t[n](this._params), !0 !== s); n--)if (s instanceof Promise) return this._parseStack.handlerPos = n, s;
                                        }
                                        this._parseStack.handlers = [];
                                        break;
                                    case 4:
                                        if (!1 === i && n > -1) {
                                            for(; n >= 0 && (s = t[n](), !0 !== s); n--)if (s instanceof Promise) return this._parseStack.handlerPos = n, s;
                                        }
                                        this._parseStack.handlers = [];
                                        break;
                                    case 6:
                                        if (r = e[this._parseStack.chunkPos], s = this._dcsParser.unhook(24 !== r && 26 !== r, i), s) return s;
                                        27 === r && (this._parseStack.transition |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0;
                                        break;
                                    case 5:
                                        if (r = e[this._parseStack.chunkPos], s = this._oscParser.end(24 !== r && 26 !== r, i), s) return s;
                                        27 === r && (this._parseStack.transition |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0;
                                }
                                this._parseStack.state = 0, o = this._parseStack.chunkPos + 1, this.precedingCodepoint = 0, this.currentState = 15 & this._parseStack.transition;
                            }
                        }
                        for(let i = o; i < t; ++i){
                            switch(r = e[i], n = this._transitions.table[this.currentState << 8 | (r < 160 ? r : h)], n >> 4){
                                case 2:
                                    for(let s = i + 1;; ++s){
                                        if (s >= t || (r = e[s]) < 32 || r > 126 && r < h) {
                                            this._printHandler(e, i, s), i = s - 1;
                                            break;
                                        }
                                        if (++s >= t || (r = e[s]) < 32 || r > 126 && r < h) {
                                            this._printHandler(e, i, s), i = s - 1;
                                            break;
                                        }
                                        if (++s >= t || (r = e[s]) < 32 || r > 126 && r < h) {
                                            this._printHandler(e, i, s), i = s - 1;
                                            break;
                                        }
                                        if (++s >= t || (r = e[s]) < 32 || r > 126 && r < h) {
                                            this._printHandler(e, i, s), i = s - 1;
                                            break;
                                        }
                                    }
                                    break;
                                case 3:
                                    this._executeHandlers[r] ? this._executeHandlers[r]() : this._executeHandlerFb(r), this.precedingCodepoint = 0;
                                    break;
                                case 0:
                                    break;
                                case 1:
                                    if (this._errorHandler({
                                        position: i,
                                        code: r,
                                        currentState: this.currentState,
                                        collect: this._collect,
                                        params: this._params,
                                        abort: !1
                                    }).abort) return;
                                    break;
                                case 7:
                                    const o = this._csiHandlers[this._collect << 8 | r];
                                    let a = o ? o.length - 1 : -1;
                                    for(; a >= 0 && (s = o[a](this._params), !0 !== s); a--)if (s instanceof Promise) return this._preserveStack(3, o, a, n, i), s;
                                    a < 0 && this._csiHandlerFb(this._collect << 8 | r, this._params), this.precedingCodepoint = 0;
                                    break;
                                case 8:
                                    do switch(r){
                                        case 59:
                                            this._params.addParam(0);
                                            break;
                                        case 58:
                                            this._params.addSubParam(-1);
                                            break;
                                        default:
                                            this._params.addDigit(r - 48);
                                    }
                                    while (++i < t && (r = e[i]) > 47 && r < 60);
                                    i--;
                                    break;
                                case 9:
                                    this._collect <<= 8, this._collect |= r;
                                    break;
                                case 10:
                                    const c = this._escHandlers[this._collect << 8 | r];
                                    let l = c ? c.length - 1 : -1;
                                    for(; l >= 0 && (s = c[l](), !0 !== s); l--)if (s instanceof Promise) return this._preserveStack(4, c, l, n, i), s;
                                    l < 0 && this._escHandlerFb(this._collect << 8 | r), this.precedingCodepoint = 0;
                                    break;
                                case 11:
                                    this._params.reset(), this._params.addParam(0), this._collect = 0;
                                    break;
                                case 12:
                                    this._dcsParser.hook(this._collect << 8 | r, this._params);
                                    break;
                                case 13:
                                    for(let s = i + 1;; ++s)if (s >= t || 24 === (r = e[s]) || 26 === r || 27 === r || r > 127 && r < h) {
                                        this._dcsParser.put(e, i, s), i = s - 1;
                                        break;
                                    }
                                    break;
                                case 14:
                                    if (s = this._dcsParser.unhook(24 !== r && 26 !== r), s) return this._preserveStack(6, [], 0, n, i), s;
                                    27 === r && (n |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0, this.precedingCodepoint = 0;
                                    break;
                                case 4:
                                    this._oscParser.start();
                                    break;
                                case 5:
                                    for(let s = i + 1;; s++)if (s >= t || (r = e[s]) < 32 || r > 127 && r < h) {
                                        this._oscParser.put(e, i, s), i = s - 1;
                                        break;
                                    }
                                    break;
                                case 6:
                                    if (s = this._oscParser.end(24 !== r && 26 !== r), s) return this._preserveStack(5, [], 0, n, i), s;
                                    27 === r && (n |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0, this.precedingCodepoint = 0;
                            }
                            this.currentState = 15 & n;
                        }
                    }
                }
                t.EscapeSequenceParser = c;
            },
            6242: (e, t, i)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.OscHandler = t.OscParser = void 0;
                const s = i(5770), r = i(482), n = [];
                t.OscParser = class {
                    constructor(){
                        this._state = 0, this._active = n, this._id = -1, this._handlers = Object.create(null), this._handlerFb = ()=>{}, this._stack = {
                            paused: !1,
                            loopPosition: 0,
                            fallThrough: !1
                        };
                    }
                    registerHandler(e, t) {
                        void 0 === this._handlers[e] && (this._handlers[e] = []);
                        const i = this._handlers[e];
                        return i.push(t), {
                            dispose: ()=>{
                                const e = i.indexOf(t);
                                -1 !== e && i.splice(e, 1);
                            }
                        };
                    }
                    clearHandler(e) {
                        this._handlers[e] && delete this._handlers[e];
                    }
                    setHandlerFallback(e) {
                        this._handlerFb = e;
                    }
                    dispose() {
                        this._handlers = Object.create(null), this._handlerFb = ()=>{}, this._active = n;
                    }
                    reset() {
                        if (2 === this._state) for(let e = this._stack.paused ? this._stack.loopPosition - 1 : this._active.length - 1; e >= 0; --e)this._active[e].end(!1);
                        this._stack.paused = !1, this._active = n, this._id = -1, this._state = 0;
                    }
                    _start() {
                        if (this._active = this._handlers[this._id] || n, this._active.length) for(let e = this._active.length - 1; e >= 0; e--)this._active[e].start();
                        else this._handlerFb(this._id, "START");
                    }
                    _put(e, t, i) {
                        if (this._active.length) for(let s = this._active.length - 1; s >= 0; s--)this._active[s].put(e, t, i);
                        else this._handlerFb(this._id, "PUT", (0, r.utf32ToString)(e, t, i));
                    }
                    start() {
                        this.reset(), this._state = 1;
                    }
                    put(e, t, i) {
                        if (3 !== this._state) {
                            if (1 === this._state) for(; t < i;){
                                const i = e[t++];
                                if (59 === i) {
                                    this._state = 2, this._start();
                                    break;
                                }
                                if (i < 48 || 57 < i) return void (this._state = 3);
                                -1 === this._id && (this._id = 0), this._id = 10 * this._id + i - 48;
                            }
                            2 === this._state && i - t > 0 && this._put(e, t, i);
                        }
                    }
                    end(e, t = !0) {
                        if (0 !== this._state) {
                            if (3 !== this._state) {
                                if (1 === this._state && this._start(), this._active.length) {
                                    let i = !1, s = this._active.length - 1, r = !1;
                                    if (this._stack.paused && (s = this._stack.loopPosition - 1, i = t, r = this._stack.fallThrough, this._stack.paused = !1), !r && !1 === i) {
                                        for(; s >= 0 && (i = this._active[s].end(e), !0 !== i); s--)if (i instanceof Promise) return this._stack.paused = !0, this._stack.loopPosition = s, this._stack.fallThrough = !1, i;
                                        s--;
                                    }
                                    for(; s >= 0; s--)if (i = this._active[s].end(!1), i instanceof Promise) return this._stack.paused = !0, this._stack.loopPosition = s, this._stack.fallThrough = !0, i;
                                } else this._handlerFb(this._id, "END", e);
                            }
                            this._active = n, this._id = -1, this._state = 0;
                        }
                    }
                }, t.OscHandler = class {
                    constructor(e){
                        this._handler = e, this._data = "", this._hitLimit = !1;
                    }
                    start() {
                        this._data = "", this._hitLimit = !1;
                    }
                    put(e, t, i) {
                        this._hitLimit || (this._data += (0, r.utf32ToString)(e, t, i), this._data.length > s.PAYLOAD_LIMIT && (this._data = "", this._hitLimit = !0));
                    }
                    end(e) {
                        let t = !1;
                        if (this._hitLimit) t = !1;
                        else if (e && (t = this._handler(this._data), t instanceof Promise)) return t.then((e)=>(this._data = "", this._hitLimit = !1, e));
                        return this._data = "", this._hitLimit = !1, t;
                    }
                };
            },
            8742: (e, t)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.Params = void 0;
                const i = 2147483647;
                class s {
                    constructor(e = 32, t = 32){
                        if (this.maxLength = e, this.maxSubParamsLength = t, t > 256) throw new Error("maxSubParamsLength must not be greater than 256");
                        this.params = new Int32Array(e), this.length = 0, this._subParams = new Int32Array(t), this._subParamsLength = 0, this._subParamsIdx = new Uint16Array(e), this._rejectDigits = !1, this._rejectSubDigits = !1, this._digitIsSub = !1;
                    }
                    static fromArray(e) {
                        const t = new s;
                        if (!e.length) return t;
                        for(let i = Array.isArray(e[0]) ? 1 : 0; i < e.length; ++i){
                            const s = e[i];
                            if (Array.isArray(s)) for(let e = 0; e < s.length; ++e)t.addSubParam(s[e]);
                            else t.addParam(s);
                        }
                        return t;
                    }
                    clone() {
                        const e = new s(this.maxLength, this.maxSubParamsLength);
                        return e.params.set(this.params), e.length = this.length, e._subParams.set(this._subParams), e._subParamsLength = this._subParamsLength, e._subParamsIdx.set(this._subParamsIdx), e._rejectDigits = this._rejectDigits, e._rejectSubDigits = this._rejectSubDigits, e._digitIsSub = this._digitIsSub, e;
                    }
                    toArray() {
                        const e = [];
                        for(let t = 0; t < this.length; ++t){
                            e.push(this.params[t]);
                            const i = this._subParamsIdx[t] >> 8, s = 255 & this._subParamsIdx[t];
                            s - i > 0 && e.push(Array.prototype.slice.call(this._subParams, i, s));
                        }
                        return e;
                    }
                    reset() {
                        this.length = 0, this._subParamsLength = 0, this._rejectDigits = !1, this._rejectSubDigits = !1, this._digitIsSub = !1;
                    }
                    addParam(e) {
                        if (this._digitIsSub = !1, this.length >= this.maxLength) this._rejectDigits = !0;
                        else {
                            if (e < -1) throw new Error("values lesser than -1 are not allowed");
                            this._subParamsIdx[this.length] = this._subParamsLength << 8 | this._subParamsLength, this.params[this.length++] = e > i ? i : e;
                        }
                    }
                    addSubParam(e) {
                        if (this._digitIsSub = !0, this.length) {
                            if (this._rejectDigits || this._subParamsLength >= this.maxSubParamsLength) this._rejectSubDigits = !0;
                            else {
                                if (e < -1) throw new Error("values lesser than -1 are not allowed");
                                this._subParams[this._subParamsLength++] = e > i ? i : e, this._subParamsIdx[this.length - 1]++;
                            }
                        }
                    }
                    hasSubParams(e) {
                        return (255 & this._subParamsIdx[e]) - (this._subParamsIdx[e] >> 8) > 0;
                    }
                    getSubParams(e) {
                        const t = this._subParamsIdx[e] >> 8, i = 255 & this._subParamsIdx[e];
                        return i - t > 0 ? this._subParams.subarray(t, i) : null;
                    }
                    getSubParamsAll() {
                        const e = {};
                        for(let t = 0; t < this.length; ++t){
                            const i = this._subParamsIdx[t] >> 8, s = 255 & this._subParamsIdx[t];
                            s - i > 0 && (e[t] = this._subParams.slice(i, s));
                        }
                        return e;
                    }
                    addDigit(e) {
                        let t;
                        if (this._rejectDigits || !(t = this._digitIsSub ? this._subParamsLength : this.length) || this._digitIsSub && this._rejectSubDigits) return;
                        const s = this._digitIsSub ? this._subParams : this.params, r = s[t - 1];
                        s[t - 1] = ~r ? Math.min(10 * r + e, i) : e;
                    }
                }
                t.Params = s;
            },
            5741: (e, t)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.AddonManager = void 0, t.AddonManager = class {
                    constructor(){
                        this._addons = [];
                    }
                    dispose() {
                        for(let e = this._addons.length - 1; e >= 0; e--)this._addons[e].instance.dispose();
                    }
                    loadAddon(e, t) {
                        const i = {
                            instance: t,
                            dispose: t.dispose,
                            isDisposed: !1
                        };
                        this._addons.push(i), t.dispose = ()=>this._wrappedAddonDispose(i), t.activate(e);
                    }
                    _wrappedAddonDispose(e) {
                        if (e.isDisposed) return;
                        let t = -1;
                        for(let i = 0; i < this._addons.length; i++)if (this._addons[i] === e) {
                            t = i;
                            break;
                        }
                        if (-1 === t) throw new Error("Could not dispose an addon that has not been loaded");
                        e.isDisposed = !0, e.dispose.apply(e.instance), this._addons.splice(t, 1);
                    }
                };
            },
            8771: (e, t, i)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.BufferApiView = void 0;
                const s = i(3785), r = i(511);
                t.BufferApiView = class {
                    constructor(e, t){
                        this._buffer = e, this.type = t;
                    }
                    init(e) {
                        return this._buffer = e, this;
                    }
                    get cursorY() {
                        return this._buffer.y;
                    }
                    get cursorX() {
                        return this._buffer.x;
                    }
                    get viewportY() {
                        return this._buffer.ydisp;
                    }
                    get baseY() {
                        return this._buffer.ybase;
                    }
                    get length() {
                        return this._buffer.lines.length;
                    }
                    getLine(e) {
                        const t = this._buffer.lines.get(e);
                        if (t) return new s.BufferLineApiView(t);
                    }
                    getNullCell() {
                        return new r.CellData;
                    }
                };
            },
            3785: (e, t, i)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.BufferLineApiView = void 0;
                const s = i(511);
                t.BufferLineApiView = class {
                    constructor(e){
                        this._line = e;
                    }
                    get isWrapped() {
                        return this._line.isWrapped;
                    }
                    get length() {
                        return this._line.length;
                    }
                    getCell(e, t) {
                        if (!(e < 0 || e >= this._line.length)) return t ? (this._line.loadCell(e, t), t) : this._line.loadCell(e, new s.CellData);
                    }
                    translateToString(e, t, i) {
                        return this._line.translateToString(e, t, i);
                    }
                };
            },
            8285: (e, t, i)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.BufferNamespaceApi = void 0;
                const s = i(8771), r = i(8460);
                t.BufferNamespaceApi = class {
                    constructor(e){
                        this._core = e, this._onBufferChange = new r.EventEmitter, this.onBufferChange = this._onBufferChange.event, this._normal = new s.BufferApiView(this._core.buffers.normal, "normal"), this._alternate = new s.BufferApiView(this._core.buffers.alt, "alternate"), this._core.buffers.onBufferActivate(()=>this._onBufferChange.fire(this.active));
                    }
                    get active() {
                        if (this._core.buffers.active === this._core.buffers.normal) return this.normal;
                        if (this._core.buffers.active === this._core.buffers.alt) return this.alternate;
                        throw new Error("Active buffer is neither normal nor alternate");
                    }
                    get normal() {
                        return this._normal.init(this._core.buffers.normal);
                    }
                    get alternate() {
                        return this._alternate.init(this._core.buffers.alt);
                    }
                };
            },
            7975: (e, t)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.ParserApi = void 0, t.ParserApi = class {
                    constructor(e){
                        this._core = e;
                    }
                    registerCsiHandler(e, t) {
                        return this._core.registerCsiHandler(e, (e)=>t(e.toArray()));
                    }
                    addCsiHandler(e, t) {
                        return this.registerCsiHandler(e, t);
                    }
                    registerDcsHandler(e, t) {
                        return this._core.registerDcsHandler(e, (e, i)=>t(e, i.toArray()));
                    }
                    addDcsHandler(e, t) {
                        return this.registerDcsHandler(e, t);
                    }
                    registerEscHandler(e, t) {
                        return this._core.registerEscHandler(e, t);
                    }
                    addEscHandler(e, t) {
                        return this.registerEscHandler(e, t);
                    }
                    registerOscHandler(e, t) {
                        return this._core.registerOscHandler(e, t);
                    }
                    addOscHandler(e, t) {
                        return this.registerOscHandler(e, t);
                    }
                };
            },
            7090: (e, t)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.UnicodeApi = void 0, t.UnicodeApi = class {
                    constructor(e){
                        this._core = e;
                    }
                    register(e) {
                        this._core.unicodeService.register(e);
                    }
                    get versions() {
                        return this._core.unicodeService.versions;
                    }
                    get activeVersion() {
                        return this._core.unicodeService.activeVersion;
                    }
                    set activeVersion(e) {
                        this._core.unicodeService.activeVersion = e;
                    }
                };
            },
            744: function(e, t, i) {
                var s = this && this.__decorate || function(e, t, i, s) {
                    var r, n = arguments.length, o = n < 3 ? t : null === s ? s = Object.getOwnPropertyDescriptor(t, i) : s;
                    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, i, s);
                    else for(var a = e.length - 1; a >= 0; a--)(r = e[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(t, i, o) : r(t, i)) || o);
                    return n > 3 && o && Object.defineProperty(t, i, o), o;
                }, r = this && this.__param || function(e, t) {
                    return function(i, s) {
                        t(i, s, e);
                    };
                };
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.BufferService = t.MINIMUM_ROWS = t.MINIMUM_COLS = void 0;
                const n = i(2585), o = i(5295), a = i(8460), h = i(844);
                t.MINIMUM_COLS = 2, t.MINIMUM_ROWS = 1;
                let c = class extends h.Disposable {
                    constructor(e){
                        super(), this.isUserScrolling = !1, this._onResize = this.register(new a.EventEmitter), this.onResize = this._onResize.event, this._onScroll = this.register(new a.EventEmitter), this.onScroll = this._onScroll.event, this.cols = Math.max(e.rawOptions.cols || 0, t.MINIMUM_COLS), this.rows = Math.max(e.rawOptions.rows || 0, t.MINIMUM_ROWS), this.buffers = this.register(new o.BufferSet(e, this));
                    }
                    get buffer() {
                        return this.buffers.active;
                    }
                    resize(e, t) {
                        this.cols = e, this.rows = t, this.buffers.resize(e, t), this._onResize.fire({
                            cols: e,
                            rows: t
                        });
                    }
                    reset() {
                        this.buffers.reset(), this.isUserScrolling = !1;
                    }
                    scroll(e, t = !1) {
                        const i = this.buffer;
                        let s;
                        s = this._cachedBlankLine, s && s.length === this.cols && s.getFg(0) === e.fg && s.getBg(0) === e.bg || (s = i.getBlankLine(e, t), this._cachedBlankLine = s), s.isWrapped = t;
                        const r = i.ybase + i.scrollTop, n = i.ybase + i.scrollBottom;
                        if (0 === i.scrollTop) {
                            const e = i.lines.isFull;
                            n === i.lines.length - 1 ? e ? i.lines.recycle().copyFrom(s) : i.lines.push(s.clone()) : i.lines.splice(n + 1, 0, s.clone()), e ? this.isUserScrolling && (i.ydisp = Math.max(i.ydisp - 1, 0)) : (i.ybase++, this.isUserScrolling || i.ydisp++);
                        } else {
                            const e = n - r + 1;
                            i.lines.shiftElements(r + 1, e - 1, -1), i.lines.set(n, s.clone());
                        }
                        this.isUserScrolling || (i.ydisp = i.ybase), this._onScroll.fire(i.ydisp);
                    }
                    scrollLines(e, t, i) {
                        const s = this.buffer;
                        if (e < 0) {
                            if (0 === s.ydisp) return;
                            this.isUserScrolling = !0;
                        } else e + s.ydisp >= s.ybase && (this.isUserScrolling = !1);
                        const r = s.ydisp;
                        s.ydisp = Math.max(Math.min(s.ydisp + e, s.ybase), 0), r !== s.ydisp && (t || this._onScroll.fire(s.ydisp));
                    }
                    scrollPages(e) {
                        this.scrollLines(e * (this.rows - 1));
                    }
                    scrollToTop() {
                        this.scrollLines(-this.buffer.ydisp);
                    }
                    scrollToBottom() {
                        this.scrollLines(this.buffer.ybase - this.buffer.ydisp);
                    }
                    scrollToLine(e) {
                        const t = e - this.buffer.ydisp;
                        0 !== t && this.scrollLines(t);
                    }
                };
                c = s([
                    r(0, n.IOptionsService)
                ], c), t.BufferService = c;
            },
            7994: (e, t)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.CharsetService = void 0, t.CharsetService = class {
                    constructor(){
                        this.glevel = 0, this._charsets = [];
                    }
                    reset() {
                        this.charset = void 0, this._charsets = [], this.glevel = 0;
                    }
                    setgLevel(e) {
                        this.glevel = e, this.charset = this._charsets[e];
                    }
                    setgCharset(e, t) {
                        this._charsets[e] = t, this.glevel === e && (this.charset = t);
                    }
                };
            },
            1753: function(e, t, i) {
                var s = this && this.__decorate || function(e, t, i, s) {
                    var r, n = arguments.length, o = n < 3 ? t : null === s ? s = Object.getOwnPropertyDescriptor(t, i) : s;
                    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, i, s);
                    else for(var a = e.length - 1; a >= 0; a--)(r = e[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(t, i, o) : r(t, i)) || o);
                    return n > 3 && o && Object.defineProperty(t, i, o), o;
                }, r = this && this.__param || function(e, t) {
                    return function(i, s) {
                        t(i, s, e);
                    };
                };
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.CoreMouseService = void 0;
                const n = i(2585), o = i(8460), a = i(844), h = {
                    NONE: {
                        events: 0,
                        restrict: ()=>!1
                    },
                    X10: {
                        events: 1,
                        restrict: (e)=>4 !== e.button && 1 === e.action && (e.ctrl = !1, e.alt = !1, e.shift = !1, !0)
                    },
                    VT200: {
                        events: 19,
                        restrict: (e)=>32 !== e.action
                    },
                    DRAG: {
                        events: 23,
                        restrict: (e)=>32 !== e.action || 3 !== e.button
                    },
                    ANY: {
                        events: 31,
                        restrict: (e)=>!0
                    }
                };
                function c(e, t) {
                    let i = (e.ctrl ? 16 : 0) | (e.shift ? 4 : 0) | (e.alt ? 8 : 0);
                    return 4 === e.button ? (i |= 64, i |= e.action) : (i |= 3 & e.button, 4 & e.button && (i |= 64), 8 & e.button && (i |= 128), 32 === e.action ? i |= 32 : 0 !== e.action || t || (i |= 3)), i;
                }
                const l = String.fromCharCode, d = {
                    DEFAULT: (e)=>{
                        const t = [
                            c(e, !1) + 32,
                            e.col + 32,
                            e.row + 32
                        ];
                        return t[0] > 255 || t[1] > 255 || t[2] > 255 ? "" : `[M${l(t[0])}${l(t[1])}${l(t[2])}`;
                    },
                    SGR: (e)=>{
                        const t = 0 === e.action && 4 !== e.button ? "m" : "M";
                        return `[<${c(e, !0)};${e.col};${e.row}${t}`;
                    },
                    SGR_PIXELS: (e)=>{
                        const t = 0 === e.action && 4 !== e.button ? "m" : "M";
                        return `[<${c(e, !0)};${e.x};${e.y}${t}`;
                    }
                };
                let _ = class extends a.Disposable {
                    constructor(e, t){
                        super(), this._bufferService = e, this._coreService = t, this._protocols = {}, this._encodings = {}, this._activeProtocol = "", this._activeEncoding = "", this._lastEvent = null, this._onProtocolChange = this.register(new o.EventEmitter), this.onProtocolChange = this._onProtocolChange.event;
                        for (const e of Object.keys(h))this.addProtocol(e, h[e]);
                        for (const e of Object.keys(d))this.addEncoding(e, d[e]);
                        this.reset();
                    }
                    addProtocol(e, t) {
                        this._protocols[e] = t;
                    }
                    addEncoding(e, t) {
                        this._encodings[e] = t;
                    }
                    get activeProtocol() {
                        return this._activeProtocol;
                    }
                    get areMouseEventsActive() {
                        return 0 !== this._protocols[this._activeProtocol].events;
                    }
                    set activeProtocol(e) {
                        if (!this._protocols[e]) throw new Error(`unknown protocol "${e}"`);
                        this._activeProtocol = e, this._onProtocolChange.fire(this._protocols[e].events);
                    }
                    get activeEncoding() {
                        return this._activeEncoding;
                    }
                    set activeEncoding(e) {
                        if (!this._encodings[e]) throw new Error(`unknown encoding "${e}"`);
                        this._activeEncoding = e;
                    }
                    reset() {
                        this.activeProtocol = "NONE", this.activeEncoding = "DEFAULT", this._lastEvent = null;
                    }
                    triggerMouseEvent(e) {
                        if (e.col < 0 || e.col >= this._bufferService.cols || e.row < 0 || e.row >= this._bufferService.rows) return !1;
                        if (4 === e.button && 32 === e.action) return !1;
                        if (3 === e.button && 32 !== e.action) return !1;
                        if (4 !== e.button && (2 === e.action || 3 === e.action)) return !1;
                        if (e.col++, e.row++, 32 === e.action && this._lastEvent && this._equalEvents(this._lastEvent, e, "SGR_PIXELS" === this._activeEncoding)) return !1;
                        if (!this._protocols[this._activeProtocol].restrict(e)) return !1;
                        const t = this._encodings[this._activeEncoding](e);
                        return t && ("DEFAULT" === this._activeEncoding ? this._coreService.triggerBinaryEvent(t) : this._coreService.triggerDataEvent(t, !0)), this._lastEvent = e, !0;
                    }
                    explainEvents(e) {
                        return {
                            down: !!(1 & e),
                            up: !!(2 & e),
                            drag: !!(4 & e),
                            move: !!(8 & e),
                            wheel: !!(16 & e)
                        };
                    }
                    _equalEvents(e, t, i) {
                        if (i) {
                            if (e.x !== t.x) return !1;
                            if (e.y !== t.y) return !1;
                        } else {
                            if (e.col !== t.col) return !1;
                            if (e.row !== t.row) return !1;
                        }
                        return e.button === t.button && e.action === t.action && e.ctrl === t.ctrl && e.alt === t.alt && e.shift === t.shift;
                    }
                };
                _ = s([
                    r(0, n.IBufferService),
                    r(1, n.ICoreService)
                ], _), t.CoreMouseService = _;
            },
            6975: function(e, t, i) {
                var s = this && this.__decorate || function(e, t, i, s) {
                    var r, n = arguments.length, o = n < 3 ? t : null === s ? s = Object.getOwnPropertyDescriptor(t, i) : s;
                    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, i, s);
                    else for(var a = e.length - 1; a >= 0; a--)(r = e[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(t, i, o) : r(t, i)) || o);
                    return n > 3 && o && Object.defineProperty(t, i, o), o;
                }, r = this && this.__param || function(e, t) {
                    return function(i, s) {
                        t(i, s, e);
                    };
                };
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.CoreService = void 0;
                const n = i(2585), o = i(8460), a = i(1439), h = i(844), c = Object.freeze({
                    insertMode: !1
                }), l = Object.freeze({
                    applicationCursorKeys: !1,
                    applicationKeypad: !1,
                    bracketedPasteMode: !1,
                    origin: !1,
                    reverseWraparound: !1,
                    sendFocus: !1,
                    wraparound: !0
                });
                let d = class extends h.Disposable {
                    constructor(e, t, i){
                        super(), this._bufferService = e, this._logService = t, this._optionsService = i, this.isCursorInitialized = !1, this.isCursorHidden = !1, this._onData = this.register(new o.EventEmitter), this.onData = this._onData.event, this._onUserInput = this.register(new o.EventEmitter), this.onUserInput = this._onUserInput.event, this._onBinary = this.register(new o.EventEmitter), this.onBinary = this._onBinary.event, this._onRequestScrollToBottom = this.register(new o.EventEmitter), this.onRequestScrollToBottom = this._onRequestScrollToBottom.event, this.modes = (0, a.clone)(c), this.decPrivateModes = (0, a.clone)(l);
                    }
                    reset() {
                        this.modes = (0, a.clone)(c), this.decPrivateModes = (0, a.clone)(l);
                    }
                    triggerDataEvent(e, t = !1) {
                        if (this._optionsService.rawOptions.disableStdin) return;
                        const i = this._bufferService.buffer;
                        t && this._optionsService.rawOptions.scrollOnUserInput && i.ybase !== i.ydisp && this._onRequestScrollToBottom.fire(), t && this._onUserInput.fire(), this._logService.debug(`sending data "${e}"`, ()=>e.split("").map((e)=>e.charCodeAt(0))), this._onData.fire(e);
                    }
                    triggerBinaryEvent(e) {
                        this._optionsService.rawOptions.disableStdin || (this._logService.debug(`sending binary "${e}"`, ()=>e.split("").map((e)=>e.charCodeAt(0))), this._onBinary.fire(e));
                    }
                };
                d = s([
                    r(0, n.IBufferService),
                    r(1, n.ILogService),
                    r(2, n.IOptionsService)
                ], d), t.CoreService = d;
            },
            9074: (e, t, i)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.DecorationService = void 0;
                const s = i(8055), r = i(8460), n = i(844), o = i(6106);
                let a = 0, h = 0;
                class c extends n.Disposable {
                    constructor(){
                        super(), this._decorations = new o.SortedList((e)=>null == e ? void 0 : e.marker.line), this._onDecorationRegistered = this.register(new r.EventEmitter), this.onDecorationRegistered = this._onDecorationRegistered.event, this._onDecorationRemoved = this.register(new r.EventEmitter), this.onDecorationRemoved = this._onDecorationRemoved.event, this.register((0, n.toDisposable)(()=>{
                            for (const e of this._decorations.values())this._onDecorationRemoved.fire(e);
                            this.reset();
                        }));
                    }
                    get decorations() {
                        return this._decorations.values();
                    }
                    registerDecoration(e) {
                        if (e.marker.isDisposed) return;
                        const t = new l(e);
                        if (t) {
                            const e = t.marker.onDispose(()=>t.dispose());
                            t.onDispose(()=>{
                                t && (this._decorations.delete(t) && this._onDecorationRemoved.fire(t), e.dispose());
                            }), this._decorations.insert(t), this._onDecorationRegistered.fire(t);
                        }
                        return t;
                    }
                    reset() {
                        for (const e of this._decorations.values())e.dispose();
                        this._decorations.clear();
                    }
                    *getDecorationsAtCell(e, t, i) {
                        var s, r, n;
                        let o = 0, a = 0;
                        for (const h of this._decorations.getKeyIterator(t))o = null !== (s = h.options.x) && void 0 !== s ? s : 0, a = o + (null !== (r = h.options.width) && void 0 !== r ? r : 1), e >= o && e < a && (!i || (null !== (n = h.options.layer) && void 0 !== n ? n : "bottom") === i) && (yield h);
                    }
                    forEachDecorationAtCell(e, t, i, s) {
                        this._decorations.forEachByKey(t, (t)=>{
                            var r, n, o;
                            a = null !== (r = t.options.x) && void 0 !== r ? r : 0, h = a + (null !== (n = t.options.width) && void 0 !== n ? n : 1), e >= a && e < h && (!i || (null !== (o = t.options.layer) && void 0 !== o ? o : "bottom") === i) && s(t);
                        });
                    }
                    dispose() {
                        for (const e of this._decorations.values())this._onDecorationRemoved.fire(e);
                        this.reset();
                    }
                }
                t.DecorationService = c;
                class l extends n.Disposable {
                    constructor(e){
                        super(), this.options = e, this.onRenderEmitter = this.register(new r.EventEmitter), this.onRender = this.onRenderEmitter.event, this._onDispose = this.register(new r.EventEmitter), this.onDispose = this._onDispose.event, this._cachedBg = null, this._cachedFg = null, this.marker = e.marker, this.options.overviewRulerOptions && !this.options.overviewRulerOptions.position && (this.options.overviewRulerOptions.position = "full");
                    }
                    get isDisposed() {
                        return this._isDisposed;
                    }
                    get backgroundColorRGB() {
                        return null === this._cachedBg && (this.options.backgroundColor ? this._cachedBg = s.css.toColor(this.options.backgroundColor) : this._cachedBg = void 0), this._cachedBg;
                    }
                    get foregroundColorRGB() {
                        return null === this._cachedFg && (this.options.foregroundColor ? this._cachedFg = s.css.toColor(this.options.foregroundColor) : this._cachedFg = void 0), this._cachedFg;
                    }
                    dispose() {
                        this._onDispose.fire(), super.dispose();
                    }
                }
            },
            4348: (e, t, i)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.InstantiationService = t.ServiceCollection = void 0;
                const s = i(2585), r = i(8343);
                class n {
                    constructor(...e){
                        this._entries = new Map;
                        for (const [t, i] of e)this.set(t, i);
                    }
                    set(e, t) {
                        const i = this._entries.get(e);
                        return this._entries.set(e, t), i;
                    }
                    forEach(e) {
                        for (const [t, i] of this._entries.entries())e(t, i);
                    }
                    has(e) {
                        return this._entries.has(e);
                    }
                    get(e) {
                        return this._entries.get(e);
                    }
                }
                t.ServiceCollection = n, t.InstantiationService = class {
                    constructor(){
                        this._services = new n, this._services.set(s.IInstantiationService, this);
                    }
                    setService(e, t) {
                        this._services.set(e, t);
                    }
                    getService(e) {
                        return this._services.get(e);
                    }
                    createInstance(e, ...t) {
                        const i = (0, r.getServiceDependencies)(e).sort((e, t)=>e.index - t.index), s = [];
                        for (const t of i){
                            const i = this._services.get(t.id);
                            if (!i) throw new Error(`[createInstance] ${e.name} depends on UNKNOWN service ${t.id}.`);
                            s.push(i);
                        }
                        const n = i.length > 0 ? i[0].index : t.length;
                        if (t.length !== n) throw new Error(`[createInstance] First service dependency of ${e.name} at position ${n + 1} conflicts with ${t.length} static arguments`);
                        return new e(...[
                            ...t,
                            ...s
                        ]);
                    }
                };
            },
            7866: function(e, t, i) {
                var s = this && this.__decorate || function(e, t, i, s) {
                    var r, n = arguments.length, o = n < 3 ? t : null === s ? s = Object.getOwnPropertyDescriptor(t, i) : s;
                    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, i, s);
                    else for(var a = e.length - 1; a >= 0; a--)(r = e[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(t, i, o) : r(t, i)) || o);
                    return n > 3 && o && Object.defineProperty(t, i, o), o;
                }, r = this && this.__param || function(e, t) {
                    return function(i, s) {
                        t(i, s, e);
                    };
                };
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.LogService = void 0;
                const n = i(844), o = i(2585), a = {
                    debug: o.LogLevelEnum.DEBUG,
                    info: o.LogLevelEnum.INFO,
                    warn: o.LogLevelEnum.WARN,
                    error: o.LogLevelEnum.ERROR,
                    off: o.LogLevelEnum.OFF
                };
                let h = class extends n.Disposable {
                    constructor(e){
                        super(), this._optionsService = e, this.logLevel = o.LogLevelEnum.OFF, this._updateLogLevel(), this.register(this._optionsService.onSpecificOptionChange("logLevel", ()=>this._updateLogLevel()));
                    }
                    _updateLogLevel() {
                        this.logLevel = a[this._optionsService.rawOptions.logLevel];
                    }
                    _evalLazyOptionalParams(e) {
                        for(let t = 0; t < e.length; t++)"function" == typeof e[t] && (e[t] = e[t]());
                    }
                    _log(e, t, i) {
                        this._evalLazyOptionalParams(i), e.call(console, "xterm.js: " + t, ...i);
                    }
                    debug(e, ...t) {
                        this.logLevel <= o.LogLevelEnum.DEBUG && this._log(console.log, e, t);
                    }
                    info(e, ...t) {
                        this.logLevel <= o.LogLevelEnum.INFO && this._log(console.info, e, t);
                    }
                    warn(e, ...t) {
                        this.logLevel <= o.LogLevelEnum.WARN && this._log(console.warn, e, t);
                    }
                    error(e, ...t) {
                        this.logLevel <= o.LogLevelEnum.ERROR && this._log(console.error, e, t);
                    }
                };
                h = s([
                    r(0, o.IOptionsService)
                ], h), t.LogService = h;
            },
            7302: (e, t, i)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.OptionsService = t.DEFAULT_OPTIONS = void 0;
                const s = i(8460), r = i(6114), n = i(844);
                t.DEFAULT_OPTIONS = {
                    cols: 80,
                    rows: 24,
                    cursorBlink: !1,
                    cursorStyle: "block",
                    cursorWidth: 1,
                    customGlyphs: !0,
                    drawBoldTextInBrightColors: !0,
                    fastScrollModifier: "alt",
                    fastScrollSensitivity: 5,
                    fontFamily: "courier-new, courier, monospace",
                    fontSize: 15,
                    fontWeight: "normal",
                    fontWeightBold: "bold",
                    lineHeight: 1,
                    letterSpacing: 0,
                    linkHandler: null,
                    logLevel: "info",
                    scrollback: 1e3,
                    scrollOnUserInput: !0,
                    scrollSensitivity: 1,
                    screenReaderMode: !1,
                    smoothScrollDuration: 0,
                    macOptionIsMeta: !1,
                    macOptionClickForcesSelection: !1,
                    minimumContrastRatio: 1,
                    disableStdin: !1,
                    allowProposedApi: !1,
                    allowTransparency: !1,
                    tabStopWidth: 8,
                    theme: {},
                    rightClickSelectsWord: r.isMac,
                    windowOptions: {},
                    windowsMode: !1,
                    windowsPty: {},
                    wordSeparator: " ()[]{}',\"`",
                    altClickMovesCursor: !0,
                    convertEol: !1,
                    termName: "xterm",
                    cancelEvents: !1,
                    overviewRulerWidth: 0
                };
                const o = [
                    "normal",
                    "bold",
                    "100",
                    "200",
                    "300",
                    "400",
                    "500",
                    "600",
                    "700",
                    "800",
                    "900"
                ];
                class a extends n.Disposable {
                    constructor(e){
                        super(), this._onOptionChange = this.register(new s.EventEmitter), this.onOptionChange = this._onOptionChange.event;
                        const i = Object.assign({}, t.DEFAULT_OPTIONS);
                        for(const t in e)if (t in i) try {
                            const s = e[t];
                            i[t] = this._sanitizeAndValidateOption(t, s);
                        } catch (e) {
                            console.error(e);
                        }
                        this.rawOptions = i, this.options = Object.assign({}, i), this._setupOptions();
                    }
                    onSpecificOptionChange(e, t) {
                        return this.onOptionChange((i)=>{
                            i === e && t(this.rawOptions[e]);
                        });
                    }
                    onMultipleOptionChange(e, t) {
                        return this.onOptionChange((i)=>{
                            -1 !== e.indexOf(i) && t();
                        });
                    }
                    _setupOptions() {
                        const e = (e)=>{
                            if (!(e in t.DEFAULT_OPTIONS)) throw new Error(`No option with key "${e}"`);
                            return this.rawOptions[e];
                        }, i = (e, i)=>{
                            if (!(e in t.DEFAULT_OPTIONS)) throw new Error(`No option with key "${e}"`);
                            i = this._sanitizeAndValidateOption(e, i), this.rawOptions[e] !== i && (this.rawOptions[e] = i, this._onOptionChange.fire(e));
                        };
                        for(const t in this.rawOptions){
                            const s = {
                                get: e.bind(this, t),
                                set: i.bind(this, t)
                            };
                            Object.defineProperty(this.options, t, s);
                        }
                    }
                    _sanitizeAndValidateOption(e, i) {
                        switch(e){
                            case "cursorStyle":
                                if (i || (i = t.DEFAULT_OPTIONS[e]), !function(e) {
                                    return "block" === e || "underline" === e || "bar" === e;
                                }(i)) throw new Error(`"${i}" is not a valid value for ${e}`);
                                break;
                            case "wordSeparator":
                                i || (i = t.DEFAULT_OPTIONS[e]);
                                break;
                            case "fontWeight":
                            case "fontWeightBold":
                                if ("number" == typeof i && 1 <= i && i <= 1e3) break;
                                i = o.includes(i) ? i : t.DEFAULT_OPTIONS[e];
                                break;
                            case "cursorWidth":
                                i = Math.floor(i);
                            case "lineHeight":
                            case "tabStopWidth":
                                if (i < 1) throw new Error(`${e} cannot be less than 1, value: ${i}`);
                                break;
                            case "minimumContrastRatio":
                                i = Math.max(1, Math.min(21, Math.round(10 * i) / 10));
                                break;
                            case "scrollback":
                                if ((i = Math.min(i, 4294967295)) < 0) throw new Error(`${e} cannot be less than 0, value: ${i}`);
                                break;
                            case "fastScrollSensitivity":
                            case "scrollSensitivity":
                                if (i <= 0) throw new Error(`${e} cannot be less than or equal to 0, value: ${i}`);
                                break;
                            case "rows":
                            case "cols":
                                if (!i && 0 !== i) throw new Error(`${e} must be numeric, value: ${i}`);
                                break;
                            case "windowsPty":
                                i = null != i ? i : {};
                        }
                        return i;
                    }
                }
                t.OptionsService = a;
            },
            2660: function(e, t, i) {
                var s = this && this.__decorate || function(e, t, i, s) {
                    var r, n = arguments.length, o = n < 3 ? t : null === s ? s = Object.getOwnPropertyDescriptor(t, i) : s;
                    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, i, s);
                    else for(var a = e.length - 1; a >= 0; a--)(r = e[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(t, i, o) : r(t, i)) || o);
                    return n > 3 && o && Object.defineProperty(t, i, o), o;
                }, r = this && this.__param || function(e, t) {
                    return function(i, s) {
                        t(i, s, e);
                    };
                };
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.OscLinkService = void 0;
                const n = i(2585);
                let o = class {
                    constructor(e){
                        this._bufferService = e, this._nextId = 1, this._entriesWithId = new Map, this._dataByLinkId = new Map;
                    }
                    registerLink(e) {
                        const t = this._bufferService.buffer;
                        if (void 0 === e.id) {
                            const i = t.addMarker(t.ybase + t.y), s = {
                                data: e,
                                id: this._nextId++,
                                lines: [
                                    i
                                ]
                            };
                            return i.onDispose(()=>this._removeMarkerFromLink(s, i)), this._dataByLinkId.set(s.id, s), s.id;
                        }
                        const i = e, s = this._getEntryIdKey(i), r = this._entriesWithId.get(s);
                        if (r) return this.addLineToLink(r.id, t.ybase + t.y), r.id;
                        const n = t.addMarker(t.ybase + t.y), o = {
                            id: this._nextId++,
                            key: this._getEntryIdKey(i),
                            data: i,
                            lines: [
                                n
                            ]
                        };
                        return n.onDispose(()=>this._removeMarkerFromLink(o, n)), this._entriesWithId.set(o.key, o), this._dataByLinkId.set(o.id, o), o.id;
                    }
                    addLineToLink(e, t) {
                        const i = this._dataByLinkId.get(e);
                        if (i && i.lines.every((e)=>e.line !== t)) {
                            const e = this._bufferService.buffer.addMarker(t);
                            i.lines.push(e), e.onDispose(()=>this._removeMarkerFromLink(i, e));
                        }
                    }
                    getLinkData(e) {
                        var t;
                        return null === (t = this._dataByLinkId.get(e)) || void 0 === t ? void 0 : t.data;
                    }
                    _getEntryIdKey(e) {
                        return `${e.id};;${e.uri}`;
                    }
                    _removeMarkerFromLink(e, t) {
                        const i = e.lines.indexOf(t);
                        -1 !== i && (e.lines.splice(i, 1), 0 === e.lines.length && (void 0 !== e.data.id && this._entriesWithId.delete(e.key), this._dataByLinkId.delete(e.id)));
                    }
                };
                o = s([
                    r(0, n.IBufferService)
                ], o), t.OscLinkService = o;
            },
            8343: (e, t)=>{
                function i(e, t, i) {
                    t.di$target === t ? t.di$dependencies.push({
                        id: e,
                        index: i
                    }) : (t.di$dependencies = [
                        {
                            id: e,
                            index: i
                        }
                    ], t.di$target = t);
                }
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.createDecorator = t.getServiceDependencies = t.serviceRegistry = void 0, t.serviceRegistry = new Map, t.getServiceDependencies = function(e) {
                    return e.di$dependencies || [];
                }, t.createDecorator = function(e) {
                    if (t.serviceRegistry.has(e)) return t.serviceRegistry.get(e);
                    const s = function(e, t, r) {
                        if (3 !== arguments.length) throw new Error("@IServiceName-decorator can only be used to decorate a parameter");
                        i(s, e, r);
                    };
                    return s.toString = ()=>e, t.serviceRegistry.set(e, s), s;
                };
            },
            2585: (e, t, i)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.IDecorationService = t.IUnicodeService = t.IOscLinkService = t.IOptionsService = t.ILogService = t.LogLevelEnum = t.IInstantiationService = t.ICharsetService = t.ICoreService = t.ICoreMouseService = t.IBufferService = void 0;
                const s = i(8343);
                var r;
                t.IBufferService = (0, s.createDecorator)("BufferService"), t.ICoreMouseService = (0, s.createDecorator)("CoreMouseService"), t.ICoreService = (0, s.createDecorator)("CoreService"), t.ICharsetService = (0, s.createDecorator)("CharsetService"), t.IInstantiationService = (0, s.createDecorator)("InstantiationService"), (r = t.LogLevelEnum || (t.LogLevelEnum = {}))[r.DEBUG = 0] = "DEBUG", r[r.INFO = 1] = "INFO", r[r.WARN = 2] = "WARN", r[r.ERROR = 3] = "ERROR", r[r.OFF = 4] = "OFF", t.ILogService = (0, s.createDecorator)("LogService"), t.IOptionsService = (0, s.createDecorator)("OptionsService"), t.IOscLinkService = (0, s.createDecorator)("OscLinkService"), t.IUnicodeService = (0, s.createDecorator)("UnicodeService"), t.IDecorationService = (0, s.createDecorator)("DecorationService");
            },
            1480: (e, t, i)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.UnicodeService = void 0;
                const s = i(8460), r = i(225);
                t.UnicodeService = class {
                    constructor(){
                        this._providers = Object.create(null), this._active = "", this._onChange = new s.EventEmitter, this.onChange = this._onChange.event;
                        const e = new r.UnicodeV6;
                        this.register(e), this._active = e.version, this._activeProvider = e;
                    }
                    dispose() {
                        this._onChange.dispose();
                    }
                    get versions() {
                        return Object.keys(this._providers);
                    }
                    get activeVersion() {
                        return this._active;
                    }
                    set activeVersion(e) {
                        if (!this._providers[e]) throw new Error(`unknown Unicode version "${e}"`);
                        this._active = e, this._activeProvider = this._providers[e], this._onChange.fire(e);
                    }
                    register(e) {
                        this._providers[e.version] = e;
                    }
                    wcwidth(e) {
                        return this._activeProvider.wcwidth(e);
                    }
                    getStringCellWidth(e) {
                        let t = 0;
                        const i = e.length;
                        for(let s = 0; s < i; ++s){
                            let r = e.charCodeAt(s);
                            if (55296 <= r && r <= 56319) {
                                if (++s >= i) return t + this.wcwidth(r);
                                const n = e.charCodeAt(s);
                                56320 <= n && n <= 57343 ? r = 1024 * (r - 55296) + n - 56320 + 65536 : t += this.wcwidth(n);
                            }
                            t += this.wcwidth(r);
                        }
                        return t;
                    }
                };
            }
        }, t = {};
        function i(s) {
            var r = t[s];
            if (void 0 !== r) return r.exports;
            var n = t[s] = {
                exports: {}
            };
            return e[s].call(n.exports, n, n.exports, i), n.exports;
        }
        var s = {};
        return (()=>{
            var e = s;
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.Terminal = void 0;
            const t = i(3236), r = i(9042), n = i(7975), o = i(7090), a = i(5741), h = i(8285), c = [
                "cols",
                "rows"
            ];
            e.Terminal = class {
                constructor(e){
                    this._core = new t.Terminal(e), this._addonManager = new a.AddonManager, this._publicOptions = Object.assign({}, this._core.options);
                    const i = (e)=>this._core.options[e], s = (e, t)=>{
                        this._checkReadonlyOptions(e), this._core.options[e] = t;
                    };
                    for(const e in this._core.options){
                        const t = {
                            get: i.bind(this, e),
                            set: s.bind(this, e)
                        };
                        Object.defineProperty(this._publicOptions, e, t);
                    }
                }
                _checkReadonlyOptions(e) {
                    if (c.includes(e)) throw new Error(`Option "${e}" can only be set in the constructor`);
                }
                _checkProposedApi() {
                    if (!this._core.optionsService.rawOptions.allowProposedApi) throw new Error("You must set the allowProposedApi option to true to use proposed API");
                }
                get onBell() {
                    return this._core.onBell;
                }
                get onBinary() {
                    return this._core.onBinary;
                }
                get onCursorMove() {
                    return this._core.onCursorMove;
                }
                get onData() {
                    return this._core.onData;
                }
                get onKey() {
                    return this._core.onKey;
                }
                get onLineFeed() {
                    return this._core.onLineFeed;
                }
                get onRender() {
                    return this._core.onRender;
                }
                get onResize() {
                    return this._core.onResize;
                }
                get onScroll() {
                    return this._core.onScroll;
                }
                get onSelectionChange() {
                    return this._core.onSelectionChange;
                }
                get onTitleChange() {
                    return this._core.onTitleChange;
                }
                get onWriteParsed() {
                    return this._core.onWriteParsed;
                }
                get element() {
                    return this._core.element;
                }
                get parser() {
                    return this._parser || (this._parser = new n.ParserApi(this._core)), this._parser;
                }
                get unicode() {
                    return this._checkProposedApi(), new o.UnicodeApi(this._core);
                }
                get textarea() {
                    return this._core.textarea;
                }
                get rows() {
                    return this._core.rows;
                }
                get cols() {
                    return this._core.cols;
                }
                get buffer() {
                    return this._buffer || (this._buffer = new h.BufferNamespaceApi(this._core)), this._buffer;
                }
                get markers() {
                    return this._checkProposedApi(), this._core.markers;
                }
                get modes() {
                    const e = this._core.coreService.decPrivateModes;
                    let t = "none";
                    switch(this._core.coreMouseService.activeProtocol){
                        case "X10":
                            t = "x10";
                            break;
                        case "VT200":
                            t = "vt200";
                            break;
                        case "DRAG":
                            t = "drag";
                            break;
                        case "ANY":
                            t = "any";
                    }
                    return {
                        applicationCursorKeysMode: e.applicationCursorKeys,
                        applicationKeypadMode: e.applicationKeypad,
                        bracketedPasteMode: e.bracketedPasteMode,
                        insertMode: this._core.coreService.modes.insertMode,
                        mouseTrackingMode: t,
                        originMode: e.origin,
                        reverseWraparoundMode: e.reverseWraparound,
                        sendFocusMode: e.sendFocus,
                        wraparoundMode: e.wraparound
                    };
                }
                get options() {
                    return this._publicOptions;
                }
                set options(e) {
                    for(const t in e)this._publicOptions[t] = e[t];
                }
                blur() {
                    this._core.blur();
                }
                focus() {
                    this._core.focus();
                }
                resize(e, t) {
                    this._verifyIntegers(e, t), this._core.resize(e, t);
                }
                open(e) {
                    this._core.open(e);
                }
                attachCustomKeyEventHandler(e) {
                    this._core.attachCustomKeyEventHandler(e);
                }
                registerLinkProvider(e) {
                    return this._core.registerLinkProvider(e);
                }
                registerCharacterJoiner(e) {
                    return this._checkProposedApi(), this._core.registerCharacterJoiner(e);
                }
                deregisterCharacterJoiner(e) {
                    this._checkProposedApi(), this._core.deregisterCharacterJoiner(e);
                }
                registerMarker(e = 0) {
                    return this._verifyIntegers(e), this._core.addMarker(e);
                }
                registerDecoration(e) {
                    var t, i, s;
                    return this._checkProposedApi(), this._verifyPositiveIntegers(null !== (t = e.x) && void 0 !== t ? t : 0, null !== (i = e.width) && void 0 !== i ? i : 0, null !== (s = e.height) && void 0 !== s ? s : 0), this._core.registerDecoration(e);
                }
                hasSelection() {
                    return this._core.hasSelection();
                }
                select(e, t, i) {
                    this._verifyIntegers(e, t, i), this._core.select(e, t, i);
                }
                getSelection() {
                    return this._core.getSelection();
                }
                getSelectionPosition() {
                    return this._core.getSelectionPosition();
                }
                clearSelection() {
                    this._core.clearSelection();
                }
                selectAll() {
                    this._core.selectAll();
                }
                selectLines(e, t) {
                    this._verifyIntegers(e, t), this._core.selectLines(e, t);
                }
                dispose() {
                    this._addonManager.dispose(), this._core.dispose();
                }
                scrollLines(e) {
                    this._verifyIntegers(e), this._core.scrollLines(e);
                }
                scrollPages(e) {
                    this._verifyIntegers(e), this._core.scrollPages(e);
                }
                scrollToTop() {
                    this._core.scrollToTop();
                }
                scrollToBottom() {
                    this._core.scrollToBottom();
                }
                scrollToLine(e) {
                    this._verifyIntegers(e), this._core.scrollToLine(e);
                }
                clear() {
                    this._core.clear();
                }
                write(e, t) {
                    this._core.write(e, t);
                }
                writeln(e, t) {
                    this._core.write(e), this._core.write("\r\n", t);
                }
                paste(e) {
                    this._core.paste(e);
                }
                refresh(e, t) {
                    this._verifyIntegers(e, t), this._core.refresh(e, t);
                }
                reset() {
                    this._core.reset();
                }
                clearTextureAtlas() {
                    this._core.clearTextureAtlas();
                }
                loadAddon(e) {
                    return this._addonManager.loadAddon(this, e);
                }
                static get strings() {
                    return r;
                }
                _verifyIntegers(...e) {
                    for (const t of e)if (t === 1 / 0 || isNaN(t) || t % 1 != 0) throw new Error("This API only accepts integers");
                }
                _verifyPositiveIntegers(...e) {
                    for (const t of e)if (t && (t === 1 / 0 || isNaN(t) || t % 1 != 0 || t < 0)) throw new Error("This API only accepts positive integers");
                }
            };
        })(), s;
    })());

},{}],"jAzui":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function ConfettiGenerator(params) {
    //////////////
    // Defaults
    var appstate = {
        target: "confetti-holder",
        max: 80,
        size: 1,
        animate: true,
        respawn: true,
        props: [
            "circle",
            "square",
            "triangle",
            "line"
        ],
        colors: [
            [
                165,
                104,
                246
            ],
            [
                230,
                61,
                135
            ],
            [
                0,
                199,
                228
            ],
            [
                253,
                214,
                126
            ]
        ],
        clock: 25,
        interval: null,
        rotate: false,
        start_from_edge: false,
        width: window.innerWidth,
        height: window.innerHeight // canvas height (as int, in px)
    };
    //////////////
    // Setting parameters if received
    if (params) {
        if (params.target) appstate.target = params.target;
        if (params.max) appstate.max = params.max;
        if (params.size) appstate.size = params.size;
        if (params.animate !== undefined && params.animate !== null) appstate.animate = params.animate;
        if (params.respawn !== undefined && params.respawn !== null) appstate.respawn = params.respawn;
        if (params.props) appstate.props = params.props;
        if (params.colors) appstate.colors = params.colors;
        if (params.clock) appstate.clock = params.clock;
        if (params.start_from_edge !== undefined && params.start_from_edge !== null) appstate.start_from_edge = params.start_from_edge;
        if (params.width) appstate.width = params.width;
        if (params.height) appstate.height = params.height;
        if (params.rotate !== undefined && params.rotate !== null) appstate.rotate = params.rotate;
    }
    //////////////
    // Early exit if the target is not the correct type, or is null
    if (typeof appstate.target != "object" && typeof appstate.target != "string") throw new TypeError("The target parameter should be a node or string");
    if (typeof appstate.target == "object" && (appstate.target === null || !appstate.target instanceof HTMLCanvasElement) || typeof appstate.target == "string" && (document.getElementById(appstate.target) === null || !document.getElementById(appstate.target) instanceof HTMLCanvasElement)) throw new ReferenceError("The target element does not exist or is not a canvas element");
    //////////////
    // Properties
    var cv = typeof appstate.target == "object" ? appstate.target : document.getElementById(appstate.target);
    var ctx = cv.getContext("2d");
    var particles = [];
    //////////////
    // Random helper (to minimize typing)
    function rand(limit, floor) {
        if (!limit) limit = 1;
        var rand = Math.random() * limit;
        return !floor ? rand : Math.floor(rand);
    }
    var totalWeight = appstate.props.reduce(function(weight, prop) {
        return weight + (prop.weight || 1);
    }, 0);
    function selectProp() {
        var rand = Math.random() * totalWeight;
        for(var i = 0; i < appstate.props.length; ++i){
            var weight = appstate.props[i].weight || 1;
            if (rand < weight) return i;
            rand -= weight;
        }
    }
    //////////////
    // Confetti particle generator
    function particleFactory() {
        var prop = appstate.props[selectProp()];
        var p = {
            prop: prop.type ? prop.type : prop,
            x: rand(appstate.width),
            y: appstate.start_from_edge ? appstate.clock >= 0 ? -10 : parseFloat(appstate.height) + 10 : rand(appstate.height),
            src: prop.src,
            radius: rand(4) + 1,
            size: prop.size,
            rotate: appstate.rotate,
            line: Math.floor(rand(65) - 30),
            angles: [
                rand(10, true) + 2,
                rand(10, true) + 2,
                rand(10, true) + 2,
                rand(10, true) + 2
            ],
            color: appstate.colors[rand(appstate.colors.length, true)],
            rotation: rand(360, true) * Math.PI / 180,
            speed: rand(appstate.clock / 7) + appstate.clock / 30
        };
        return p;
    }
    //////////////
    // Confetti drawing on canvas
    function particleDraw(p) {
        if (!p) return;
        var op = p.radius <= 3 ? 0.4 : 0.8;
        ctx.fillStyle = ctx.strokeStyle = "rgba(" + p.color + ", " + op + ")";
        ctx.beginPath();
        switch(p.prop){
            case "circle":
                ctx.moveTo(p.x, p.y);
                ctx.arc(p.x, p.y, p.radius * appstate.size, 0, Math.PI * 2, true);
                ctx.fill();
                break;
            case "triangle":
                ctx.moveTo(p.x, p.y);
                ctx.lineTo(p.x + p.angles[0] * appstate.size, p.y + p.angles[1] * appstate.size);
                ctx.lineTo(p.x + p.angles[2] * appstate.size, p.y + p.angles[3] * appstate.size);
                ctx.closePath();
                ctx.fill();
                break;
            case "line":
                ctx.moveTo(p.x, p.y);
                ctx.lineTo(p.x + p.line * appstate.size, p.y + p.radius * 5);
                ctx.lineWidth = 2 * appstate.size;
                ctx.stroke();
                break;
            case "square":
                ctx.save();
                ctx.translate(p.x + 15, p.y + 5);
                ctx.rotate(p.rotation);
                ctx.fillRect(-15 * appstate.size, -5 * appstate.size, 15 * appstate.size, 5 * appstate.size);
                ctx.restore();
                break;
            case "svg":
                ctx.save();
                var image = new window.Image();
                image.src = p.src;
                var size = p.size || 15;
                ctx.translate(p.x + size / 2, p.y + size / 2);
                if (p.rotate) ctx.rotate(p.rotation);
                ctx.drawImage(image, -(size / 2) * appstate.size, -(size / 2) * appstate.size, size * appstate.size, size * appstate.size);
                ctx.restore();
                break;
        }
    }
    //////////////
    // Public itens
    //////////////
    //////////////
    // Clean actual state
    var _clear = function() {
        appstate.animate = false;
        clearInterval(appstate.interval);
        requestAnimationFrame(function() {
            ctx.clearRect(0, 0, cv.width, cv.height);
            var w = cv.width;
            cv.width = 1;
            cv.width = w;
        });
    };
    //////////////
    // Render confetti on canvas
    var _render = function() {
        cv.width = appstate.width;
        cv.height = appstate.height;
        particles = [];
        for(var i = 0; i < appstate.max; i++)particles.push(particleFactory());
        function draw() {
            ctx.clearRect(0, 0, appstate.width, appstate.height);
            for(var i in particles)particleDraw(particles[i]);
            update();
            if (appstate.animate) requestAnimationFrame(draw);
        }
        function update() {
            for(var i = 0; i < appstate.max; i++){
                var p = particles[i];
                if (p) {
                    if (appstate.animate) p.y += p.speed;
                    if (p.rotate) p.rotation += p.speed / 35;
                    if (p.speed >= 0 && p.y > appstate.height || p.speed < 0 && p.y < 0) {
                        if (appstate.respawn) {
                            particles[i] = p;
                            particles[i].x = rand(appstate.width, true);
                            particles[i].y = p.speed >= 0 ? -10 : parseFloat(appstate.height);
                        } else particles[i] = undefined;
                    }
                }
            }
            if (particles.every(function(p) {
                return p === undefined;
            })) _clear();
        }
        return requestAnimationFrame(draw);
    };
    return {
        render: _render,
        clear: _clear
    };
}
exports.default = ConfettiGenerator;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gkKU3":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, "__esModule", {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === "default" || key === "__esModule" || dest.hasOwnProperty(key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"fl6Io":[function(require,module,exports) {
!function(e, t) {
    module.exports = t();
}(self, function() {
    return (()=>{
        "use strict";
        var e = {};
        return (()=>{
            var t = e;
            function s(e, t, s) {
                return e.addEventListener(t, s), {
                    dispose: ()=>{
                        s && e.removeEventListener(t, s);
                    }
                };
            }
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.AttachAddon = void 0, t.AttachAddon = class {
                constructor(e, t){
                    this._disposables = [], this._socket = e, this._socket.binaryType = "arraybuffer", this._bidirectional = !(t && !1 === t.bidirectional);
                }
                activate(e) {
                    this._disposables.push(s(this._socket, "message", (t)=>{
                        const s = t.data;
                        e.write("string" == typeof s ? s : new Uint8Array(s));
                    })), this._bidirectional && (this._disposables.push(e.onData((e)=>this._sendData(e))), this._disposables.push(e.onBinary((e)=>this._sendBinary(e)))), this._disposables.push(s(this._socket, "close", ()=>this.dispose())), this._disposables.push(s(this._socket, "error", ()=>this.dispose()));
                }
                dispose() {
                    for (const e of this._disposables)e.dispose();
                }
                _sendData(e) {
                    this._checkOpenSocket() && this._socket.send(e);
                }
                _sendBinary(e) {
                    if (!this._checkOpenSocket()) return;
                    const t = new Uint8Array(e.length);
                    for(let s = 0; s < e.length; ++s)t[s] = 255 & e.charCodeAt(s);
                    this._socket.send(t);
                }
                _checkOpenSocket() {
                    switch(this._socket.readyState){
                        case WebSocket.OPEN:
                            return !0;
                        case WebSocket.CONNECTING:
                            throw new Error("Attach addon was loaded before socket was open");
                        case WebSocket.CLOSING:
                            return console.warn("Attach addon socket is closing"), !1;
                        case WebSocket.CLOSED:
                            throw new Error("Attach addon socket is closed");
                        default:
                            throw new Error("Unexpected socket state");
                    }
                }
            };
        })(), e;
    })();
});

},{}],"llEjX":[function(require,module,exports) {
!function(e, t) {
    module.exports = t();
}(self, ()=>(()=>{
        "use strict";
        var e = {
            903: (e, t, i)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.BaseRenderLayer = void 0;
                const s = i(627), r = i(237), o = i(860), n = i(374), a = i(296), h = i(855), l = i(274), c = i(859), d = i(399), _ = i(345);
                class u extends c.Disposable {
                    constructor(e, t, i, s, r, o, n, h, d, u){
                        super(), this._terminal = e, this._container = t, this._alpha = r, this._themeService = o, this._bufferService = n, this._optionsService = h, this._decorationService = d, this._coreBrowserService = u, this._deviceCharWidth = 0, this._deviceCharHeight = 0, this._deviceCellWidth = 0, this._deviceCellHeight = 0, this._deviceCharLeft = 0, this._deviceCharTop = 0, this._selectionModel = (0, a.createSelectionRenderModel)(), this._bitmapGenerator = [], this._onAddTextureAtlasCanvas = this.register(new _.EventEmitter), this.onAddTextureAtlasCanvas = this._onAddTextureAtlasCanvas.event, this._cellColorResolver = new l.CellColorResolver(this._terminal, this._selectionModel, this._decorationService, this._coreBrowserService, this._themeService), this._canvas = document.createElement("canvas"), this._canvas.classList.add(`xterm-${i}-layer`), this._canvas.style.zIndex = s.toString(), this._initCanvas(), this._container.appendChild(this._canvas), this._refreshCharAtlas(this._themeService.colors), this.register(this._themeService.onChangeColors((e)=>{
                            this._refreshCharAtlas(e), this.reset(), this.handleSelectionChanged(this._selectionModel.selectionStart, this._selectionModel.selectionEnd, this._selectionModel.columnSelectMode);
                        })), this.register((0, c.toDisposable)(()=>{
                            var e;
                            this._canvas.remove(), null === (e = this._charAtlas) || void 0 === e || e.dispose();
                        }));
                    }
                    get canvas() {
                        return this._canvas;
                    }
                    get cacheCanvas() {
                        var e;
                        return null === (e = this._charAtlas) || void 0 === e ? void 0 : e.pages[0].canvas;
                    }
                    _initCanvas() {
                        this._ctx = (0, n.throwIfFalsy)(this._canvas.getContext("2d", {
                            alpha: this._alpha
                        })), this._alpha || this._clearAll();
                    }
                    handleBlur() {}
                    handleFocus() {}
                    handleCursorMove() {}
                    handleGridChanged(e, t) {}
                    handleSelectionChanged(e, t, i = !1) {
                        this._selectionModel.update(this._terminal, e, t, i);
                    }
                    _setTransparency(e) {
                        if (e === this._alpha) return;
                        const t = this._canvas;
                        this._alpha = e, this._canvas = this._canvas.cloneNode(), this._initCanvas(), this._container.replaceChild(this._canvas, t), this._refreshCharAtlas(this._themeService.colors), this.handleGridChanged(0, this._bufferService.rows - 1);
                    }
                    _refreshCharAtlas(e) {
                        var t;
                        if (!(this._deviceCharWidth <= 0 && this._deviceCharHeight <= 0)) {
                            null === (t = this._charAtlasDisposable) || void 0 === t || t.dispose(), this._charAtlas = (0, s.acquireTextureAtlas)(this._terminal, this._optionsService.rawOptions, e, this._deviceCellWidth, this._deviceCellHeight, this._deviceCharWidth, this._deviceCharHeight, this._coreBrowserService.dpr), this._charAtlasDisposable = (0, _.forwardEvent)(this._charAtlas.onAddTextureAtlasCanvas, this._onAddTextureAtlasCanvas), this._charAtlas.warmUp();
                            for(let e = 0; e < this._charAtlas.pages.length; e++)this._bitmapGenerator[e] = new g(this._charAtlas.pages[e].canvas);
                        }
                    }
                    resize(e) {
                        this._deviceCellWidth = e.device.cell.width, this._deviceCellHeight = e.device.cell.height, this._deviceCharWidth = e.device.char.width, this._deviceCharHeight = e.device.char.height, this._deviceCharLeft = e.device.char.left, this._deviceCharTop = e.device.char.top, this._canvas.width = e.device.canvas.width, this._canvas.height = e.device.canvas.height, this._canvas.style.width = `${e.css.canvas.width}px`, this._canvas.style.height = `${e.css.canvas.height}px`, this._alpha || this._clearAll(), this._refreshCharAtlas(this._themeService.colors);
                    }
                    clearTextureAtlas() {
                        var e;
                        null === (e = this._charAtlas) || void 0 === e || e.clearTexture();
                    }
                    _fillCells(e, t, i, s) {
                        this._ctx.fillRect(e * this._deviceCellWidth, t * this._deviceCellHeight, i * this._deviceCellWidth, s * this._deviceCellHeight);
                    }
                    _fillMiddleLineAtCells(e, t, i = 1) {
                        const s = Math.ceil(.5 * this._deviceCellHeight);
                        this._ctx.fillRect(e * this._deviceCellWidth, (t + 1) * this._deviceCellHeight - s - this._coreBrowserService.dpr, i * this._deviceCellWidth, this._coreBrowserService.dpr);
                    }
                    _fillBottomLineAtCells(e, t, i = 1, s = 0) {
                        this._ctx.fillRect(e * this._deviceCellWidth, (t + 1) * this._deviceCellHeight + s - this._coreBrowserService.dpr - 1, i * this._deviceCellWidth, this._coreBrowserService.dpr);
                    }
                    _curlyUnderlineAtCell(e, t, i = 1) {
                        this._ctx.save(), this._ctx.beginPath(), this._ctx.strokeStyle = this._ctx.fillStyle;
                        const s = this._coreBrowserService.dpr;
                        this._ctx.lineWidth = s;
                        for(let r = 0; r < i; r++){
                            const i = (e + r) * this._deviceCellWidth, o = (e + r + .5) * this._deviceCellWidth, n = (e + r + 1) * this._deviceCellWidth, a = (t + 1) * this._deviceCellHeight - s - 1, h = a - s, l = a + s;
                            this._ctx.moveTo(i, a), this._ctx.bezierCurveTo(i, h, o, h, o, a), this._ctx.bezierCurveTo(o, l, n, l, n, a);
                        }
                        this._ctx.stroke(), this._ctx.restore();
                    }
                    _dottedUnderlineAtCell(e, t, i = 1) {
                        this._ctx.save(), this._ctx.beginPath(), this._ctx.strokeStyle = this._ctx.fillStyle;
                        const s = this._coreBrowserService.dpr;
                        this._ctx.lineWidth = s, this._ctx.setLineDash([
                            2 * s,
                            s
                        ]);
                        const r = e * this._deviceCellWidth, o = (t + 1) * this._deviceCellHeight - s - 1;
                        this._ctx.moveTo(r, o);
                        for(let t = 0; t < i; t++){
                            const s = (e + i + t) * this._deviceCellWidth;
                            this._ctx.lineTo(s, o);
                        }
                        this._ctx.stroke(), this._ctx.closePath(), this._ctx.restore();
                    }
                    _dashedUnderlineAtCell(e, t, i = 1) {
                        this._ctx.save(), this._ctx.beginPath(), this._ctx.strokeStyle = this._ctx.fillStyle;
                        const s = this._coreBrowserService.dpr;
                        this._ctx.lineWidth = s, this._ctx.setLineDash([
                            4 * s,
                            3 * s
                        ]);
                        const r = e * this._deviceCellWidth, o = (e + i) * this._deviceCellWidth, n = (t + 1) * this._deviceCellHeight - s - 1;
                        this._ctx.moveTo(r, n), this._ctx.lineTo(o, n), this._ctx.stroke(), this._ctx.closePath(), this._ctx.restore();
                    }
                    _fillLeftLineAtCell(e, t, i) {
                        this._ctx.fillRect(e * this._deviceCellWidth, t * this._deviceCellHeight, this._coreBrowserService.dpr * i, this._deviceCellHeight);
                    }
                    _strokeRectAtCell(e, t, i, s) {
                        const r = this._coreBrowserService.dpr;
                        this._ctx.lineWidth = r, this._ctx.strokeRect(e * this._deviceCellWidth + r / 2, t * this._deviceCellHeight + r / 2, i * this._deviceCellWidth - r, s * this._deviceCellHeight - r);
                    }
                    _clearAll() {
                        this._alpha ? this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height) : (this._ctx.fillStyle = this._themeService.colors.background.css, this._ctx.fillRect(0, 0, this._canvas.width, this._canvas.height));
                    }
                    _clearCells(e, t, i, s) {
                        this._alpha ? this._ctx.clearRect(e * this._deviceCellWidth, t * this._deviceCellHeight, i * this._deviceCellWidth, s * this._deviceCellHeight) : (this._ctx.fillStyle = this._themeService.colors.background.css, this._ctx.fillRect(e * this._deviceCellWidth, t * this._deviceCellHeight, i * this._deviceCellWidth, s * this._deviceCellHeight));
                    }
                    _fillCharTrueColor(e, t, i) {
                        this._ctx.font = this._getFont(!1, !1), this._ctx.textBaseline = r.TEXT_BASELINE, this._clipRow(i);
                        let s = !1;
                        !1 !== this._optionsService.rawOptions.customGlyphs && (s = (0, o.tryDrawCustomChar)(this._ctx, e.getChars(), t * this._deviceCellWidth, i * this._deviceCellHeight, this._deviceCellWidth, this._deviceCellHeight, this._optionsService.rawOptions.fontSize, this._coreBrowserService.dpr)), s || this._ctx.fillText(e.getChars(), t * this._deviceCellWidth + this._deviceCharLeft, i * this._deviceCellHeight + this._deviceCharTop + this._deviceCharHeight);
                    }
                    _drawChars(e, t, i) {
                        var s, r, o, n;
                        const a = e.getChars();
                        let l;
                        this._cellColorResolver.resolve(e, t, this._bufferService.buffer.ydisp + i), l = a && a.length > 1 ? this._charAtlas.getRasterizedGlyphCombinedChar(a, this._cellColorResolver.result.bg, this._cellColorResolver.result.fg, this._cellColorResolver.result.ext) : this._charAtlas.getRasterizedGlyph(e.getCode() || h.WHITESPACE_CELL_CODE, this._cellColorResolver.result.bg, this._cellColorResolver.result.fg, this._cellColorResolver.result.ext), l.size.x && l.size.y && (this._ctx.save(), this._clipRow(i), this._bitmapGenerator[l.texturePage] && this._charAtlas.pages[l.texturePage].canvas !== this._bitmapGenerator[l.texturePage].canvas && (null === (r = null === (s = this._bitmapGenerator[l.texturePage]) || void 0 === s ? void 0 : s.bitmap) || void 0 === r || r.close(), delete this._bitmapGenerator[l.texturePage]), this._charAtlas.pages[l.texturePage].version !== (null === (o = this._bitmapGenerator[l.texturePage]) || void 0 === o ? void 0 : o.version) && (this._bitmapGenerator[l.texturePage] || (this._bitmapGenerator[l.texturePage] = new g(this._charAtlas.pages[l.texturePage].canvas)), this._bitmapGenerator[l.texturePage].refresh(), this._bitmapGenerator[l.texturePage].version = this._charAtlas.pages[l.texturePage].version), this._ctx.drawImage((null === (n = this._bitmapGenerator[l.texturePage]) || void 0 === n ? void 0 : n.bitmap) || this._charAtlas.pages[l.texturePage].canvas, l.texturePosition.x, l.texturePosition.y, l.size.x, l.size.y, t * this._deviceCellWidth + this._deviceCharLeft - l.offset.x, i * this._deviceCellHeight + this._deviceCharTop - l.offset.y, l.size.x, l.size.y), this._ctx.restore());
                    }
                    _clipRow(e) {
                        this._ctx.beginPath(), this._ctx.rect(0, e * this._deviceCellHeight, this._bufferService.cols * this._deviceCellWidth, this._deviceCellHeight), this._ctx.clip();
                    }
                    _getFont(e, t) {
                        return `${t ? "italic" : ""} ${e ? this._optionsService.rawOptions.fontWeightBold : this._optionsService.rawOptions.fontWeight} ${this._optionsService.rawOptions.fontSize * this._coreBrowserService.dpr}px ${this._optionsService.rawOptions.fontFamily}`;
                    }
                }
                t.BaseRenderLayer = u;
                class g {
                    constructor(e){
                        this.canvas = e, this._state = 0, this._commitTimeout = void 0, this._bitmap = void 0, this.version = -1;
                    }
                    get bitmap() {
                        return this._bitmap;
                    }
                    refresh() {
                        var e;
                        null === (e = this._bitmap) || void 0 === e || e.close(), this._bitmap = void 0, d.isSafari || (void 0 === this._commitTimeout && (this._commitTimeout = window.setTimeout(()=>this._generate(), 100)), 1 === this._state && (this._state = 2));
                    }
                    _generate() {
                        var e;
                        0 === this._state && (null === (e = this._bitmap) || void 0 === e || e.close(), this._bitmap = void 0, this._state = 1, window.createImageBitmap(this.canvas).then((e)=>{
                            2 === this._state ? this.refresh() : this._bitmap = e, this._state = 0;
                        }), this._commitTimeout && (this._commitTimeout = void 0));
                    }
                }
            },
            949: (e, t, i)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.CanvasRenderer = void 0;
                const s = i(627), r = i(56), o = i(374), n = i(345), a = i(859), h = i(873), l = i(43), c = i(630), d = i(744);
                class _ extends a.Disposable {
                    constructor(e, t, i, _, u, g, f, v, C, p, x){
                        super(), this._terminal = e, this._screenElement = t, this._bufferService = _, this._charSizeService = u, this._optionsService = g, this._coreBrowserService = C, this._themeService = x, this._onRequestRedraw = this.register(new n.EventEmitter), this.onRequestRedraw = this._onRequestRedraw.event, this._onChangeTextureAtlas = this.register(new n.EventEmitter), this.onChangeTextureAtlas = this._onChangeTextureAtlas.event, this._onAddTextureAtlasCanvas = this.register(new n.EventEmitter), this.onAddTextureAtlasCanvas = this._onAddTextureAtlasCanvas.event;
                        const m = this._optionsService.rawOptions.allowTransparency;
                        this._renderLayers = [
                            new d.TextRenderLayer(this._terminal, this._screenElement, 0, m, this._bufferService, this._optionsService, f, p, this._coreBrowserService, x),
                            new c.SelectionRenderLayer(this._terminal, this._screenElement, 1, this._bufferService, this._coreBrowserService, p, this._optionsService, x),
                            new l.LinkRenderLayer(this._terminal, this._screenElement, 2, i, this._bufferService, this._optionsService, p, this._coreBrowserService, x),
                            new h.CursorRenderLayer(this._terminal, this._screenElement, 3, this._onRequestRedraw, this._bufferService, this._optionsService, v, this._coreBrowserService, p, x)
                        ];
                        for (const e of this._renderLayers)(0, n.forwardEvent)(e.onAddTextureAtlasCanvas, this._onAddTextureAtlasCanvas);
                        this.dimensions = (0, o.createRenderDimensions)(), this._devicePixelRatio = this._coreBrowserService.dpr, this._updateDimensions(), this.register((0, r.observeDevicePixelDimensions)(this._renderLayers[0].canvas, this._coreBrowserService.window, (e, t)=>this._setCanvasDevicePixelDimensions(e, t))), this.register((0, a.toDisposable)(()=>{
                            for (const e of this._renderLayers)e.dispose();
                            (0, s.removeTerminalFromCache)(this._terminal);
                        }));
                    }
                    get textureAtlas() {
                        return this._renderLayers[0].cacheCanvas;
                    }
                    handleDevicePixelRatioChange() {
                        this._devicePixelRatio !== this._coreBrowserService.dpr && (this._devicePixelRatio = this._coreBrowserService.dpr, this.handleResize(this._bufferService.cols, this._bufferService.rows));
                    }
                    handleResize(e, t) {
                        this._updateDimensions();
                        for (const e of this._renderLayers)e.resize(this.dimensions);
                        this._screenElement.style.width = `${this.dimensions.css.canvas.width}px`, this._screenElement.style.height = `${this.dimensions.css.canvas.height}px`;
                    }
                    handleCharSizeChanged() {
                        this.handleResize(this._bufferService.cols, this._bufferService.rows);
                    }
                    handleBlur() {
                        this._runOperation((e)=>e.handleBlur());
                    }
                    handleFocus() {
                        this._runOperation((e)=>e.handleFocus());
                    }
                    handleSelectionChanged(e, t, i = !1) {
                        this._runOperation((s)=>s.handleSelectionChanged(e, t, i)), this._themeService.colors.selectionForeground && this._onRequestRedraw.fire({
                            start: 0,
                            end: this._bufferService.rows - 1
                        });
                    }
                    handleCursorMove() {
                        this._runOperation((e)=>e.handleCursorMove());
                    }
                    clear() {
                        this._runOperation((e)=>e.reset());
                    }
                    _runOperation(e) {
                        for (const t of this._renderLayers)e(t);
                    }
                    renderRows(e, t) {
                        for (const i of this._renderLayers)i.handleGridChanged(e, t);
                    }
                    clearTextureAtlas() {
                        for (const e of this._renderLayers)e.clearTextureAtlas();
                    }
                    _updateDimensions() {
                        if (!this._charSizeService.hasValidSize) return;
                        const e = this._coreBrowserService.dpr;
                        this.dimensions.device.char.width = Math.floor(this._charSizeService.width * e), this.dimensions.device.char.height = Math.ceil(this._charSizeService.height * e), this.dimensions.device.cell.height = Math.floor(this.dimensions.device.char.height * this._optionsService.rawOptions.lineHeight), this.dimensions.device.char.top = 1 === this._optionsService.rawOptions.lineHeight ? 0 : Math.round((this.dimensions.device.cell.height - this.dimensions.device.char.height) / 2), this.dimensions.device.cell.width = this.dimensions.device.char.width + Math.round(this._optionsService.rawOptions.letterSpacing), this.dimensions.device.char.left = Math.floor(this._optionsService.rawOptions.letterSpacing / 2), this.dimensions.device.canvas.height = this._bufferService.rows * this.dimensions.device.cell.height, this.dimensions.device.canvas.width = this._bufferService.cols * this.dimensions.device.cell.width, this.dimensions.css.canvas.height = Math.round(this.dimensions.device.canvas.height / e), this.dimensions.css.canvas.width = Math.round(this.dimensions.device.canvas.width / e), this.dimensions.css.cell.height = this.dimensions.css.canvas.height / this._bufferService.rows, this.dimensions.css.cell.width = this.dimensions.css.canvas.width / this._bufferService.cols;
                    }
                    _setCanvasDevicePixelDimensions(e, t) {
                        this.dimensions.device.canvas.height = t, this.dimensions.device.canvas.width = e;
                        for (const e of this._renderLayers)e.resize(this.dimensions);
                        this._requestRedrawViewport();
                    }
                    _requestRedrawViewport() {
                        this._onRequestRedraw.fire({
                            start: 0,
                            end: this._bufferService.rows - 1
                        });
                    }
                }
                t.CanvasRenderer = _;
            },
            873: (e, t, i)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.CursorRenderLayer = void 0;
                const s = i(903), r = i(782), o = i(859), n = i(399);
                class a extends s.BaseRenderLayer {
                    constructor(e, t, i, s, n, a, h, l, c, d){
                        super(e, t, "cursor", i, !0, d, n, a, c, l), this._onRequestRedraw = s, this._coreService = h, this._cell = new r.CellData, this._state = {
                            x: 0,
                            y: 0,
                            isFocused: !1,
                            style: "",
                            width: 0
                        }, this._cursorRenderers = {
                            bar: this._renderBarCursor.bind(this),
                            block: this._renderBlockCursor.bind(this),
                            underline: this._renderUnderlineCursor.bind(this)
                        }, this.register(a.onOptionChange(()=>this._handleOptionsChanged())), this.register((0, o.toDisposable)(()=>{
                            var e;
                            null === (e = this._cursorBlinkStateManager) || void 0 === e || e.dispose(), this._cursorBlinkStateManager = void 0;
                        }));
                    }
                    resize(e) {
                        super.resize(e), this._state = {
                            x: 0,
                            y: 0,
                            isFocused: !1,
                            style: "",
                            width: 0
                        };
                    }
                    reset() {
                        var e;
                        this._clearCursor(), null === (e = this._cursorBlinkStateManager) || void 0 === e || e.restartBlinkAnimation(), this._handleOptionsChanged();
                    }
                    handleBlur() {
                        var e;
                        null === (e = this._cursorBlinkStateManager) || void 0 === e || e.pause(), this._onRequestRedraw.fire({
                            start: this._bufferService.buffer.y,
                            end: this._bufferService.buffer.y
                        });
                    }
                    handleFocus() {
                        var e;
                        null === (e = this._cursorBlinkStateManager) || void 0 === e || e.resume(), this._onRequestRedraw.fire({
                            start: this._bufferService.buffer.y,
                            end: this._bufferService.buffer.y
                        });
                    }
                    _handleOptionsChanged() {
                        var e;
                        this._optionsService.rawOptions.cursorBlink ? this._cursorBlinkStateManager || (this._cursorBlinkStateManager = new h(this._coreBrowserService.isFocused, ()=>{
                            this._render(!0);
                        }, this._coreBrowserService)) : (null === (e = this._cursorBlinkStateManager) || void 0 === e || e.dispose(), this._cursorBlinkStateManager = void 0), this._onRequestRedraw.fire({
                            start: this._bufferService.buffer.y,
                            end: this._bufferService.buffer.y
                        });
                    }
                    handleCursorMove() {
                        var e;
                        null === (e = this._cursorBlinkStateManager) || void 0 === e || e.restartBlinkAnimation();
                    }
                    handleGridChanged(e, t) {
                        !this._cursorBlinkStateManager || this._cursorBlinkStateManager.isPaused ? this._render(!1) : this._cursorBlinkStateManager.restartBlinkAnimation();
                    }
                    _render(e) {
                        if (!this._coreService.isCursorInitialized || this._coreService.isCursorHidden) return void this._clearCursor();
                        const t = this._bufferService.buffer.ybase + this._bufferService.buffer.y, i = t - this._bufferService.buffer.ydisp;
                        if (i < 0 || i >= this._bufferService.rows) return void this._clearCursor();
                        const s = Math.min(this._bufferService.buffer.x, this._bufferService.cols - 1);
                        if (this._bufferService.buffer.lines.get(t).loadCell(s, this._cell), void 0 !== this._cell.content) {
                            if (!this._coreBrowserService.isFocused) {
                                this._clearCursor(), this._ctx.save(), this._ctx.fillStyle = this._themeService.colors.cursor.css;
                                const e = this._optionsService.rawOptions.cursorStyle;
                                return this._renderBlurCursor(s, i, this._cell), this._ctx.restore(), this._state.x = s, this._state.y = i, this._state.isFocused = !1, this._state.style = e, void (this._state.width = this._cell.getWidth());
                            }
                            if (!this._cursorBlinkStateManager || this._cursorBlinkStateManager.isCursorVisible) {
                                if (this._state) {
                                    if (this._state.x === s && this._state.y === i && this._state.isFocused === this._coreBrowserService.isFocused && this._state.style === this._optionsService.rawOptions.cursorStyle && this._state.width === this._cell.getWidth()) return;
                                    this._clearCursor();
                                }
                                this._ctx.save(), this._cursorRenderers[this._optionsService.rawOptions.cursorStyle || "block"](s, i, this._cell), this._ctx.restore(), this._state.x = s, this._state.y = i, this._state.isFocused = !1, this._state.style = this._optionsService.rawOptions.cursorStyle, this._state.width = this._cell.getWidth();
                            } else this._clearCursor();
                        }
                    }
                    _clearCursor() {
                        this._state && (n.isFirefox || this._coreBrowserService.dpr < 1 ? this._clearAll() : this._clearCells(this._state.x, this._state.y, this._state.width, 1), this._state = {
                            x: 0,
                            y: 0,
                            isFocused: !1,
                            style: "",
                            width: 0
                        });
                    }
                    _renderBarCursor(e, t, i) {
                        this._ctx.save(), this._ctx.fillStyle = this._themeService.colors.cursor.css, this._fillLeftLineAtCell(e, t, this._optionsService.rawOptions.cursorWidth), this._ctx.restore();
                    }
                    _renderBlockCursor(e, t, i) {
                        this._ctx.save(), this._ctx.fillStyle = this._themeService.colors.cursor.css, this._fillCells(e, t, i.getWidth(), 1), this._ctx.fillStyle = this._themeService.colors.cursorAccent.css, this._fillCharTrueColor(i, e, t), this._ctx.restore();
                    }
                    _renderUnderlineCursor(e, t, i) {
                        this._ctx.save(), this._ctx.fillStyle = this._themeService.colors.cursor.css, this._fillBottomLineAtCells(e, t), this._ctx.restore();
                    }
                    _renderBlurCursor(e, t, i) {
                        this._ctx.save(), this._ctx.strokeStyle = this._themeService.colors.cursor.css, this._strokeRectAtCell(e, t, i.getWidth(), 1), this._ctx.restore();
                    }
                }
                t.CursorRenderLayer = a;
                class h {
                    constructor(e, t, i){
                        this._renderCallback = t, this._coreBrowserService = i, this.isCursorVisible = !0, e && this._restartInterval();
                    }
                    get isPaused() {
                        return !(this._blinkStartTimeout || this._blinkInterval);
                    }
                    dispose() {
                        this._blinkInterval && (this._coreBrowserService.window.clearInterval(this._blinkInterval), this._blinkInterval = void 0), this._blinkStartTimeout && (this._coreBrowserService.window.clearTimeout(this._blinkStartTimeout), this._blinkStartTimeout = void 0), this._animationFrame && (this._coreBrowserService.window.cancelAnimationFrame(this._animationFrame), this._animationFrame = void 0);
                    }
                    restartBlinkAnimation() {
                        this.isPaused || (this._animationTimeRestarted = Date.now(), this.isCursorVisible = !0, this._animationFrame || (this._animationFrame = this._coreBrowserService.window.requestAnimationFrame(()=>{
                            this._renderCallback(), this._animationFrame = void 0;
                        })));
                    }
                    _restartInterval(e = 600) {
                        this._blinkInterval && (this._coreBrowserService.window.clearInterval(this._blinkInterval), this._blinkInterval = void 0), this._blinkStartTimeout = this._coreBrowserService.window.setTimeout(()=>{
                            if (this._animationTimeRestarted) {
                                const e = 600 - (Date.now() - this._animationTimeRestarted);
                                if (this._animationTimeRestarted = void 0, e > 0) return void this._restartInterval(e);
                            }
                            this.isCursorVisible = !1, this._animationFrame = this._coreBrowserService.window.requestAnimationFrame(()=>{
                                this._renderCallback(), this._animationFrame = void 0;
                            }), this._blinkInterval = this._coreBrowserService.window.setInterval(()=>{
                                if (this._animationTimeRestarted) {
                                    const e = 600 - (Date.now() - this._animationTimeRestarted);
                                    return this._animationTimeRestarted = void 0, void this._restartInterval(e);
                                }
                                this.isCursorVisible = !this.isCursorVisible, this._animationFrame = this._coreBrowserService.window.requestAnimationFrame(()=>{
                                    this._renderCallback(), this._animationFrame = void 0;
                                });
                            }, 600);
                        }, e);
                    }
                    pause() {
                        this.isCursorVisible = !0, this._blinkInterval && (this._coreBrowserService.window.clearInterval(this._blinkInterval), this._blinkInterval = void 0), this._blinkStartTimeout && (this._coreBrowserService.window.clearTimeout(this._blinkStartTimeout), this._blinkStartTimeout = void 0), this._animationFrame && (this._coreBrowserService.window.cancelAnimationFrame(this._animationFrame), this._animationFrame = void 0);
                    }
                    resume() {
                        this.pause(), this._animationTimeRestarted = void 0, this._restartInterval(), this.restartBlinkAnimation();
                    }
                }
            },
            574: (e, t)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.GridCache = void 0, t.GridCache = class {
                    constructor(){
                        this.cache = [];
                    }
                    resize(e, t) {
                        for(let i = 0; i < e; i++){
                            this.cache.length <= i && this.cache.push([]);
                            for(let e = this.cache[i].length; e < t; e++)this.cache[i].push(void 0);
                            this.cache[i].length = t;
                        }
                        this.cache.length = e;
                    }
                    clear() {
                        for(let e = 0; e < this.cache.length; e++)for(let t = 0; t < this.cache[e].length; t++)this.cache[e][t] = void 0;
                    }
                };
            },
            43: (e, t, i)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.LinkRenderLayer = void 0;
                const s = i(903), r = i(237), o = i(197);
                class n extends s.BaseRenderLayer {
                    constructor(e, t, i, s, r, o, n, a, h){
                        super(e, t, "link", i, !0, h, r, o, n, a), this.register(s.onShowLinkUnderline((e)=>this._handleShowLinkUnderline(e))), this.register(s.onHideLinkUnderline((e)=>this._handleHideLinkUnderline(e)));
                    }
                    resize(e) {
                        super.resize(e), this._state = void 0;
                    }
                    reset() {
                        this._clearCurrentLink();
                    }
                    _clearCurrentLink() {
                        if (this._state) {
                            this._clearCells(this._state.x1, this._state.y1, this._state.cols - this._state.x1, 1);
                            const e = this._state.y2 - this._state.y1 - 1;
                            e > 0 && this._clearCells(0, this._state.y1 + 1, this._state.cols, e), this._clearCells(0, this._state.y2, this._state.x2, 1), this._state = void 0;
                        }
                    }
                    _handleShowLinkUnderline(e) {
                        if (e.fg === r.INVERTED_DEFAULT_COLOR ? this._ctx.fillStyle = this._themeService.colors.background.css : e.fg && (0, o.is256Color)(e.fg) ? this._ctx.fillStyle = this._themeService.colors.ansi[e.fg].css : this._ctx.fillStyle = this._themeService.colors.foreground.css, e.y1 === e.y2) this._fillBottomLineAtCells(e.x1, e.y1, e.x2 - e.x1);
                        else {
                            this._fillBottomLineAtCells(e.x1, e.y1, e.cols - e.x1);
                            for(let t = e.y1 + 1; t < e.y2; t++)this._fillBottomLineAtCells(0, t, e.cols);
                            this._fillBottomLineAtCells(0, e.y2, e.x2);
                        }
                        this._state = e;
                    }
                    _handleHideLinkUnderline(e) {
                        this._clearCurrentLink();
                    }
                }
                t.LinkRenderLayer = n;
            },
            630: (e, t, i)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.SelectionRenderLayer = void 0;
                const s = i(903);
                class r extends s.BaseRenderLayer {
                    constructor(e, t, i, s, r, o, n, a){
                        super(e, t, "selection", i, !0, a, s, n, o, r), this._clearState();
                    }
                    _clearState() {
                        this._state = {
                            start: void 0,
                            end: void 0,
                            columnSelectMode: void 0,
                            ydisp: void 0
                        };
                    }
                    resize(e) {
                        super.resize(e), this._selectionModel.selectionStart && this._selectionModel.selectionEnd && (this._clearState(), this._redrawSelection(this._selectionModel.selectionStart, this._selectionModel.selectionEnd, this._selectionModel.columnSelectMode));
                    }
                    reset() {
                        this._state.start && this._state.end && (this._clearState(), this._clearAll());
                    }
                    handleBlur() {
                        this.reset(), this._redrawSelection(this._selectionModel.selectionStart, this._selectionModel.selectionEnd, this._selectionModel.columnSelectMode);
                    }
                    handleFocus() {
                        this.reset(), this._redrawSelection(this._selectionModel.selectionStart, this._selectionModel.selectionEnd, this._selectionModel.columnSelectMode);
                    }
                    handleSelectionChanged(e, t, i) {
                        super.handleSelectionChanged(e, t, i), this._redrawSelection(e, t, i);
                    }
                    _redrawSelection(e, t, i) {
                        if (!this._didStateChange(e, t, i, this._bufferService.buffer.ydisp)) return;
                        if (this._clearAll(), !e || !t) return void this._clearState();
                        const s = e[1] - this._bufferService.buffer.ydisp, r = t[1] - this._bufferService.buffer.ydisp, o = Math.max(s, 0), n = Math.min(r, this._bufferService.rows - 1);
                        if (o >= this._bufferService.rows || n < 0) this._state.ydisp = this._bufferService.buffer.ydisp;
                        else {
                            if (this._ctx.fillStyle = (this._coreBrowserService.isFocused ? this._themeService.colors.selectionBackgroundTransparent : this._themeService.colors.selectionInactiveBackgroundTransparent).css, i) {
                                const i = e[0], s = t[0] - i, r = n - o + 1;
                                this._fillCells(i, o, s, r);
                            } else {
                                const i = s === o ? e[0] : 0, a = o === r ? t[0] : this._bufferService.cols;
                                this._fillCells(i, o, a - i, 1);
                                const h = Math.max(n - o - 1, 0);
                                if (this._fillCells(0, o + 1, this._bufferService.cols, h), o !== n) {
                                    const e = r === n ? t[0] : this._bufferService.cols;
                                    this._fillCells(0, n, e, 1);
                                }
                            }
                            this._state.start = [
                                e[0],
                                e[1]
                            ], this._state.end = [
                                t[0],
                                t[1]
                            ], this._state.columnSelectMode = i, this._state.ydisp = this._bufferService.buffer.ydisp;
                        }
                    }
                    _didStateChange(e, t, i, s) {
                        return !this._areCoordinatesEqual(e, this._state.start) || !this._areCoordinatesEqual(t, this._state.end) || i !== this._state.columnSelectMode || s !== this._state.ydisp;
                    }
                    _areCoordinatesEqual(e, t) {
                        return !(!e || !t) && e[0] === t[0] && e[1] === t[1];
                    }
                }
                t.SelectionRenderLayer = r;
            },
            744: (e, t, i)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.TextRenderLayer = void 0;
                const s = i(574), r = i(903), o = i(147), n = i(855), a = i(782), h = i(577);
                class l extends r.BaseRenderLayer {
                    constructor(e, t, i, r, o, n, h, l, c, d){
                        super(e, t, "text", i, r, d, o, n, l, c), this._characterJoinerService = h, this._characterWidth = 0, this._characterFont = "", this._characterOverlapCache = {}, this._workCell = new a.CellData, this._state = new s.GridCache, this.register(n.onSpecificOptionChange("allowTransparency", (e)=>this._setTransparency(e)));
                    }
                    resize(e) {
                        super.resize(e);
                        const t = this._getFont(!1, !1);
                        this._characterWidth === e.device.char.width && this._characterFont === t || (this._characterWidth = e.device.char.width, this._characterFont = t, this._characterOverlapCache = {}), this._state.clear(), this._state.resize(this._bufferService.cols, this._bufferService.rows);
                    }
                    reset() {
                        this._state.clear(), this._clearAll();
                    }
                    _forEachCell(e, t, i) {
                        for(let s = e; s <= t; s++){
                            const e = s + this._bufferService.buffer.ydisp, t = this._bufferService.buffer.lines.get(e), r = this._characterJoinerService.getJoinedCharacters(e);
                            for(let e = 0; e < this._bufferService.cols; e++){
                                t.loadCell(e, this._workCell);
                                let o = this._workCell, a = !1, l = e;
                                if (0 !== o.getWidth()) {
                                    if (r.length > 0 && e === r[0][0]) {
                                        a = !0;
                                        const e = r.shift();
                                        o = new h.JoinedCellData(this._workCell, t.translateToString(!0, e[0], e[1]), e[1] - e[0]), l = e[1] - 1;
                                    }
                                    !a && this._isOverlapping(o) && l < t.length - 1 && t.getCodePoint(l + 1) === n.NULL_CELL_CODE && (o.content &= -12582913, o.content |= 8388608), i(o, e, s), e = l;
                                }
                            }
                        }
                    }
                    _drawBackground(e, t) {
                        const i = this._ctx, s = this._bufferService.cols;
                        let r = 0, n = 0, a = null;
                        i.save(), this._forEachCell(e, t, (e, t, h)=>{
                            let l = null;
                            e.isInverse() ? l = e.isFgDefault() ? this._themeService.colors.foreground.css : e.isFgRGB() ? `rgb(${o.AttributeData.toColorRGB(e.getFgColor()).join(",")})` : this._themeService.colors.ansi[e.getFgColor()].css : e.isBgRGB() ? l = `rgb(${o.AttributeData.toColorRGB(e.getBgColor()).join(",")})` : e.isBgPalette() && (l = this._themeService.colors.ansi[e.getBgColor()].css);
                            let c = !1;
                            this._decorationService.forEachDecorationAtCell(t, this._bufferService.buffer.ydisp + h, void 0, (e)=>{
                                "top" !== e.options.layer && c || (e.backgroundColorRGB && (l = e.backgroundColorRGB.css), c = "top" === e.options.layer);
                            }), null === a && (r = t, n = h), h !== n ? (i.fillStyle = a || "", this._fillCells(r, n, s - r, 1), r = t, n = h) : a !== l && (i.fillStyle = a || "", this._fillCells(r, n, t - r, 1), r = t, n = h), a = l;
                        }), null !== a && (i.fillStyle = a, this._fillCells(r, n, s - r, 1)), i.restore();
                    }
                    _drawForeground(e, t) {
                        this._forEachCell(e, t, (e, t, i)=>this._drawChars(e, t, i));
                    }
                    handleGridChanged(e, t) {
                        0 !== this._state.cache.length && (this._charAtlas && this._charAtlas.beginFrame(), this._clearCells(0, e, this._bufferService.cols, t - e + 1), this._drawBackground(e, t), this._drawForeground(e, t));
                    }
                    _isOverlapping(e) {
                        if (1 !== e.getWidth()) return !1;
                        if (e.getCode() < 256) return !1;
                        const t = e.getChars();
                        if (this._characterOverlapCache.hasOwnProperty(t)) return this._characterOverlapCache[t];
                        this._ctx.save(), this._ctx.font = this._characterFont;
                        const i = Math.floor(this._ctx.measureText(t).width) > this._characterWidth;
                        return this._ctx.restore(), this._characterOverlapCache[t] = i, i;
                    }
                }
                t.TextRenderLayer = l;
            },
            274: (e, t)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.CellColorResolver = void 0;
                let i, s = 0, r = 0, o = !1, n = !1, a = !1;
                t.CellColorResolver = class {
                    constructor(e, t, i, s, r){
                        this._terminal = e, this._selectionRenderModel = t, this._decorationService = i, this._coreBrowserService = s, this._themeService = r, this.result = {
                            fg: 0,
                            bg: 0,
                            ext: 0
                        };
                    }
                    resolve(e, t, h) {
                        this.result.bg = e.bg, this.result.fg = e.fg, this.result.ext = 268435456 & e.bg ? e.extended.ext : 0, r = 0, s = 0, n = !1, o = !1, a = !1, i = this._themeService.colors, this._decorationService.forEachDecorationAtCell(t, h, "bottom", (e)=>{
                            e.backgroundColorRGB && (r = e.backgroundColorRGB.rgba >> 8 & 16777215, n = !0), e.foregroundColorRGB && (s = e.foregroundColorRGB.rgba >> 8 & 16777215, o = !0);
                        }), a = this._selectionRenderModel.isCellSelected(this._terminal, t, h), a && (r = (this._coreBrowserService.isFocused ? i.selectionBackgroundOpaque : i.selectionInactiveBackgroundOpaque).rgba >> 8 & 16777215, n = !0, i.selectionForeground && (s = i.selectionForeground.rgba >> 8 & 16777215, o = !0)), this._decorationService.forEachDecorationAtCell(t, h, "top", (e)=>{
                            e.backgroundColorRGB && (r = e.backgroundColorRGB.rgba >> 8 & 16777215, n = !0), e.foregroundColorRGB && (s = e.foregroundColorRGB.rgba >> 8 & 16777215, o = !0);
                        }), n && (r = a ? -16777216 & e.bg & -134217729 | r | 50331648 : -16777216 & e.bg | r | 50331648), o && (s = -16777216 & e.fg & -67108865 | s | 50331648), 67108864 & this.result.fg && (n && !o && (s = 0 == (50331648 & this.result.bg) ? -134217728 & this.result.fg | 16777215 & i.background.rgba >> 8 | 50331648 : -134217728 & this.result.fg | 67108863 & this.result.bg, o = !0), !n && o && (r = 0 == (50331648 & this.result.fg) ? -67108864 & this.result.bg | 16777215 & i.foreground.rgba >> 8 | 50331648 : -67108864 & this.result.bg | 67108863 & this.result.fg, n = !0)), i = void 0, this.result.bg = n ? r : this.result.bg, this.result.fg = o ? s : this.result.fg;
                    }
                };
            },
            627: (e, t, i)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.removeTerminalFromCache = t.acquireTextureAtlas = void 0;
                const s = i(509), r = i(197), o = [];
                t.acquireTextureAtlas = function(e, t, i, n, a, h, l, c) {
                    const d = (0, r.generateConfig)(n, a, h, l, t, i, c);
                    for(let t = 0; t < o.length; t++){
                        const i = o[t], s = i.ownedBy.indexOf(e);
                        if (s >= 0) {
                            if ((0, r.configEquals)(i.config, d)) return i.atlas;
                            1 === i.ownedBy.length ? (i.atlas.dispose(), o.splice(t, 1)) : i.ownedBy.splice(s, 1);
                            break;
                        }
                    }
                    for(let t = 0; t < o.length; t++){
                        const i = o[t];
                        if ((0, r.configEquals)(i.config, d)) return i.ownedBy.push(e), i.atlas;
                    }
                    const _ = e._core, u = {
                        atlas: new s.TextureAtlas(document, d, _.unicodeService),
                        config: d,
                        ownedBy: [
                            e
                        ]
                    };
                    return o.push(u), u.atlas;
                }, t.removeTerminalFromCache = function(e) {
                    for(let t = 0; t < o.length; t++){
                        const i = o[t].ownedBy.indexOf(e);
                        if (-1 !== i) {
                            1 === o[t].ownedBy.length ? (o[t].atlas.dispose(), o.splice(t, 1)) : o[t].ownedBy.splice(i, 1);
                            break;
                        }
                    }
                };
            },
            197: (e, t, i)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.is256Color = t.configEquals = t.generateConfig = void 0;
                const s = i(160);
                t.generateConfig = function(e, t, i, r, o, n, a) {
                    const h = {
                        foreground: n.foreground,
                        background: n.background,
                        cursor: s.NULL_COLOR,
                        cursorAccent: s.NULL_COLOR,
                        selectionForeground: s.NULL_COLOR,
                        selectionBackgroundTransparent: s.NULL_COLOR,
                        selectionBackgroundOpaque: s.NULL_COLOR,
                        selectionInactiveBackgroundTransparent: s.NULL_COLOR,
                        selectionInactiveBackgroundOpaque: s.NULL_COLOR,
                        ansi: n.ansi.slice(),
                        contrastCache: n.contrastCache
                    };
                    return {
                        customGlyphs: o.customGlyphs,
                        devicePixelRatio: a,
                        letterSpacing: o.letterSpacing,
                        lineHeight: o.lineHeight,
                        deviceCellWidth: e,
                        deviceCellHeight: t,
                        deviceCharWidth: i,
                        deviceCharHeight: r,
                        fontFamily: o.fontFamily,
                        fontSize: o.fontSize,
                        fontWeight: o.fontWeight,
                        fontWeightBold: o.fontWeightBold,
                        allowTransparency: o.allowTransparency,
                        drawBoldTextInBrightColors: o.drawBoldTextInBrightColors,
                        minimumContrastRatio: o.minimumContrastRatio,
                        colors: h
                    };
                }, t.configEquals = function(e, t) {
                    for(let i = 0; i < e.colors.ansi.length; i++)if (e.colors.ansi[i].rgba !== t.colors.ansi[i].rgba) return !1;
                    return e.devicePixelRatio === t.devicePixelRatio && e.customGlyphs === t.customGlyphs && e.lineHeight === t.lineHeight && e.letterSpacing === t.letterSpacing && e.fontFamily === t.fontFamily && e.fontSize === t.fontSize && e.fontWeight === t.fontWeight && e.fontWeightBold === t.fontWeightBold && e.allowTransparency === t.allowTransparency && e.deviceCharWidth === t.deviceCharWidth && e.deviceCharHeight === t.deviceCharHeight && e.drawBoldTextInBrightColors === t.drawBoldTextInBrightColors && e.minimumContrastRatio === t.minimumContrastRatio && e.colors.foreground.rgba === t.colors.foreground.rgba && e.colors.background.rgba === t.colors.background.rgba;
                }, t.is256Color = function(e) {
                    return 16777216 == (50331648 & e) || 33554432 == (50331648 & e);
                };
            },
            237: (e, t, i)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.TEXT_BASELINE = t.DIM_OPACITY = t.INVERTED_DEFAULT_COLOR = void 0;
                const s = i(399);
                t.INVERTED_DEFAULT_COLOR = 257, t.DIM_OPACITY = .5, t.TEXT_BASELINE = s.isFirefox || s.isLegacyEdge ? "bottom" : "ideographic";
            },
            860: (e, t, i)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.tryDrawCustomChar = t.powerlineDefinitions = t.boxDrawingDefinitions = t.blockElementDefinitions = void 0;
                const s = i(374);
                t.blockElementDefinitions = {
                    "▀": [
                        {
                            x: 0,
                            y: 0,
                            w: 8,
                            h: 4
                        }
                    ],
                    "▁": [
                        {
                            x: 0,
                            y: 7,
                            w: 8,
                            h: 1
                        }
                    ],
                    "▂": [
                        {
                            x: 0,
                            y: 6,
                            w: 8,
                            h: 2
                        }
                    ],
                    "▃": [
                        {
                            x: 0,
                            y: 5,
                            w: 8,
                            h: 3
                        }
                    ],
                    "▄": [
                        {
                            x: 0,
                            y: 4,
                            w: 8,
                            h: 4
                        }
                    ],
                    "▅": [
                        {
                            x: 0,
                            y: 3,
                            w: 8,
                            h: 5
                        }
                    ],
                    "▆": [
                        {
                            x: 0,
                            y: 2,
                            w: 8,
                            h: 6
                        }
                    ],
                    "▇": [
                        {
                            x: 0,
                            y: 1,
                            w: 8,
                            h: 7
                        }
                    ],
                    "█": [
                        {
                            x: 0,
                            y: 0,
                            w: 8,
                            h: 8
                        }
                    ],
                    "▉": [
                        {
                            x: 0,
                            y: 0,
                            w: 7,
                            h: 8
                        }
                    ],
                    "▊": [
                        {
                            x: 0,
                            y: 0,
                            w: 6,
                            h: 8
                        }
                    ],
                    "▋": [
                        {
                            x: 0,
                            y: 0,
                            w: 5,
                            h: 8
                        }
                    ],
                    "▌": [
                        {
                            x: 0,
                            y: 0,
                            w: 4,
                            h: 8
                        }
                    ],
                    "▍": [
                        {
                            x: 0,
                            y: 0,
                            w: 3,
                            h: 8
                        }
                    ],
                    "▎": [
                        {
                            x: 0,
                            y: 0,
                            w: 2,
                            h: 8
                        }
                    ],
                    "▏": [
                        {
                            x: 0,
                            y: 0,
                            w: 1,
                            h: 8
                        }
                    ],
                    "▐": [
                        {
                            x: 4,
                            y: 0,
                            w: 4,
                            h: 8
                        }
                    ],
                    "▔": [
                        {
                            x: 0,
                            y: 0,
                            w: 8,
                            h: 1
                        }
                    ],
                    "▕": [
                        {
                            x: 7,
                            y: 0,
                            w: 1,
                            h: 8
                        }
                    ],
                    "▖": [
                        {
                            x: 0,
                            y: 4,
                            w: 4,
                            h: 4
                        }
                    ],
                    "▗": [
                        {
                            x: 4,
                            y: 4,
                            w: 4,
                            h: 4
                        }
                    ],
                    "▘": [
                        {
                            x: 0,
                            y: 0,
                            w: 4,
                            h: 4
                        }
                    ],
                    "▙": [
                        {
                            x: 0,
                            y: 0,
                            w: 4,
                            h: 8
                        },
                        {
                            x: 0,
                            y: 4,
                            w: 8,
                            h: 4
                        }
                    ],
                    "▚": [
                        {
                            x: 0,
                            y: 0,
                            w: 4,
                            h: 4
                        },
                        {
                            x: 4,
                            y: 4,
                            w: 4,
                            h: 4
                        }
                    ],
                    "▛": [
                        {
                            x: 0,
                            y: 0,
                            w: 4,
                            h: 8
                        },
                        {
                            x: 4,
                            y: 0,
                            w: 4,
                            h: 4
                        }
                    ],
                    "▜": [
                        {
                            x: 0,
                            y: 0,
                            w: 8,
                            h: 4
                        },
                        {
                            x: 4,
                            y: 0,
                            w: 4,
                            h: 8
                        }
                    ],
                    "▝": [
                        {
                            x: 4,
                            y: 0,
                            w: 4,
                            h: 4
                        }
                    ],
                    "▞": [
                        {
                            x: 4,
                            y: 0,
                            w: 4,
                            h: 4
                        },
                        {
                            x: 0,
                            y: 4,
                            w: 4,
                            h: 4
                        }
                    ],
                    "▟": [
                        {
                            x: 4,
                            y: 0,
                            w: 4,
                            h: 8
                        },
                        {
                            x: 0,
                            y: 4,
                            w: 8,
                            h: 4
                        }
                    ],
                    "\uD83E\uDF70": [
                        {
                            x: 1,
                            y: 0,
                            w: 1,
                            h: 8
                        }
                    ],
                    "\uD83E\uDF71": [
                        {
                            x: 2,
                            y: 0,
                            w: 1,
                            h: 8
                        }
                    ],
                    "\uD83E\uDF72": [
                        {
                            x: 3,
                            y: 0,
                            w: 1,
                            h: 8
                        }
                    ],
                    "\uD83E\uDF73": [
                        {
                            x: 4,
                            y: 0,
                            w: 1,
                            h: 8
                        }
                    ],
                    "\uD83E\uDF74": [
                        {
                            x: 5,
                            y: 0,
                            w: 1,
                            h: 8
                        }
                    ],
                    "\uD83E\uDF75": [
                        {
                            x: 6,
                            y: 0,
                            w: 1,
                            h: 8
                        }
                    ],
                    "\uD83E\uDF76": [
                        {
                            x: 0,
                            y: 1,
                            w: 8,
                            h: 1
                        }
                    ],
                    "\uD83E\uDF77": [
                        {
                            x: 0,
                            y: 2,
                            w: 8,
                            h: 1
                        }
                    ],
                    "\uD83E\uDF78": [
                        {
                            x: 0,
                            y: 3,
                            w: 8,
                            h: 1
                        }
                    ],
                    "\uD83E\uDF79": [
                        {
                            x: 0,
                            y: 4,
                            w: 8,
                            h: 1
                        }
                    ],
                    "\uD83E\uDF7A": [
                        {
                            x: 0,
                            y: 5,
                            w: 8,
                            h: 1
                        }
                    ],
                    "\uD83E\uDF7B": [
                        {
                            x: 0,
                            y: 6,
                            w: 8,
                            h: 1
                        }
                    ],
                    "\uD83E\uDF7C": [
                        {
                            x: 0,
                            y: 0,
                            w: 1,
                            h: 8
                        },
                        {
                            x: 0,
                            y: 7,
                            w: 8,
                            h: 1
                        }
                    ],
                    "\uD83E\uDF7D": [
                        {
                            x: 0,
                            y: 0,
                            w: 1,
                            h: 8
                        },
                        {
                            x: 0,
                            y: 0,
                            w: 8,
                            h: 1
                        }
                    ],
                    "\uD83E\uDF7E": [
                        {
                            x: 7,
                            y: 0,
                            w: 1,
                            h: 8
                        },
                        {
                            x: 0,
                            y: 0,
                            w: 8,
                            h: 1
                        }
                    ],
                    "\uD83E\uDF7F": [
                        {
                            x: 7,
                            y: 0,
                            w: 1,
                            h: 8
                        },
                        {
                            x: 0,
                            y: 7,
                            w: 8,
                            h: 1
                        }
                    ],
                    "\uD83E\uDF80": [
                        {
                            x: 0,
                            y: 0,
                            w: 8,
                            h: 1
                        },
                        {
                            x: 0,
                            y: 7,
                            w: 8,
                            h: 1
                        }
                    ],
                    "\uD83E\uDF81": [
                        {
                            x: 0,
                            y: 0,
                            w: 8,
                            h: 1
                        },
                        {
                            x: 0,
                            y: 2,
                            w: 8,
                            h: 1
                        },
                        {
                            x: 0,
                            y: 4,
                            w: 8,
                            h: 1
                        },
                        {
                            x: 0,
                            y: 7,
                            w: 8,
                            h: 1
                        }
                    ],
                    "\uD83E\uDF82": [
                        {
                            x: 0,
                            y: 0,
                            w: 8,
                            h: 2
                        }
                    ],
                    "\uD83E\uDF83": [
                        {
                            x: 0,
                            y: 0,
                            w: 8,
                            h: 3
                        }
                    ],
                    "\uD83E\uDF84": [
                        {
                            x: 0,
                            y: 0,
                            w: 8,
                            h: 5
                        }
                    ],
                    "\uD83E\uDF85": [
                        {
                            x: 0,
                            y: 0,
                            w: 8,
                            h: 6
                        }
                    ],
                    "\uD83E\uDF86": [
                        {
                            x: 0,
                            y: 0,
                            w: 8,
                            h: 7
                        }
                    ],
                    "\uD83E\uDF87": [
                        {
                            x: 6,
                            y: 0,
                            w: 2,
                            h: 8
                        }
                    ],
                    "\uD83E\uDF88": [
                        {
                            x: 5,
                            y: 0,
                            w: 3,
                            h: 8
                        }
                    ],
                    "\uD83E\uDF89": [
                        {
                            x: 3,
                            y: 0,
                            w: 5,
                            h: 8
                        }
                    ],
                    "\uD83E\uDF8A": [
                        {
                            x: 2,
                            y: 0,
                            w: 6,
                            h: 8
                        }
                    ],
                    "\uD83E\uDF8B": [
                        {
                            x: 1,
                            y: 0,
                            w: 7,
                            h: 8
                        }
                    ],
                    "\uD83E\uDF95": [
                        {
                            x: 0,
                            y: 0,
                            w: 2,
                            h: 2
                        },
                        {
                            x: 4,
                            y: 0,
                            w: 2,
                            h: 2
                        },
                        {
                            x: 2,
                            y: 2,
                            w: 2,
                            h: 2
                        },
                        {
                            x: 6,
                            y: 2,
                            w: 2,
                            h: 2
                        },
                        {
                            x: 0,
                            y: 4,
                            w: 2,
                            h: 2
                        },
                        {
                            x: 4,
                            y: 4,
                            w: 2,
                            h: 2
                        },
                        {
                            x: 2,
                            y: 6,
                            w: 2,
                            h: 2
                        },
                        {
                            x: 6,
                            y: 6,
                            w: 2,
                            h: 2
                        }
                    ],
                    "\uD83E\uDF96": [
                        {
                            x: 2,
                            y: 0,
                            w: 2,
                            h: 2
                        },
                        {
                            x: 6,
                            y: 0,
                            w: 2,
                            h: 2
                        },
                        {
                            x: 0,
                            y: 2,
                            w: 2,
                            h: 2
                        },
                        {
                            x: 4,
                            y: 2,
                            w: 2,
                            h: 2
                        },
                        {
                            x: 2,
                            y: 4,
                            w: 2,
                            h: 2
                        },
                        {
                            x: 6,
                            y: 4,
                            w: 2,
                            h: 2
                        },
                        {
                            x: 0,
                            y: 6,
                            w: 2,
                            h: 2
                        },
                        {
                            x: 4,
                            y: 6,
                            w: 2,
                            h: 2
                        }
                    ],
                    "\uD83E\uDF97": [
                        {
                            x: 0,
                            y: 2,
                            w: 8,
                            h: 2
                        },
                        {
                            x: 0,
                            y: 6,
                            w: 8,
                            h: 2
                        }
                    ]
                };
                const r = {
                    "░": [
                        [
                            1,
                            0,
                            0,
                            0
                        ],
                        [
                            0,
                            0,
                            0,
                            0
                        ],
                        [
                            0,
                            0,
                            1,
                            0
                        ],
                        [
                            0,
                            0,
                            0,
                            0
                        ]
                    ],
                    "▒": [
                        [
                            1,
                            0
                        ],
                        [
                            0,
                            0
                        ],
                        [
                            0,
                            1
                        ],
                        [
                            0,
                            0
                        ]
                    ],
                    "▓": [
                        [
                            0,
                            1
                        ],
                        [
                            1,
                            1
                        ],
                        [
                            1,
                            0
                        ],
                        [
                            1,
                            1
                        ]
                    ]
                };
                t.boxDrawingDefinitions = {
                    "─": {
                        1: "M0,.5 L1,.5"
                    },
                    "━": {
                        3: "M0,.5 L1,.5"
                    },
                    "│": {
                        1: "M.5,0 L.5,1"
                    },
                    "┃": {
                        3: "M.5,0 L.5,1"
                    },
                    "┌": {
                        1: "M0.5,1 L.5,.5 L1,.5"
                    },
                    "┏": {
                        3: "M0.5,1 L.5,.5 L1,.5"
                    },
                    "┐": {
                        1: "M0,.5 L.5,.5 L.5,1"
                    },
                    "┓": {
                        3: "M0,.5 L.5,.5 L.5,1"
                    },
                    "└": {
                        1: "M.5,0 L.5,.5 L1,.5"
                    },
                    "┗": {
                        3: "M.5,0 L.5,.5 L1,.5"
                    },
                    "┘": {
                        1: "M.5,0 L.5,.5 L0,.5"
                    },
                    "┛": {
                        3: "M.5,0 L.5,.5 L0,.5"
                    },
                    "├": {
                        1: "M.5,0 L.5,1 M.5,.5 L1,.5"
                    },
                    "┣": {
                        3: "M.5,0 L.5,1 M.5,.5 L1,.5"
                    },
                    "┤": {
                        1: "M.5,0 L.5,1 M.5,.5 L0,.5"
                    },
                    "┫": {
                        3: "M.5,0 L.5,1 M.5,.5 L0,.5"
                    },
                    "┬": {
                        1: "M0,.5 L1,.5 M.5,.5 L.5,1"
                    },
                    "┳": {
                        3: "M0,.5 L1,.5 M.5,.5 L.5,1"
                    },
                    "┴": {
                        1: "M0,.5 L1,.5 M.5,.5 L.5,0"
                    },
                    "┻": {
                        3: "M0,.5 L1,.5 M.5,.5 L.5,0"
                    },
                    "┼": {
                        1: "M0,.5 L1,.5 M.5,0 L.5,1"
                    },
                    "╋": {
                        3: "M0,.5 L1,.5 M.5,0 L.5,1"
                    },
                    "╴": {
                        1: "M.5,.5 L0,.5"
                    },
                    "╸": {
                        3: "M.5,.5 L0,.5"
                    },
                    "╵": {
                        1: "M.5,.5 L.5,0"
                    },
                    "╹": {
                        3: "M.5,.5 L.5,0"
                    },
                    "╶": {
                        1: "M.5,.5 L1,.5"
                    },
                    "╺": {
                        3: "M.5,.5 L1,.5"
                    },
                    "╷": {
                        1: "M.5,.5 L.5,1"
                    },
                    "╻": {
                        3: "M.5,.5 L.5,1"
                    },
                    "═": {
                        1: (e, t)=>`M0,${.5 - t} L1,${.5 - t} M0,${.5 + t} L1,${.5 + t}`
                    },
                    "║": {
                        1: (e, t)=>`M${.5 - e},0 L${.5 - e},1 M${.5 + e},0 L${.5 + e},1`
                    },
                    "╒": {
                        1: (e, t)=>`M.5,1 L.5,${.5 - t} L1,${.5 - t} M.5,${.5 + t} L1,${.5 + t}`
                    },
                    "╓": {
                        1: (e, t)=>`M${.5 - e},1 L${.5 - e},.5 L1,.5 M${.5 + e},.5 L${.5 + e},1`
                    },
                    "╔": {
                        1: (e, t)=>`M1,${.5 - t} L${.5 - e},${.5 - t} L${.5 - e},1 M1,${.5 + t} L${.5 + e},${.5 + t} L${.5 + e},1`
                    },
                    "╕": {
                        1: (e, t)=>`M0,${.5 - t} L.5,${.5 - t} L.5,1 M0,${.5 + t} L.5,${.5 + t}`
                    },
                    "╖": {
                        1: (e, t)=>`M${.5 + e},1 L${.5 + e},.5 L0,.5 M${.5 - e},.5 L${.5 - e},1`
                    },
                    "╗": {
                        1: (e, t)=>`M0,${.5 + t} L${.5 - e},${.5 + t} L${.5 - e},1 M0,${.5 - t} L${.5 + e},${.5 - t} L${.5 + e},1`
                    },
                    "╘": {
                        1: (e, t)=>`M.5,0 L.5,${.5 + t} L1,${.5 + t} M.5,${.5 - t} L1,${.5 - t}`
                    },
                    "╙": {
                        1: (e, t)=>`M1,.5 L${.5 - e},.5 L${.5 - e},0 M${.5 + e},.5 L${.5 + e},0`
                    },
                    "╚": {
                        1: (e, t)=>`M1,${.5 - t} L${.5 + e},${.5 - t} L${.5 + e},0 M1,${.5 + t} L${.5 - e},${.5 + t} L${.5 - e},0`
                    },
                    "╛": {
                        1: (e, t)=>`M0,${.5 + t} L.5,${.5 + t} L.5,0 M0,${.5 - t} L.5,${.5 - t}`
                    },
                    "╜": {
                        1: (e, t)=>`M0,.5 L${.5 + e},.5 L${.5 + e},0 M${.5 - e},.5 L${.5 - e},0`
                    },
                    "╝": {
                        1: (e, t)=>`M0,${.5 - t} L${.5 - e},${.5 - t} L${.5 - e},0 M0,${.5 + t} L${.5 + e},${.5 + t} L${.5 + e},0`
                    },
                    "╞": {
                        1: (e, t)=>`M.5,0 L.5,1 M.5,${.5 - t} L1,${.5 - t} M.5,${.5 + t} L1,${.5 + t}`
                    },
                    "╟": {
                        1: (e, t)=>`M${.5 - e},0 L${.5 - e},1 M${.5 + e},0 L${.5 + e},1 M${.5 + e},.5 L1,.5`
                    },
                    "╠": {
                        1: (e, t)=>`M${.5 - e},0 L${.5 - e},1 M1,${.5 + t} L${.5 + e},${.5 + t} L${.5 + e},1 M1,${.5 - t} L${.5 + e},${.5 - t} L${.5 + e},0`
                    },
                    "╡": {
                        1: (e, t)=>`M.5,0 L.5,1 M0,${.5 - t} L.5,${.5 - t} M0,${.5 + t} L.5,${.5 + t}`
                    },
                    "╢": {
                        1: (e, t)=>`M0,.5 L${.5 - e},.5 M${.5 - e},0 L${.5 - e},1 M${.5 + e},0 L${.5 + e},1`
                    },
                    "╣": {
                        1: (e, t)=>`M${.5 + e},0 L${.5 + e},1 M0,${.5 + t} L${.5 - e},${.5 + t} L${.5 - e},1 M0,${.5 - t} L${.5 - e},${.5 - t} L${.5 - e},0`
                    },
                    "╤": {
                        1: (e, t)=>`M0,${.5 - t} L1,${.5 - t} M0,${.5 + t} L1,${.5 + t} M.5,${.5 + t} L.5,1`
                    },
                    "╥": {
                        1: (e, t)=>`M0,.5 L1,.5 M${.5 - e},.5 L${.5 - e},1 M${.5 + e},.5 L${.5 + e},1`
                    },
                    "╦": {
                        1: (e, t)=>`M0,${.5 - t} L1,${.5 - t} M0,${.5 + t} L${.5 - e},${.5 + t} L${.5 - e},1 M1,${.5 + t} L${.5 + e},${.5 + t} L${.5 + e},1`
                    },
                    "╧": {
                        1: (e, t)=>`M.5,0 L.5,${.5 - t} M0,${.5 - t} L1,${.5 - t} M0,${.5 + t} L1,${.5 + t}`
                    },
                    "╨": {
                        1: (e, t)=>`M0,.5 L1,.5 M${.5 - e},.5 L${.5 - e},0 M${.5 + e},.5 L${.5 + e},0`
                    },
                    "╩": {
                        1: (e, t)=>`M0,${.5 + t} L1,${.5 + t} M0,${.5 - t} L${.5 - e},${.5 - t} L${.5 - e},0 M1,${.5 - t} L${.5 + e},${.5 - t} L${.5 + e},0`
                    },
                    "╪": {
                        1: (e, t)=>`M.5,0 L.5,1 M0,${.5 - t} L1,${.5 - t} M0,${.5 + t} L1,${.5 + t}`
                    },
                    "╫": {
                        1: (e, t)=>`M0,.5 L1,.5 M${.5 - e},0 L${.5 - e},1 M${.5 + e},0 L${.5 + e},1`
                    },
                    "╬": {
                        1: (e, t)=>`M0,${.5 + t} L${.5 - e},${.5 + t} L${.5 - e},1 M1,${.5 + t} L${.5 + e},${.5 + t} L${.5 + e},1 M0,${.5 - t} L${.5 - e},${.5 - t} L${.5 - e},0 M1,${.5 - t} L${.5 + e},${.5 - t} L${.5 + e},0`
                    },
                    "╱": {
                        1: "M1,0 L0,1"
                    },
                    "╲": {
                        1: "M0,0 L1,1"
                    },
                    "╳": {
                        1: "M1,0 L0,1 M0,0 L1,1"
                    },
                    "╼": {
                        1: "M.5,.5 L0,.5",
                        3: "M.5,.5 L1,.5"
                    },
                    "╽": {
                        1: "M.5,.5 L.5,0",
                        3: "M.5,.5 L.5,1"
                    },
                    "╾": {
                        1: "M.5,.5 L1,.5",
                        3: "M.5,.5 L0,.5"
                    },
                    "╿": {
                        1: "M.5,.5 L.5,1",
                        3: "M.5,.5 L.5,0"
                    },
                    "┍": {
                        1: "M.5,.5 L.5,1",
                        3: "M.5,.5 L1,.5"
                    },
                    "┎": {
                        1: "M.5,.5 L1,.5",
                        3: "M.5,.5 L.5,1"
                    },
                    "┑": {
                        1: "M.5,.5 L.5,1",
                        3: "M.5,.5 L0,.5"
                    },
                    "┒": {
                        1: "M.5,.5 L0,.5",
                        3: "M.5,.5 L.5,1"
                    },
                    "┕": {
                        1: "M.5,.5 L.5,0",
                        3: "M.5,.5 L1,.5"
                    },
                    "┖": {
                        1: "M.5,.5 L1,.5",
                        3: "M.5,.5 L.5,0"
                    },
                    "┙": {
                        1: "M.5,.5 L.5,0",
                        3: "M.5,.5 L0,.5"
                    },
                    "┚": {
                        1: "M.5,.5 L0,.5",
                        3: "M.5,.5 L.5,0"
                    },
                    "┝": {
                        1: "M.5,0 L.5,1",
                        3: "M.5,.5 L1,.5"
                    },
                    "┞": {
                        1: "M0.5,1 L.5,.5 L1,.5",
                        3: "M.5,.5 L.5,0"
                    },
                    "┟": {
                        1: "M.5,0 L.5,.5 L1,.5",
                        3: "M.5,.5 L.5,1"
                    },
                    "┠": {
                        1: "M.5,.5 L1,.5",
                        3: "M.5,0 L.5,1"
                    },
                    "┡": {
                        1: "M.5,.5 L.5,1",
                        3: "M.5,0 L.5,.5 L1,.5"
                    },
                    "┢": {
                        1: "M.5,.5 L.5,0",
                        3: "M0.5,1 L.5,.5 L1,.5"
                    },
                    "┥": {
                        1: "M.5,0 L.5,1",
                        3: "M.5,.5 L0,.5"
                    },
                    "┦": {
                        1: "M0,.5 L.5,.5 L.5,1",
                        3: "M.5,.5 L.5,0"
                    },
                    "┧": {
                        1: "M.5,0 L.5,.5 L0,.5",
                        3: "M.5,.5 L.5,1"
                    },
                    "┨": {
                        1: "M.5,.5 L0,.5",
                        3: "M.5,0 L.5,1"
                    },
                    "┩": {
                        1: "M.5,.5 L.5,1",
                        3: "M.5,0 L.5,.5 L0,.5"
                    },
                    "┪": {
                        1: "M.5,.5 L.5,0",
                        3: "M0,.5 L.5,.5 L.5,1"
                    },
                    "┭": {
                        1: "M0.5,1 L.5,.5 L1,.5",
                        3: "M.5,.5 L0,.5"
                    },
                    "┮": {
                        1: "M0,.5 L.5,.5 L.5,1",
                        3: "M.5,.5 L1,.5"
                    },
                    "┯": {
                        1: "M.5,.5 L.5,1",
                        3: "M0,.5 L1,.5"
                    },
                    "┰": {
                        1: "M0,.5 L1,.5",
                        3: "M.5,.5 L.5,1"
                    },
                    "┱": {
                        1: "M.5,.5 L1,.5",
                        3: "M0,.5 L.5,.5 L.5,1"
                    },
                    "┲": {
                        1: "M.5,.5 L0,.5",
                        3: "M0.5,1 L.5,.5 L1,.5"
                    },
                    "┵": {
                        1: "M.5,0 L.5,.5 L1,.5",
                        3: "M.5,.5 L0,.5"
                    },
                    "┶": {
                        1: "M.5,0 L.5,.5 L0,.5",
                        3: "M.5,.5 L1,.5"
                    },
                    "┷": {
                        1: "M.5,.5 L.5,0",
                        3: "M0,.5 L1,.5"
                    },
                    "┸": {
                        1: "M0,.5 L1,.5",
                        3: "M.5,.5 L.5,0"
                    },
                    "┹": {
                        1: "M.5,.5 L1,.5",
                        3: "M.5,0 L.5,.5 L0,.5"
                    },
                    "┺": {
                        1: "M.5,.5 L0,.5",
                        3: "M.5,0 L.5,.5 L1,.5"
                    },
                    "┽": {
                        1: "M.5,0 L.5,1 M.5,.5 L1,.5",
                        3: "M.5,.5 L0,.5"
                    },
                    "┾": {
                        1: "M.5,0 L.5,1 M.5,.5 L0,.5",
                        3: "M.5,.5 L1,.5"
                    },
                    "┿": {
                        1: "M.5,0 L.5,1",
                        3: "M0,.5 L1,.5"
                    },
                    "╀": {
                        1: "M0,.5 L1,.5 M.5,.5 L.5,1",
                        3: "M.5,.5 L.5,0"
                    },
                    "╁": {
                        1: "M.5,.5 L.5,0 M0,.5 L1,.5",
                        3: "M.5,.5 L.5,1"
                    },
                    "╂": {
                        1: "M0,.5 L1,.5",
                        3: "M.5,0 L.5,1"
                    },
                    "╃": {
                        1: "M0.5,1 L.5,.5 L1,.5",
                        3: "M.5,0 L.5,.5 L0,.5"
                    },
                    "╄": {
                        1: "M0,.5 L.5,.5 L.5,1",
                        3: "M.5,0 L.5,.5 L1,.5"
                    },
                    "╅": {
                        1: "M.5,0 L.5,.5 L1,.5",
                        3: "M0,.5 L.5,.5 L.5,1"
                    },
                    "╆": {
                        1: "M.5,0 L.5,.5 L0,.5",
                        3: "M0.5,1 L.5,.5 L1,.5"
                    },
                    "╇": {
                        1: "M.5,.5 L.5,1",
                        3: "M.5,.5 L.5,0 M0,.5 L1,.5"
                    },
                    "╈": {
                        1: "M.5,.5 L.5,0",
                        3: "M0,.5 L1,.5 M.5,.5 L.5,1"
                    },
                    "╉": {
                        1: "M.5,.5 L1,.5",
                        3: "M.5,0 L.5,1 M.5,.5 L0,.5"
                    },
                    "╊": {
                        1: "M.5,.5 L0,.5",
                        3: "M.5,0 L.5,1 M.5,.5 L1,.5"
                    },
                    "╌": {
                        1: "M.1,.5 L.4,.5 M.6,.5 L.9,.5"
                    },
                    "╍": {
                        3: "M.1,.5 L.4,.5 M.6,.5 L.9,.5"
                    },
                    "┄": {
                        1: "M.0667,.5 L.2667,.5 M.4,.5 L.6,.5 M.7333,.5 L.9333,.5"
                    },
                    "┅": {
                        3: "M.0667,.5 L.2667,.5 M.4,.5 L.6,.5 M.7333,.5 L.9333,.5"
                    },
                    "┈": {
                        1: "M.05,.5 L.2,.5 M.3,.5 L.45,.5 M.55,.5 L.7,.5 M.8,.5 L.95,.5"
                    },
                    "┉": {
                        3: "M.05,.5 L.2,.5 M.3,.5 L.45,.5 M.55,.5 L.7,.5 M.8,.5 L.95,.5"
                    },
                    "╎": {
                        1: "M.5,.1 L.5,.4 M.5,.6 L.5,.9"
                    },
                    "╏": {
                        3: "M.5,.1 L.5,.4 M.5,.6 L.5,.9"
                    },
                    "┆": {
                        1: "M.5,.0667 L.5,.2667 M.5,.4 L.5,.6 M.5,.7333 L.5,.9333"
                    },
                    "┇": {
                        3: "M.5,.0667 L.5,.2667 M.5,.4 L.5,.6 M.5,.7333 L.5,.9333"
                    },
                    "┊": {
                        1: "M.5,.05 L.5,.2 M.5,.3 L.5,.45 L.5,.55 M.5,.7 L.5,.95"
                    },
                    "┋": {
                        3: "M.5,.05 L.5,.2 M.5,.3 L.5,.45 L.5,.55 M.5,.7 L.5,.95"
                    },
                    "╭": {
                        1: (e, t)=>`M.5,1 L.5,${.5 + t / .15 * .5} C.5,${.5 + t / .15 * .5},.5,.5,1,.5`
                    },
                    "╮": {
                        1: (e, t)=>`M.5,1 L.5,${.5 + t / .15 * .5} C.5,${.5 + t / .15 * .5},.5,.5,0,.5`
                    },
                    "╯": {
                        1: (e, t)=>`M.5,0 L.5,${.5 - t / .15 * .5} C.5,${.5 - t / .15 * .5},.5,.5,0,.5`
                    },
                    "╰": {
                        1: (e, t)=>`M.5,0 L.5,${.5 - t / .15 * .5} C.5,${.5 - t / .15 * .5},.5,.5,1,.5`
                    }
                }, t.powerlineDefinitions = {
                    "": {
                        d: "M0,0 L1,.5 L0,1",
                        type: 0,
                        rightPadding: 2
                    },
                    "": {
                        d: "M-1,-.5 L1,.5 L-1,1.5",
                        type: 1,
                        leftPadding: 1,
                        rightPadding: 1
                    },
                    "": {
                        d: "M1,0 L0,.5 L1,1",
                        type: 0,
                        leftPadding: 2
                    },
                    "": {
                        d: "M2,-.5 L0,.5 L2,1.5",
                        type: 1,
                        leftPadding: 1,
                        rightPadding: 1
                    },
                    "": {
                        d: "M0,0 L0,1 C0.552,1,1,0.776,1,.5 C1,0.224,0.552,0,0,0",
                        type: 0,
                        rightPadding: 1
                    },
                    "": {
                        d: "M0,1 C0.552,1,1,0.776,1,.5 C1,0.224,0.552,0,0,0",
                        type: 1,
                        rightPadding: 1
                    },
                    "": {
                        d: "M1,0 L1,1 C0.448,1,0,0.776,0,.5 C0,0.224,0.448,0,1,0",
                        type: 0,
                        leftPadding: 1
                    },
                    "": {
                        d: "M1,1 C0.448,1,0,0.776,0,.5 C0,0.224,0.448,0,1,0",
                        type: 1,
                        leftPadding: 1
                    },
                    "": {
                        d: "M-.5,-.5 L1.5,1.5 L-.5,1.5",
                        type: 0
                    },
                    "": {
                        d: "M-.5,-.5 L1.5,1.5",
                        type: 1,
                        leftPadding: 1,
                        rightPadding: 1
                    },
                    "": {
                        d: "M1.5,-.5 L-.5,1.5 L1.5,1.5",
                        type: 0
                    },
                    "": {
                        d: "M1.5,-.5 L-.5,1.5 L-.5,-.5",
                        type: 0
                    },
                    "": {
                        d: "M1.5,-.5 L-.5,1.5",
                        type: 1,
                        leftPadding: 1,
                        rightPadding: 1
                    },
                    "": {
                        d: "M-.5,-.5 L1.5,1.5 L1.5,-.5",
                        type: 0
                    }
                }, t.powerlineDefinitions[""] = t.powerlineDefinitions[""], t.powerlineDefinitions[""] = t.powerlineDefinitions[""], t.tryDrawCustomChar = function(e, i, n, l, c, d, _, u) {
                    const g = t.blockElementDefinitions[i];
                    if (g) return function(e, t, i, s, r, o) {
                        for(let n = 0; n < t.length; n++){
                            const a = t[n], h = r / 8, l = o / 8;
                            e.fillRect(i + a.x * h, s + a.y * l, a.w * h, a.h * l);
                        }
                    }(e, g, n, l, c, d), !0;
                    const f = r[i];
                    if (f) return function(e, t, i, r, n, a) {
                        let h = o.get(t);
                        h || (h = new Map, o.set(t, h));
                        const l = e.fillStyle;
                        if ("string" != typeof l) throw new Error(`Unexpected fillStyle type "${l}"`);
                        let c = h.get(l);
                        if (!c) {
                            const i = t[0].length, r = t.length, o = document.createElement("canvas");
                            o.width = i, o.height = r;
                            const n = (0, s.throwIfFalsy)(o.getContext("2d")), a = new ImageData(i, r);
                            let d, _, u, g;
                            if (l.startsWith("#")) d = parseInt(l.slice(1, 3), 16), _ = parseInt(l.slice(3, 5), 16), u = parseInt(l.slice(5, 7), 16), g = l.length > 7 && parseInt(l.slice(7, 9), 16) || 1;
                            else {
                                if (!l.startsWith("rgba")) throw new Error(`Unexpected fillStyle color format "${l}" when drawing pattern glyph`);
                                [d, _, u, g] = l.substring(5, l.length - 1).split(",").map((e)=>parseFloat(e));
                            }
                            for(let e = 0; e < r; e++)for(let s = 0; s < i; s++)a.data[4 * (e * i + s)] = d, a.data[4 * (e * i + s) + 1] = _, a.data[4 * (e * i + s) + 2] = u, a.data[4 * (e * i + s) + 3] = t[e][s] * (255 * g);
                            n.putImageData(a, 0, 0), c = (0, s.throwIfFalsy)(e.createPattern(o, null)), h.set(l, c);
                        }
                        e.fillStyle = c, e.fillRect(i, r, n, a);
                    }(e, f, n, l, c, d), !0;
                    const v = t.boxDrawingDefinitions[i];
                    if (v) return function(e, t, i, s, r, o, n) {
                        e.strokeStyle = e.fillStyle;
                        for (const [l, c] of Object.entries(t)){
                            let t;
                            e.beginPath(), e.lineWidth = n * Number.parseInt(l), t = "function" == typeof c ? c(.15, .15 / o * r) : c;
                            for (const l of t.split(" ")){
                                const t = l[0], c = a[t];
                                if (!c) {
                                    console.error(`Could not find drawing instructions for "${t}"`);
                                    continue;
                                }
                                const d = l.substring(1).split(",");
                                d[0] && d[1] && c(e, h(d, r, o, i, s, !0, n));
                            }
                            e.stroke(), e.closePath();
                        }
                    }(e, v, n, l, c, d, u), !0;
                    const C = t.powerlineDefinitions[i];
                    return !!C && (function(e, t, i, s, r, o, n, l) {
                        var c, d;
                        const _ = new Path2D;
                        _.rect(i, s, r, o), e.clip(_), e.beginPath();
                        const u = n / 12;
                        e.lineWidth = l * u;
                        for (const n of t.d.split(" ")){
                            const _ = n[0], g = a[_];
                            if (!g) {
                                console.error(`Could not find drawing instructions for "${_}"`);
                                continue;
                            }
                            const f = n.substring(1).split(",");
                            f[0] && f[1] && g(e, h(f, r, o, i, s, !1, l, (null !== (c = t.leftPadding) && void 0 !== c ? c : 0) * (u / 2), (null !== (d = t.rightPadding) && void 0 !== d ? d : 0) * (u / 2)));
                        }
                        1 === t.type ? (e.strokeStyle = e.fillStyle, e.stroke()) : e.fill(), e.closePath();
                    }(e, C, n, l, c, d, _, u), !0);
                };
                const o = new Map;
                function n(e, t, i = 0) {
                    return Math.max(Math.min(e, t), i);
                }
                const a = {
                    C: (e, t)=>e.bezierCurveTo(t[0], t[1], t[2], t[3], t[4], t[5]),
                    L: (e, t)=>e.lineTo(t[0], t[1]),
                    M: (e, t)=>e.moveTo(t[0], t[1])
                };
                function h(e, t, i, s, r, o, a, h = 0, l = 0) {
                    const c = e.map((e)=>parseFloat(e) || parseInt(e));
                    if (c.length < 2) throw new Error("Too few arguments for instruction");
                    for(let e = 0; e < c.length; e += 2)c[e] *= t - h * a - l * a, o && 0 !== c[e] && (c[e] = n(Math.round(c[e] + .5) - .5, t, 0)), c[e] += s + h * a;
                    for(let e = 1; e < c.length; e += 2)c[e] *= i, o && 0 !== c[e] && (c[e] = n(Math.round(c[e] + .5) - .5, i, 0)), c[e] += r;
                    return c;
                }
            },
            56: (e, t, i)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.observeDevicePixelDimensions = void 0;
                const s = i(859);
                t.observeDevicePixelDimensions = function(e, t, i) {
                    let r = new t.ResizeObserver((t)=>{
                        const s = t.find((t)=>t.target === e);
                        if (!s) return;
                        if (!("devicePixelContentBoxSize" in s)) return null == r || r.disconnect(), void (r = void 0);
                        const o = s.devicePixelContentBoxSize[0].inlineSize, n = s.devicePixelContentBoxSize[0].blockSize;
                        o > 0 && n > 0 && i(o, n);
                    });
                    try {
                        r.observe(e, {
                            box: [
                                "device-pixel-content-box"
                            ]
                        });
                    } catch (e) {
                        r.disconnect(), r = void 0;
                    }
                    return (0, s.toDisposable)(()=>null == r ? void 0 : r.disconnect());
                };
            },
            374: (e, t)=>{
                function i(e) {
                    return 57508 <= e && e <= 57558;
                }
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.createRenderDimensions = t.excludeFromContrastRatioDemands = t.isRestrictedPowerlineGlyph = t.isPowerlineGlyph = t.throwIfFalsy = void 0, t.throwIfFalsy = function(e) {
                    if (!e) throw new Error("value must not be falsy");
                    return e;
                }, t.isPowerlineGlyph = i, t.isRestrictedPowerlineGlyph = function(e) {
                    return 57520 <= e && e <= 57527;
                }, t.excludeFromContrastRatioDemands = function(e) {
                    return i(e) || function(e) {
                        return 9472 <= e && e <= 9631;
                    }(e);
                }, t.createRenderDimensions = function() {
                    return {
                        css: {
                            canvas: {
                                width: 0,
                                height: 0
                            },
                            cell: {
                                width: 0,
                                height: 0
                            }
                        },
                        device: {
                            canvas: {
                                width: 0,
                                height: 0
                            },
                            cell: {
                                width: 0,
                                height: 0
                            },
                            char: {
                                width: 0,
                                height: 0,
                                left: 0,
                                top: 0
                            }
                        }
                    };
                };
            },
            296: (e, t)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.createSelectionRenderModel = void 0;
                class i {
                    constructor(){
                        this.clear();
                    }
                    clear() {
                        this.hasSelection = !1, this.columnSelectMode = !1, this.viewportStartRow = 0, this.viewportEndRow = 0, this.viewportCappedStartRow = 0, this.viewportCappedEndRow = 0, this.startCol = 0, this.endCol = 0, this.selectionStart = void 0, this.selectionEnd = void 0;
                    }
                    update(e, t, i, s = !1) {
                        if (this.selectionStart = t, this.selectionEnd = i, !t || !i || t[0] === i[0] && t[1] === i[1]) return void this.clear();
                        const r = t[1] - e.buffer.active.viewportY, o = i[1] - e.buffer.active.viewportY, n = Math.max(r, 0), a = Math.min(o, e.rows - 1);
                        n >= e.rows || a < 0 ? this.clear() : (this.hasSelection = !0, this.columnSelectMode = s, this.viewportStartRow = r, this.viewportEndRow = o, this.viewportCappedStartRow = n, this.viewportCappedEndRow = a, this.startCol = t[0], this.endCol = i[0]);
                    }
                    isCellSelected(e, t, i) {
                        return !!this.hasSelection && (i -= e.buffer.active.viewportY, this.columnSelectMode ? this.startCol <= this.endCol ? t >= this.startCol && i >= this.viewportCappedStartRow && t < this.endCol && i <= this.viewportCappedEndRow : t < this.startCol && i >= this.viewportCappedStartRow && t >= this.endCol && i <= this.viewportCappedEndRow : i > this.viewportStartRow && i < this.viewportEndRow || this.viewportStartRow === this.viewportEndRow && i === this.viewportStartRow && t >= this.startCol && t < this.endCol || this.viewportStartRow < this.viewportEndRow && i === this.viewportEndRow && t < this.endCol || this.viewportStartRow < this.viewportEndRow && i === this.viewportStartRow && t >= this.startCol);
                    }
                }
                t.createSelectionRenderModel = function() {
                    return new i;
                };
            },
            509: (e, t, i)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.TextureAtlas = void 0;
                const s = i(237), r = i(855), o = i(147), n = i(160), a = i(860), h = i(374), l = i(485), c = i(385), d = i(345), _ = {
                    texturePage: 0,
                    texturePosition: {
                        x: 0,
                        y: 0
                    },
                    texturePositionClipSpace: {
                        x: 0,
                        y: 0
                    },
                    offset: {
                        x: 0,
                        y: 0
                    },
                    size: {
                        x: 0,
                        y: 0
                    },
                    sizeClipSpace: {
                        x: 0,
                        y: 0
                    }
                };
                let u;
                class g {
                    constructor(e, t, i){
                        this._document = e, this._config = t, this._unicodeService = i, this._didWarmUp = !1, this._cacheMap = new l.FourKeyMap, this._cacheMapCombined = new l.FourKeyMap, this._pages = [], this._activePages = [], this._workBoundingBox = {
                            top: 0,
                            left: 0,
                            bottom: 0,
                            right: 0
                        }, this._workAttributeData = new o.AttributeData, this._textureSize = 512, this._onAddTextureAtlasCanvas = new d.EventEmitter, this.onAddTextureAtlasCanvas = this._onAddTextureAtlasCanvas.event, this._onRemoveTextureAtlasCanvas = new d.EventEmitter, this.onRemoveTextureAtlasCanvas = this._onRemoveTextureAtlasCanvas.event, this._requestClearModel = !1, this._createNewPage(), this._tmpCanvas = C(e, 4 * this._config.deviceCellWidth + 4, this._config.deviceCellHeight + 4), this._tmpCtx = (0, h.throwIfFalsy)(this._tmpCanvas.getContext("2d", {
                            alpha: this._config.allowTransparency,
                            willReadFrequently: !0
                        }));
                    }
                    get pages() {
                        return this._pages;
                    }
                    dispose() {
                        for (const e of this.pages)e.canvas.remove();
                        this._onAddTextureAtlasCanvas.dispose();
                    }
                    warmUp() {
                        this._didWarmUp || (this._doWarmUp(), this._didWarmUp = !0);
                    }
                    _doWarmUp() {
                        const e = new c.IdleTaskQueue;
                        for(let t = 33; t < 126; t++)e.enqueue(()=>{
                            if (!this._cacheMap.get(t, r.DEFAULT_COLOR, r.DEFAULT_COLOR, r.DEFAULT_EXT)) {
                                const e = this._drawToCache(t, r.DEFAULT_COLOR, r.DEFAULT_COLOR, r.DEFAULT_EXT);
                                this._cacheMap.set(t, r.DEFAULT_COLOR, r.DEFAULT_COLOR, r.DEFAULT_EXT, e);
                            }
                        });
                    }
                    beginFrame() {
                        return this._requestClearModel;
                    }
                    clearTexture() {
                        if (0 !== this._pages[0].currentRow.x || 0 !== this._pages[0].currentRow.y) {
                            for (const e of this._pages)e.clear();
                            this._cacheMap.clear(), this._cacheMapCombined.clear(), this._didWarmUp = !1;
                        }
                    }
                    _createNewPage() {
                        g.maxAtlasPages && this._pages.length >= Math.max(4, g.maxAtlasPages / 2) && queueMicrotask(()=>{
                            const e = this._pages.filter((e)=>2 * e.canvas.width <= (g.maxTextureSize || 4096)).sort((e, t)=>t.canvas.width !== e.canvas.width ? t.canvas.width - e.canvas.width : t.percentageUsed - e.percentageUsed);
                            let t = -1, i = 0;
                            for(let s = 0; s < e.length; s++)if (e[s].canvas.width !== i) t = s, i = e[s].canvas.width;
                            else if (s - t == 3) break;
                            const s = e.slice(t, t + 4), r = s.map((e)=>e.glyphs[0].texturePage).sort((e, t)=>e > t ? 1 : -1), o = r[0], n = this._mergePages(s, o);
                            n.version++, this._pages[o] = n;
                            for(let e = r.length - 1; e >= 1; e--)this._deletePage(r[e]);
                            this._requestClearModel = !0, this._onAddTextureAtlasCanvas.fire(n.canvas);
                        });
                        const e = new f(this._document, this._textureSize);
                        return this._pages.push(e), this._activePages.push(e), this._onAddTextureAtlasCanvas.fire(e.canvas), e;
                    }
                    _mergePages(e, t) {
                        const i = 2 * e[0].canvas.width, s = new f(this._document, i, e);
                        for (const [r, o] of e.entries()){
                            const e = r * o.canvas.width % i, n = Math.floor(r / 2) * o.canvas.height;
                            s.ctx.drawImage(o.canvas, e, n);
                            for (const s of o.glyphs)s.texturePage = t, s.sizeClipSpace.x = s.size.x / i, s.sizeClipSpace.y = s.size.y / i, s.texturePosition.x += e, s.texturePosition.y += n, s.texturePositionClipSpace.x = s.texturePosition.x / i, s.texturePositionClipSpace.y = s.texturePosition.y / i;
                            this._onRemoveTextureAtlasCanvas.fire(o.canvas);
                            const a = this._activePages.indexOf(o);
                            -1 !== a && this._activePages.splice(a, 1);
                        }
                        return s;
                    }
                    _deletePage(e) {
                        this._pages.splice(e, 1);
                        for(let t = e; t < this._pages.length; t++){
                            const e = this._pages[t];
                            for (const t of e.glyphs)t.texturePage--;
                            e.version++;
                        }
                    }
                    getRasterizedGlyphCombinedChar(e, t, i, s) {
                        return this._getFromCacheMap(this._cacheMapCombined, e, t, i, s);
                    }
                    getRasterizedGlyph(e, t, i, s) {
                        return this._getFromCacheMap(this._cacheMap, e, t, i, s);
                    }
                    _getFromCacheMap(e, t, i, s, r) {
                        return u = e.get(t, i, s, r), u || (u = this._drawToCache(t, i, s, r), e.set(t, i, s, r, u)), u;
                    }
                    _getColorFromAnsiIndex(e) {
                        if (e >= this._config.colors.ansi.length) throw new Error("No color found for idx " + e);
                        return this._config.colors.ansi[e];
                    }
                    _getBackgroundColor(e, t, i, s) {
                        if (this._config.allowTransparency) return n.NULL_COLOR;
                        let r;
                        switch(e){
                            case 16777216:
                            case 33554432:
                                r = this._getColorFromAnsiIndex(t);
                                break;
                            case 50331648:
                                const e1 = o.AttributeData.toColorRGB(t);
                                r = n.rgba.toColor(e1[0], e1[1], e1[2]);
                                break;
                            default:
                                r = i ? this._config.colors.foreground : this._config.colors.background;
                        }
                        return r;
                    }
                    _getForegroundColor(e, t, i, r, a, h, l, c, d, _) {
                        const u = this._getMinimumContrastColor(e, t, i, r, a, h, !1, d, _);
                        if (u) return u;
                        let g;
                        switch(a){
                            case 16777216:
                            case 33554432:
                                this._config.drawBoldTextInBrightColors && d && h < 8 && (h += 8), g = this._getColorFromAnsiIndex(h);
                                break;
                            case 50331648:
                                const e1 = o.AttributeData.toColorRGB(h);
                                g = n.rgba.toColor(e1[0], e1[1], e1[2]);
                                break;
                            default:
                                g = l ? this._config.colors.background : this._config.colors.foreground;
                        }
                        return this._config.allowTransparency && (g = n.color.opaque(g)), c && (g = n.color.multiplyOpacity(g, s.DIM_OPACITY)), g;
                    }
                    _resolveBackgroundRgba(e, t, i) {
                        switch(e){
                            case 16777216:
                            case 33554432:
                                return this._getColorFromAnsiIndex(t).rgba;
                            case 50331648:
                                return t << 8;
                            default:
                                return i ? this._config.colors.foreground.rgba : this._config.colors.background.rgba;
                        }
                    }
                    _resolveForegroundRgba(e, t, i, s) {
                        switch(e){
                            case 16777216:
                            case 33554432:
                                return this._config.drawBoldTextInBrightColors && s && t < 8 && (t += 8), this._getColorFromAnsiIndex(t).rgba;
                            case 50331648:
                                return t << 8;
                            default:
                                return i ? this._config.colors.background.rgba : this._config.colors.foreground.rgba;
                        }
                    }
                    _getMinimumContrastColor(e, t, i, s, r, o, a, h, l) {
                        if (1 === this._config.minimumContrastRatio || l) return;
                        const c = this._config.colors.contrastCache.getColor(e, s);
                        if (void 0 !== c) return c || void 0;
                        const d = this._resolveBackgroundRgba(t, i, a), _ = this._resolveForegroundRgba(r, o, a, h), u = n.rgba.ensureContrastRatio(d, _, this._config.minimumContrastRatio);
                        if (!u) return void this._config.colors.contrastCache.setColor(e, s, null);
                        const g = n.rgba.toColor(u >> 24 & 255, u >> 16 & 255, u >> 8 & 255);
                        return this._config.colors.contrastCache.setColor(e, s, g), g;
                    }
                    _drawToCache(e, t, i, r) {
                        const n = "number" == typeof e ? String.fromCharCode(e) : e, l = Math.min(this._config.deviceCellWidth * Math.max(n.length, 2) + 4, this._textureSize);
                        this._tmpCanvas.width < l && (this._tmpCanvas.width = l);
                        const c = Math.min(this._config.deviceCellHeight + 8, this._textureSize);
                        if (this._tmpCanvas.height < c && (this._tmpCanvas.height = c), this._tmpCtx.save(), this._workAttributeData.fg = i, this._workAttributeData.bg = t, this._workAttributeData.extended.ext = r, this._workAttributeData.isInvisible()) return _;
                        const d = !!this._workAttributeData.isBold(), u = !!this._workAttributeData.isInverse(), g = !!this._workAttributeData.isDim(), f = !!this._workAttributeData.isItalic(), C = !!this._workAttributeData.isUnderline(), p = !!this._workAttributeData.isStrikethrough(), x = !!this._workAttributeData.isOverline();
                        let m = this._workAttributeData.getFgColor(), w = this._workAttributeData.getFgColorMode(), L = this._workAttributeData.getBgColor(), b = this._workAttributeData.getBgColorMode();
                        if (u) {
                            const e = m;
                            m = L, L = e;
                            const t = w;
                            w = b, b = t;
                        }
                        const M = this._getBackgroundColor(b, L, u, g);
                        this._tmpCtx.globalCompositeOperation = "copy", this._tmpCtx.fillStyle = M.css, this._tmpCtx.fillRect(0, 0, this._tmpCanvas.width, this._tmpCanvas.height), this._tmpCtx.globalCompositeOperation = "source-over";
                        const y = d ? this._config.fontWeightBold : this._config.fontWeight, S = f ? "italic" : "";
                        this._tmpCtx.font = `${S} ${y} ${this._config.fontSize * this._config.devicePixelRatio}px ${this._config.fontFamily}`, this._tmpCtx.textBaseline = s.TEXT_BASELINE;
                        const R = 1 === n.length && (0, h.isPowerlineGlyph)(n.charCodeAt(0)), A = 1 === n.length && (0, h.isRestrictedPowerlineGlyph)(n.charCodeAt(0)), T = this._getForegroundColor(t, b, L, i, w, m, u, g, d, (0, h.excludeFromContrastRatioDemands)(n.charCodeAt(0)));
                        this._tmpCtx.fillStyle = T.css;
                        const D = A ? 0 : 4;
                        let k = !1;
                        !1 !== this._config.customGlyphs && (k = (0, a.tryDrawCustomChar)(this._tmpCtx, n, D, D, this._config.deviceCellWidth, this._config.deviceCellHeight, this._config.fontSize, this._config.devicePixelRatio));
                        let $, B = !R;
                        if ($ = "number" == typeof e ? this._unicodeService.wcwidth(e) : this._unicodeService.getStringCellWidth(e), C) {
                            this._tmpCtx.save();
                            const e = Math.max(1, Math.floor(this._config.fontSize * this._config.devicePixelRatio / 15)), t = e % 2 == 1 ? .5 : 0;
                            if (this._tmpCtx.lineWidth = e, this._workAttributeData.isUnderlineColorDefault()) this._tmpCtx.strokeStyle = this._tmpCtx.fillStyle;
                            else if (this._workAttributeData.isUnderlineColorRGB()) B = !1, this._tmpCtx.strokeStyle = `rgb(${o.AttributeData.toColorRGB(this._workAttributeData.getUnderlineColor()).join(",")})`;
                            else {
                                B = !1;
                                let e = this._workAttributeData.getUnderlineColor();
                                this._config.drawBoldTextInBrightColors && this._workAttributeData.isBold() && e < 8 && (e += 8), this._tmpCtx.strokeStyle = this._getColorFromAnsiIndex(e).css;
                            }
                            this._tmpCtx.beginPath();
                            const i = D, s = Math.ceil(D + this._config.deviceCharHeight) - t, r = D + this._config.deviceCharHeight + e - t, a = Math.ceil(D + this._config.deviceCharHeight + 2 * e) - t;
                            for(let o = 0; o < $; o++){
                                this._tmpCtx.save();
                                const n = i + o * this._config.deviceCellWidth, h = i + (o + 1) * this._config.deviceCellWidth, l = n + this._config.deviceCellWidth / 2;
                                switch(this._workAttributeData.extended.underlineStyle){
                                    case 2:
                                        this._tmpCtx.moveTo(n, s), this._tmpCtx.lineTo(h, s), this._tmpCtx.moveTo(n, a), this._tmpCtx.lineTo(h, a);
                                        break;
                                    case 3:
                                        const i1 = e <= 1 ? a : Math.ceil(D + this._config.deviceCharHeight - e / 2) - t, o1 = e <= 1 ? s : Math.ceil(D + this._config.deviceCharHeight + e / 2) - t, c = new Path2D;
                                        c.rect(n, s, this._config.deviceCellWidth, a - s), this._tmpCtx.clip(c), this._tmpCtx.moveTo(n - this._config.deviceCellWidth / 2, r), this._tmpCtx.bezierCurveTo(n - this._config.deviceCellWidth / 2, o1, n, o1, n, r), this._tmpCtx.bezierCurveTo(n, i1, l, i1, l, r), this._tmpCtx.bezierCurveTo(l, o1, h, o1, h, r), this._tmpCtx.bezierCurveTo(h, i1, h + this._config.deviceCellWidth / 2, i1, h + this._config.deviceCellWidth / 2, r);
                                        break;
                                    case 4:
                                        this._tmpCtx.setLineDash([
                                            Math.round(e),
                                            Math.round(e)
                                        ]), this._tmpCtx.moveTo(n, s), this._tmpCtx.lineTo(h, s);
                                        break;
                                    case 5:
                                        this._tmpCtx.setLineDash([
                                            4 * this._config.devicePixelRatio,
                                            3 * this._config.devicePixelRatio
                                        ]), this._tmpCtx.moveTo(n, s), this._tmpCtx.lineTo(h, s);
                                        break;
                                    default:
                                        this._tmpCtx.moveTo(n, s), this._tmpCtx.lineTo(h, s);
                                }
                                this._tmpCtx.stroke(), this._tmpCtx.restore();
                            }
                            if (this._tmpCtx.restore(), !k && this._config.fontSize >= 12 && !this._config.allowTransparency && " " !== n) {
                                this._tmpCtx.save(), this._tmpCtx.textBaseline = "alphabetic";
                                const t = this._tmpCtx.measureText(n);
                                if (this._tmpCtx.restore(), "actualBoundingBoxDescent" in t && t.actualBoundingBoxDescent > 0) {
                                    this._tmpCtx.save();
                                    const t = new Path2D;
                                    t.rect(i, s - Math.ceil(e / 2), this._config.deviceCellWidth * $, a - s + Math.ceil(e / 2)), this._tmpCtx.clip(t), this._tmpCtx.lineWidth = 3 * this._config.devicePixelRatio, this._tmpCtx.strokeStyle = M.css, this._tmpCtx.strokeText(n, D, D + this._config.deviceCharHeight), this._tmpCtx.restore();
                                }
                            }
                        }
                        if (x) {
                            const e = Math.max(1, Math.floor(this._config.fontSize * this._config.devicePixelRatio / 15)), t = e % 2 == 1 ? .5 : 0;
                            this._tmpCtx.lineWidth = e, this._tmpCtx.strokeStyle = this._tmpCtx.fillStyle, this._tmpCtx.beginPath(), this._tmpCtx.moveTo(D, D + t), this._tmpCtx.lineTo(D + this._config.deviceCharWidth * $, D + t), this._tmpCtx.stroke();
                        }
                        if (k || this._tmpCtx.fillText(n, D, D + this._config.deviceCharHeight), "_" === n && !this._config.allowTransparency) {
                            let e = v(this._tmpCtx.getImageData(D, D, this._config.deviceCellWidth, this._config.deviceCellHeight), M, T, B);
                            if (e) for(let t = 1; t <= 5 && (this._tmpCtx.save(), this._tmpCtx.fillStyle = M.css, this._tmpCtx.fillRect(0, 0, this._tmpCanvas.width, this._tmpCanvas.height), this._tmpCtx.restore(), this._tmpCtx.fillText(n, D, D + this._config.deviceCharHeight - t), e = v(this._tmpCtx.getImageData(D, D, this._config.deviceCellWidth, this._config.deviceCellHeight), M, T, B), e); t++);
                        }
                        if (p) {
                            const e = Math.max(1, Math.floor(this._config.fontSize * this._config.devicePixelRatio / 10)), t = this._tmpCtx.lineWidth % 2 == 1 ? .5 : 0;
                            this._tmpCtx.lineWidth = e, this._tmpCtx.strokeStyle = this._tmpCtx.fillStyle, this._tmpCtx.beginPath(), this._tmpCtx.moveTo(D, D + Math.floor(this._config.deviceCharHeight / 2) - t), this._tmpCtx.lineTo(D + this._config.deviceCharWidth * $, D + Math.floor(this._config.deviceCharHeight / 2) - t), this._tmpCtx.stroke();
                        }
                        this._tmpCtx.restore();
                        const E = this._tmpCtx.getImageData(0, 0, this._tmpCanvas.width, this._tmpCanvas.height);
                        let P;
                        if (P = this._config.allowTransparency ? function(e) {
                            for(let t = 0; t < e.data.length; t += 4)if (e.data[t + 3] > 0) return !1;
                            return !0;
                        }(E) : v(E, M, T, B), P) return _;
                        const I = this._findGlyphBoundingBox(E, this._workBoundingBox, l, A, k, D);
                        let O, F;
                        for(;;){
                            if (0 === this._activePages.length) {
                                const e = this._createNewPage();
                                O = e, F = e.currentRow, F.height = I.size.y;
                                break;
                            }
                            O = this._activePages[this._activePages.length - 1], F = O.currentRow;
                            for (const e of this._activePages)I.size.y <= e.currentRow.height && (O = e, F = e.currentRow);
                            for(let e = this._activePages.length - 1; e >= 0; e--)for (const t of this._activePages[e].fixedRows)t.height <= F.height && I.size.y <= t.height && (O = this._activePages[e], F = t);
                            if (F.y + I.size.y >= O.canvas.height || F.height > I.size.y + 2) {
                                let e = !1;
                                if (O.currentRow.y + O.currentRow.height + I.size.y >= O.canvas.height) {
                                    let t;
                                    for (const e of this._activePages)if (e.currentRow.y + e.currentRow.height + I.size.y < e.canvas.height) {
                                        t = e;
                                        break;
                                    }
                                    if (t) O = t;
                                    else {
                                        const t = this._createNewPage();
                                        O = t, F = t.currentRow, F.height = I.size.y, e = !0;
                                    }
                                }
                                e || (O.currentRow.height > 0 && O.fixedRows.push(O.currentRow), F = {
                                    x: 0,
                                    y: O.currentRow.y + O.currentRow.height,
                                    height: I.size.y
                                }, O.fixedRows.push(F), O.currentRow = {
                                    x: 0,
                                    y: F.y + F.height,
                                    height: 0
                                });
                            }
                            if (F.x + I.size.x <= O.canvas.width) break;
                            F === O.currentRow ? (F.x = 0, F.y += F.height, F.height = 0) : O.fixedRows.splice(O.fixedRows.indexOf(F), 1);
                        }
                        return I.texturePage = this._pages.indexOf(O), I.texturePosition.x = F.x, I.texturePosition.y = F.y, I.texturePositionClipSpace.x = F.x / O.canvas.width, I.texturePositionClipSpace.y = F.y / O.canvas.height, I.sizeClipSpace.x /= O.canvas.width, I.sizeClipSpace.y /= O.canvas.height, F.height = Math.max(F.height, I.size.y), F.x += I.size.x, O.ctx.putImageData(E, I.texturePosition.x - this._workBoundingBox.left, I.texturePosition.y - this._workBoundingBox.top, this._workBoundingBox.left, this._workBoundingBox.top, I.size.x, I.size.y), O.addGlyph(I), O.version++, I;
                    }
                    _findGlyphBoundingBox(e, t, i, s, r, o) {
                        t.top = 0;
                        const n = s ? this._config.deviceCellHeight : this._tmpCanvas.height, a = s ? this._config.deviceCellWidth : i;
                        let h = !1;
                        for(let i = 0; i < n; i++){
                            for(let s = 0; s < a; s++){
                                const r = i * this._tmpCanvas.width * 4 + 4 * s + 3;
                                if (0 !== e.data[r]) {
                                    t.top = i, h = !0;
                                    break;
                                }
                            }
                            if (h) break;
                        }
                        t.left = 0, h = !1;
                        for(let i = 0; i < o + a; i++){
                            for(let s = 0; s < n; s++){
                                const r = s * this._tmpCanvas.width * 4 + 4 * i + 3;
                                if (0 !== e.data[r]) {
                                    t.left = i, h = !0;
                                    break;
                                }
                            }
                            if (h) break;
                        }
                        t.right = a, h = !1;
                        for(let i = o + a - 1; i >= o; i--){
                            for(let s = 0; s < n; s++){
                                const r = s * this._tmpCanvas.width * 4 + 4 * i + 3;
                                if (0 !== e.data[r]) {
                                    t.right = i, h = !0;
                                    break;
                                }
                            }
                            if (h) break;
                        }
                        t.bottom = n, h = !1;
                        for(let i = n - 1; i >= 0; i--){
                            for(let s = 0; s < a; s++){
                                const r = i * this._tmpCanvas.width * 4 + 4 * s + 3;
                                if (0 !== e.data[r]) {
                                    t.bottom = i, h = !0;
                                    break;
                                }
                            }
                            if (h) break;
                        }
                        return {
                            texturePage: 0,
                            texturePosition: {
                                x: 0,
                                y: 0
                            },
                            texturePositionClipSpace: {
                                x: 0,
                                y: 0
                            },
                            size: {
                                x: t.right - t.left + 1,
                                y: t.bottom - t.top + 1
                            },
                            sizeClipSpace: {
                                x: t.right - t.left + 1,
                                y: t.bottom - t.top + 1
                            },
                            offset: {
                                x: -t.left + o + (s || r ? Math.floor((this._config.deviceCellWidth - this._config.deviceCharWidth) / 2) : 0),
                                y: -t.top + o + (s || r ? 1 === this._config.lineHeight ? 0 : Math.round((this._config.deviceCellHeight - this._config.deviceCharHeight) / 2) : 0)
                            }
                        };
                    }
                }
                t.TextureAtlas = g;
                class f {
                    constructor(e, t, i){
                        if (this._usedPixels = 0, this._glyphs = [], this.version = 0, this.currentRow = {
                            x: 0,
                            y: 0,
                            height: 0
                        }, this.fixedRows = [], i) for (const e of i)this._glyphs.push(...e.glyphs), this._usedPixels += e._usedPixels;
                        this.canvas = C(e, t, t), this.ctx = (0, h.throwIfFalsy)(this.canvas.getContext("2d", {
                            alpha: !0
                        }));
                    }
                    get percentageUsed() {
                        return this._usedPixels / (this.canvas.width * this.canvas.height);
                    }
                    get glyphs() {
                        return this._glyphs;
                    }
                    addGlyph(e) {
                        this._glyphs.push(e), this._usedPixels += e.size.x * e.size.y;
                    }
                    clear() {
                        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height), this.currentRow.x = 0, this.currentRow.y = 0, this.currentRow.height = 0, this.fixedRows.length = 0, this.version++;
                    }
                }
                function v(e, t, i, s) {
                    const r = t.rgba >>> 24, o = t.rgba >>> 16 & 255, n = t.rgba >>> 8 & 255, a = i.rgba >>> 24, h = i.rgba >>> 16 & 255, l = i.rgba >>> 8 & 255, c = Math.floor((Math.abs(r - a) + Math.abs(o - h) + Math.abs(n - l)) / 12);
                    let d = !0;
                    for(let t = 0; t < e.data.length; t += 4)e.data[t] === r && e.data[t + 1] === o && e.data[t + 2] === n || s && Math.abs(e.data[t] - r) + Math.abs(e.data[t + 1] - o) + Math.abs(e.data[t + 2] - n) < c ? e.data[t + 3] = 0 : d = !1;
                    return d;
                }
                function C(e, t, i) {
                    const s = e.createElement("canvas");
                    return s.width = t, s.height = i, s;
                }
            },
            577: function(e, t, i) {
                var s = this && this.__decorate || function(e, t, i, s) {
                    var r, o = arguments.length, n = o < 3 ? t : null === s ? s = Object.getOwnPropertyDescriptor(t, i) : s;
                    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) n = Reflect.decorate(e, t, i, s);
                    else for(var a = e.length - 1; a >= 0; a--)(r = e[a]) && (n = (o < 3 ? r(n) : o > 3 ? r(t, i, n) : r(t, i)) || n);
                    return o > 3 && n && Object.defineProperty(t, i, n), n;
                }, r = this && this.__param || function(e, t) {
                    return function(i, s) {
                        t(i, s, e);
                    };
                };
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.CharacterJoinerService = t.JoinedCellData = void 0;
                const o = i(147), n = i(855), a = i(782), h = i(97);
                class l extends o.AttributeData {
                    constructor(e, t, i){
                        super(), this.content = 0, this.combinedData = "", this.fg = e.fg, this.bg = e.bg, this.combinedData = t, this._width = i;
                    }
                    isCombined() {
                        return 2097152;
                    }
                    getWidth() {
                        return this._width;
                    }
                    getChars() {
                        return this.combinedData;
                    }
                    getCode() {
                        return 2097151;
                    }
                    setFromCharData(e) {
                        throw new Error("not implemented");
                    }
                    getAsCharData() {
                        return [
                            this.fg,
                            this.getChars(),
                            this.getWidth(),
                            this.getCode()
                        ];
                    }
                }
                t.JoinedCellData = l;
                let c = class e {
                    constructor(e){
                        this._bufferService = e, this._characterJoiners = [], this._nextCharacterJoinerId = 0, this._workCell = new a.CellData;
                    }
                    register(e) {
                        const t = {
                            id: this._nextCharacterJoinerId++,
                            handler: e
                        };
                        return this._characterJoiners.push(t), t.id;
                    }
                    deregister(e) {
                        for(let t = 0; t < this._characterJoiners.length; t++)if (this._characterJoiners[t].id === e) return this._characterJoiners.splice(t, 1), !0;
                        return !1;
                    }
                    getJoinedCharacters(e) {
                        if (0 === this._characterJoiners.length) return [];
                        const t = this._bufferService.buffer.lines.get(e);
                        if (!t || 0 === t.length) return [];
                        const i = [], s = t.translateToString(!0);
                        let r = 0, o = 0, a = 0, h = t.getFg(0), l = t.getBg(0);
                        for(let e = 0; e < t.getTrimmedLength(); e++)if (t.loadCell(e, this._workCell), 0 !== this._workCell.getWidth()) {
                            if (this._workCell.fg !== h || this._workCell.bg !== l) {
                                if (e - r > 1) {
                                    const e = this._getJoinedRanges(s, a, o, t, r);
                                    for(let t = 0; t < e.length; t++)i.push(e[t]);
                                }
                                r = e, a = o, h = this._workCell.fg, l = this._workCell.bg;
                            }
                            o += this._workCell.getChars().length || n.WHITESPACE_CELL_CHAR.length;
                        }
                        if (this._bufferService.cols - r > 1) {
                            const e = this._getJoinedRanges(s, a, o, t, r);
                            for(let t = 0; t < e.length; t++)i.push(e[t]);
                        }
                        return i;
                    }
                    _getJoinedRanges(t, i, s, r, o) {
                        const n = t.substring(i, s);
                        let a = [];
                        try {
                            a = this._characterJoiners[0].handler(n);
                        } catch (e) {
                            console.error(e);
                        }
                        for(let t = 1; t < this._characterJoiners.length; t++)try {
                            const i = this._characterJoiners[t].handler(n);
                            for(let t = 0; t < i.length; t++)e._mergeRanges(a, i[t]);
                        } catch (e) {
                            console.error(e);
                        }
                        return this._stringRangesToCellRanges(a, r, o), a;
                    }
                    _stringRangesToCellRanges(e, t, i) {
                        let s = 0, r = !1, o = 0, a = e[s];
                        if (a) {
                            for(let h = i; h < this._bufferService.cols; h++){
                                const i = t.getWidth(h), l = t.getString(h).length || n.WHITESPACE_CELL_CHAR.length;
                                if (0 !== i) {
                                    if (!r && a[0] <= o && (a[0] = h, r = !0), a[1] <= o) {
                                        if (a[1] = h, a = e[++s], !a) break;
                                        a[0] <= o ? (a[0] = h, r = !0) : r = !1;
                                    }
                                    o += l;
                                }
                            }
                            a && (a[1] = this._bufferService.cols);
                        }
                    }
                    static _mergeRanges(e, t) {
                        let i = !1;
                        for(let s = 0; s < e.length; s++){
                            const r = e[s];
                            if (i) {
                                if (t[1] <= r[0]) return e[s - 1][1] = t[1], e;
                                if (t[1] <= r[1]) return e[s - 1][1] = Math.max(t[1], r[1]), e.splice(s, 1), e;
                                e.splice(s, 1), s--;
                            } else {
                                if (t[1] <= r[0]) return e.splice(s, 0, t), e;
                                if (t[1] <= r[1]) return r[0] = Math.min(t[0], r[0]), e;
                                t[0] < r[1] && (r[0] = Math.min(t[0], r[0]), i = !0);
                            }
                        }
                        return i ? e[e.length - 1][1] = t[1] : e.push(t), e;
                    }
                };
                c = s([
                    r(0, h.IBufferService)
                ], c), t.CharacterJoinerService = c;
            },
            160: (e, t, i)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.contrastRatio = t.toPaddedHex = t.rgba = t.rgb = t.css = t.color = t.channels = t.NULL_COLOR = void 0;
                const s = i(399);
                let r = 0, o = 0, n = 0, a = 0;
                var h, l, c;
                function d(e) {
                    const t = e.toString(16);
                    return t.length < 2 ? "0" + t : t;
                }
                function _(e, t) {
                    return e < t ? (t + .05) / (e + .05) : (e + .05) / (t + .05);
                }
                t.NULL_COLOR = {
                    css: "#00000000",
                    rgba: 0
                }, function(e) {
                    e.toCss = function(e, t, i, s) {
                        return void 0 !== s ? `#${d(e)}${d(t)}${d(i)}${d(s)}` : `#${d(e)}${d(t)}${d(i)}`;
                    }, e.toRgba = function(e, t, i, s = 255) {
                        return (e << 24 | t << 16 | i << 8 | s) >>> 0;
                    };
                }(h = t.channels || (t.channels = {})), function(e) {
                    function t(e, t) {
                        return a = Math.round(255 * t), [r, o, n] = c.toChannels(e.rgba), {
                            css: h.toCss(r, o, n, a),
                            rgba: h.toRgba(r, o, n, a)
                        };
                    }
                    e.blend = function(e, t) {
                        if (a = (255 & t.rgba) / 255, 1 === a) return {
                            css: t.css,
                            rgba: t.rgba
                        };
                        const i = t.rgba >> 24 & 255, s = t.rgba >> 16 & 255, l = t.rgba >> 8 & 255, c = e.rgba >> 24 & 255, d = e.rgba >> 16 & 255, _ = e.rgba >> 8 & 255;
                        return r = c + Math.round((i - c) * a), o = d + Math.round((s - d) * a), n = _ + Math.round((l - _) * a), {
                            css: h.toCss(r, o, n),
                            rgba: h.toRgba(r, o, n)
                        };
                    }, e.isOpaque = function(e) {
                        return 255 == (255 & e.rgba);
                    }, e.ensureContrastRatio = function(e, t, i) {
                        const s = c.ensureContrastRatio(e.rgba, t.rgba, i);
                        if (s) return c.toColor(s >> 24 & 255, s >> 16 & 255, s >> 8 & 255);
                    }, e.opaque = function(e) {
                        const t = (255 | e.rgba) >>> 0;
                        return [r, o, n] = c.toChannels(t), {
                            css: h.toCss(r, o, n),
                            rgba: t
                        };
                    }, e.opacity = t, e.multiplyOpacity = function(e, i) {
                        return a = 255 & e.rgba, t(e, a * i / 255);
                    }, e.toColorRGB = function(e) {
                        return [
                            e.rgba >> 24 & 255,
                            e.rgba >> 16 & 255,
                            e.rgba >> 8 & 255
                        ];
                    };
                }(t.color || (t.color = {})), function(e) {
                    let t, i;
                    if (!s.isNode) {
                        const e = document.createElement("canvas");
                        e.width = 1, e.height = 1;
                        const s = e.getContext("2d", {
                            willReadFrequently: !0
                        });
                        s && (t = s, t.globalCompositeOperation = "copy", i = t.createLinearGradient(0, 0, 1, 1));
                    }
                    e.toColor = function(e) {
                        if (e.match(/#[\da-f]{3,8}/i)) switch(e.length){
                            case 4:
                                return r = parseInt(e.slice(1, 2).repeat(2), 16), o = parseInt(e.slice(2, 3).repeat(2), 16), n = parseInt(e.slice(3, 4).repeat(2), 16), c.toColor(r, o, n);
                            case 5:
                                return r = parseInt(e.slice(1, 2).repeat(2), 16), o = parseInt(e.slice(2, 3).repeat(2), 16), n = parseInt(e.slice(3, 4).repeat(2), 16), a = parseInt(e.slice(4, 5).repeat(2), 16), c.toColor(r, o, n, a);
                            case 7:
                                return {
                                    css: e,
                                    rgba: (parseInt(e.slice(1), 16) << 8 | 255) >>> 0
                                };
                            case 9:
                                return {
                                    css: e,
                                    rgba: parseInt(e.slice(1), 16) >>> 0
                                };
                        }
                        const s = e.match(/rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(,\s*(0|1|\d?\.(\d+))\s*)?\)/);
                        if (s) return r = parseInt(s[1]), o = parseInt(s[2]), n = parseInt(s[3]), a = Math.round(255 * (void 0 === s[5] ? 1 : parseFloat(s[5]))), c.toColor(r, o, n, a);
                        if (!t || !i) throw new Error("css.toColor: Unsupported css format");
                        if (t.fillStyle = i, t.fillStyle = e, "string" != typeof t.fillStyle) throw new Error("css.toColor: Unsupported css format");
                        if (t.fillRect(0, 0, 1, 1), [r, o, n, a] = t.getImageData(0, 0, 1, 1).data, 255 !== a) throw new Error("css.toColor: Unsupported css format");
                        return {
                            rgba: h.toRgba(r, o, n, a),
                            css: e
                        };
                    };
                }(t.css || (t.css = {})), function(e) {
                    function t(e, t, i) {
                        const s = e / 255, r = t / 255, o = i / 255;
                        return .2126 * (s <= .03928 ? s / 12.92 : Math.pow((s + .055) / 1.055, 2.4)) + .7152 * (r <= .03928 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4)) + .0722 * (o <= .03928 ? o / 12.92 : Math.pow((o + .055) / 1.055, 2.4));
                    }
                    e.relativeLuminance = function(e) {
                        return t(e >> 16 & 255, e >> 8 & 255, 255 & e);
                    }, e.relativeLuminance2 = t;
                }(l = t.rgb || (t.rgb = {})), function(e) {
                    function t(e, t, i) {
                        const s = e >> 24 & 255, r = e >> 16 & 255, o = e >> 8 & 255;
                        let n = t >> 24 & 255, a = t >> 16 & 255, h = t >> 8 & 255, c = _(l.relativeLuminance2(n, a, h), l.relativeLuminance2(s, r, o));
                        for(; c < i && (n > 0 || a > 0 || h > 0);)n -= Math.max(0, Math.ceil(.1 * n)), a -= Math.max(0, Math.ceil(.1 * a)), h -= Math.max(0, Math.ceil(.1 * h)), c = _(l.relativeLuminance2(n, a, h), l.relativeLuminance2(s, r, o));
                        return (n << 24 | a << 16 | h << 8 | 255) >>> 0;
                    }
                    function i(e, t, i) {
                        const s = e >> 24 & 255, r = e >> 16 & 255, o = e >> 8 & 255;
                        let n = t >> 24 & 255, a = t >> 16 & 255, h = t >> 8 & 255, c = _(l.relativeLuminance2(n, a, h), l.relativeLuminance2(s, r, o));
                        for(; c < i && (n < 255 || a < 255 || h < 255);)n = Math.min(255, n + Math.ceil(.1 * (255 - n))), a = Math.min(255, a + Math.ceil(.1 * (255 - a))), h = Math.min(255, h + Math.ceil(.1 * (255 - h))), c = _(l.relativeLuminance2(n, a, h), l.relativeLuminance2(s, r, o));
                        return (n << 24 | a << 16 | h << 8 | 255) >>> 0;
                    }
                    e.ensureContrastRatio = function(e, s, r) {
                        const o = l.relativeLuminance(e >> 8), n = l.relativeLuminance(s >> 8);
                        if (_(o, n) < r) {
                            if (n < o) {
                                const n = t(e, s, r), a = _(o, l.relativeLuminance(n >> 8));
                                if (a < r) {
                                    const t = i(e, s, r);
                                    return a > _(o, l.relativeLuminance(t >> 8)) ? n : t;
                                }
                                return n;
                            }
                            const a = i(e, s, r), h = _(o, l.relativeLuminance(a >> 8));
                            if (h < r) {
                                const i = t(e, s, r);
                                return h > _(o, l.relativeLuminance(i >> 8)) ? a : i;
                            }
                            return a;
                        }
                    }, e.reduceLuminance = t, e.increaseLuminance = i, e.toChannels = function(e) {
                        return [
                            e >> 24 & 255,
                            e >> 16 & 255,
                            e >> 8 & 255,
                            255 & e
                        ];
                    }, e.toColor = function(e, t, i, s) {
                        return {
                            css: h.toCss(e, t, i, s),
                            rgba: h.toRgba(e, t, i, s)
                        };
                    };
                }(c = t.rgba || (t.rgba = {})), t.toPaddedHex = d, t.contrastRatio = _;
            },
            345: (e, t)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.forwardEvent = t.EventEmitter = void 0, t.EventEmitter = class {
                    constructor(){
                        this._listeners = [], this._disposed = !1;
                    }
                    get event() {
                        return this._event || (this._event = (e)=>(this._listeners.push(e), {
                                dispose: ()=>{
                                    if (!this._disposed) {
                                        for(let t = 0; t < this._listeners.length; t++)if (this._listeners[t] === e) return void this._listeners.splice(t, 1);
                                    }
                                }
                            })), this._event;
                    }
                    fire(e, t) {
                        const i = [];
                        for(let e = 0; e < this._listeners.length; e++)i.push(this._listeners[e]);
                        for(let s = 0; s < i.length; s++)i[s].call(void 0, e, t);
                    }
                    dispose() {
                        this._listeners && (this._listeners.length = 0), this._disposed = !0;
                    }
                }, t.forwardEvent = function(e, t) {
                    return e((e)=>t.fire(e));
                };
            },
            859: (e, t)=>{
                function i(e) {
                    for (const t of e)t.dispose();
                    e.length = 0;
                }
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.getDisposeArrayDisposable = t.disposeArray = t.toDisposable = t.Disposable = void 0, t.Disposable = class {
                    constructor(){
                        this._disposables = [], this._isDisposed = !1;
                    }
                    dispose() {
                        this._isDisposed = !0;
                        for (const e of this._disposables)e.dispose();
                        this._disposables.length = 0;
                    }
                    register(e) {
                        return this._disposables.push(e), e;
                    }
                    unregister(e) {
                        const t = this._disposables.indexOf(e);
                        -1 !== t && this._disposables.splice(t, 1);
                    }
                }, t.toDisposable = function(e) {
                    return {
                        dispose: e
                    };
                }, t.disposeArray = i, t.getDisposeArrayDisposable = function(e) {
                    return {
                        dispose: ()=>i(e)
                    };
                };
            },
            485: (e, t)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.FourKeyMap = t.TwoKeyMap = void 0;
                class i {
                    constructor(){
                        this._data = {};
                    }
                    set(e, t, i) {
                        this._data[e] || (this._data[e] = {}), this._data[e][t] = i;
                    }
                    get(e, t) {
                        return this._data[e] ? this._data[e][t] : void 0;
                    }
                    clear() {
                        this._data = {};
                    }
                }
                t.TwoKeyMap = i, t.FourKeyMap = class {
                    constructor(){
                        this._data = new i;
                    }
                    set(e, t, s, r, o) {
                        this._data.get(e, t) || this._data.set(e, t, new i), this._data.get(e, t).set(s, r, o);
                    }
                    get(e, t, i, s) {
                        var r;
                        return null === (r = this._data.get(e, t)) || void 0 === r ? void 0 : r.get(i, s);
                    }
                    clear() {
                        this._data.clear();
                    }
                };
            },
            399: (e, t)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.isChromeOS = t.isLinux = t.isWindows = t.isIphone = t.isIpad = t.isMac = t.getSafariVersion = t.isSafari = t.isLegacyEdge = t.isFirefox = t.isNode = void 0, t.isNode = "undefined" == typeof navigator;
                const i = t.isNode ? "node" : navigator.userAgent, s = t.isNode ? "node" : navigator.platform;
                t.isFirefox = i.includes("Firefox"), t.isLegacyEdge = i.includes("Edge"), t.isSafari = /^((?!chrome|android).)*safari/i.test(i), t.getSafariVersion = function() {
                    if (!t.isSafari) return 0;
                    const e = i.match(/Version\/(\d+)/);
                    return null === e || e.length < 2 ? 0 : parseInt(e[1]);
                }, t.isMac = [
                    "Macintosh",
                    "MacIntel",
                    "MacPPC",
                    "Mac68K"
                ].includes(s), t.isIpad = "iPad" === s, t.isIphone = "iPhone" === s, t.isWindows = [
                    "Windows",
                    "Win16",
                    "Win32",
                    "WinCE"
                ].includes(s), t.isLinux = s.indexOf("Linux") >= 0, t.isChromeOS = /\bCrOS\b/.test(i);
            },
            385: (e, t, i)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.DebouncedIdleTask = t.IdleTaskQueue = t.PriorityTaskQueue = void 0;
                const s = i(399);
                class r {
                    constructor(){
                        this._tasks = [], this._i = 0;
                    }
                    enqueue(e) {
                        this._tasks.push(e), this._start();
                    }
                    flush() {
                        for(; this._i < this._tasks.length;)this._tasks[this._i]() || this._i++;
                        this.clear();
                    }
                    clear() {
                        this._idleCallback && (this._cancelCallback(this._idleCallback), this._idleCallback = void 0), this._i = 0, this._tasks.length = 0;
                    }
                    _start() {
                        this._idleCallback || (this._idleCallback = this._requestCallback(this._process.bind(this)));
                    }
                    _process(e) {
                        this._idleCallback = void 0;
                        let t = 0, i = 0, s = e.timeRemaining(), r = 0;
                        for(; this._i < this._tasks.length;){
                            if (t = Date.now(), this._tasks[this._i]() || this._i++, t = Math.max(1, Date.now() - t), i = Math.max(t, i), r = e.timeRemaining(), 1.5 * i > r) return s - t < -20 && console.warn(`task queue exceeded allotted deadline by ${Math.abs(Math.round(s - t))}ms`), void this._start();
                            s = r;
                        }
                        this.clear();
                    }
                }
                class o extends r {
                    _requestCallback(e) {
                        return setTimeout(()=>e(this._createDeadline(16)));
                    }
                    _cancelCallback(e) {
                        clearTimeout(e);
                    }
                    _createDeadline(e) {
                        const t = Date.now() + e;
                        return {
                            timeRemaining: ()=>Math.max(0, t - Date.now())
                        };
                    }
                }
                t.PriorityTaskQueue = o, t.IdleTaskQueue = !s.isNode && "requestIdleCallback" in window ? class extends r {
                    _requestCallback(e) {
                        return requestIdleCallback(e);
                    }
                    _cancelCallback(e) {
                        cancelIdleCallback(e);
                    }
                } : o, t.DebouncedIdleTask = class {
                    constructor(){
                        this._queue = new t.IdleTaskQueue;
                    }
                    set(e) {
                        this._queue.clear(), this._queue.enqueue(e);
                    }
                    flush() {
                        this._queue.flush();
                    }
                };
            },
            147: (e, t)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.ExtendedAttrs = t.AttributeData = void 0;
                class i {
                    constructor(){
                        this.fg = 0, this.bg = 0, this.extended = new s;
                    }
                    static toColorRGB(e) {
                        return [
                            e >>> 16 & 255,
                            e >>> 8 & 255,
                            255 & e
                        ];
                    }
                    static fromColorRGB(e) {
                        return (255 & e[0]) << 16 | (255 & e[1]) << 8 | 255 & e[2];
                    }
                    clone() {
                        const e = new i;
                        return e.fg = this.fg, e.bg = this.bg, e.extended = this.extended.clone(), e;
                    }
                    isInverse() {
                        return 67108864 & this.fg;
                    }
                    isBold() {
                        return 134217728 & this.fg;
                    }
                    isUnderline() {
                        return this.hasExtendedAttrs() && 0 !== this.extended.underlineStyle ? 1 : 268435456 & this.fg;
                    }
                    isBlink() {
                        return 536870912 & this.fg;
                    }
                    isInvisible() {
                        return 1073741824 & this.fg;
                    }
                    isItalic() {
                        return 67108864 & this.bg;
                    }
                    isDim() {
                        return 134217728 & this.bg;
                    }
                    isStrikethrough() {
                        return 2147483648 & this.fg;
                    }
                    isProtected() {
                        return 536870912 & this.bg;
                    }
                    isOverline() {
                        return 1073741824 & this.bg;
                    }
                    getFgColorMode() {
                        return 50331648 & this.fg;
                    }
                    getBgColorMode() {
                        return 50331648 & this.bg;
                    }
                    isFgRGB() {
                        return 50331648 == (50331648 & this.fg);
                    }
                    isBgRGB() {
                        return 50331648 == (50331648 & this.bg);
                    }
                    isFgPalette() {
                        return 16777216 == (50331648 & this.fg) || 33554432 == (50331648 & this.fg);
                    }
                    isBgPalette() {
                        return 16777216 == (50331648 & this.bg) || 33554432 == (50331648 & this.bg);
                    }
                    isFgDefault() {
                        return 0 == (50331648 & this.fg);
                    }
                    isBgDefault() {
                        return 0 == (50331648 & this.bg);
                    }
                    isAttributeDefault() {
                        return 0 === this.fg && 0 === this.bg;
                    }
                    getFgColor() {
                        switch(50331648 & this.fg){
                            case 16777216:
                            case 33554432:
                                return 255 & this.fg;
                            case 50331648:
                                return 16777215 & this.fg;
                            default:
                                return -1;
                        }
                    }
                    getBgColor() {
                        switch(50331648 & this.bg){
                            case 16777216:
                            case 33554432:
                                return 255 & this.bg;
                            case 50331648:
                                return 16777215 & this.bg;
                            default:
                                return -1;
                        }
                    }
                    hasExtendedAttrs() {
                        return 268435456 & this.bg;
                    }
                    updateExtended() {
                        this.extended.isEmpty() ? this.bg &= -268435457 : this.bg |= 268435456;
                    }
                    getUnderlineColor() {
                        if (268435456 & this.bg && ~this.extended.underlineColor) switch(50331648 & this.extended.underlineColor){
                            case 16777216:
                            case 33554432:
                                return 255 & this.extended.underlineColor;
                            case 50331648:
                                return 16777215 & this.extended.underlineColor;
                            default:
                                return this.getFgColor();
                        }
                        return this.getFgColor();
                    }
                    getUnderlineColorMode() {
                        return 268435456 & this.bg && ~this.extended.underlineColor ? 50331648 & this.extended.underlineColor : this.getFgColorMode();
                    }
                    isUnderlineColorRGB() {
                        return 268435456 & this.bg && ~this.extended.underlineColor ? 50331648 == (50331648 & this.extended.underlineColor) : this.isFgRGB();
                    }
                    isUnderlineColorPalette() {
                        return 268435456 & this.bg && ~this.extended.underlineColor ? 16777216 == (50331648 & this.extended.underlineColor) || 33554432 == (50331648 & this.extended.underlineColor) : this.isFgPalette();
                    }
                    isUnderlineColorDefault() {
                        return 268435456 & this.bg && ~this.extended.underlineColor ? 0 == (50331648 & this.extended.underlineColor) : this.isFgDefault();
                    }
                    getUnderlineStyle() {
                        return 268435456 & this.fg ? 268435456 & this.bg ? this.extended.underlineStyle : 1 : 0;
                    }
                }
                t.AttributeData = i;
                class s {
                    constructor(e = 0, t = 0){
                        this._ext = 0, this._urlId = 0, this._ext = e, this._urlId = t;
                    }
                    get ext() {
                        return this._urlId ? -469762049 & this._ext | this.underlineStyle << 26 : this._ext;
                    }
                    set ext(e) {
                        this._ext = e;
                    }
                    get underlineStyle() {
                        return this._urlId ? 5 : (469762048 & this._ext) >> 26;
                    }
                    set underlineStyle(e) {
                        this._ext &= -469762049, this._ext |= e << 26 & 469762048;
                    }
                    get underlineColor() {
                        return 67108863 & this._ext;
                    }
                    set underlineColor(e) {
                        this._ext &= -67108864, this._ext |= 67108863 & e;
                    }
                    get urlId() {
                        return this._urlId;
                    }
                    set urlId(e) {
                        this._urlId = e;
                    }
                    clone() {
                        return new s(this._ext, this._urlId);
                    }
                    isEmpty() {
                        return 0 === this.underlineStyle && 0 === this._urlId;
                    }
                }
                t.ExtendedAttrs = s;
            },
            782: (e, t, i)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.CellData = void 0;
                const s = i(133), r = i(855), o = i(147);
                class n extends o.AttributeData {
                    constructor(){
                        super(...arguments), this.content = 0, this.fg = 0, this.bg = 0, this.extended = new o.ExtendedAttrs, this.combinedData = "";
                    }
                    static fromCharData(e) {
                        const t = new n;
                        return t.setFromCharData(e), t;
                    }
                    isCombined() {
                        return 2097152 & this.content;
                    }
                    getWidth() {
                        return this.content >> 22;
                    }
                    getChars() {
                        return 2097152 & this.content ? this.combinedData : 2097151 & this.content ? (0, s.stringFromCodePoint)(2097151 & this.content) : "";
                    }
                    getCode() {
                        return this.isCombined() ? this.combinedData.charCodeAt(this.combinedData.length - 1) : 2097151 & this.content;
                    }
                    setFromCharData(e) {
                        this.fg = e[r.CHAR_DATA_ATTR_INDEX], this.bg = 0;
                        let t = !1;
                        if (e[r.CHAR_DATA_CHAR_INDEX].length > 2) t = !0;
                        else if (2 === e[r.CHAR_DATA_CHAR_INDEX].length) {
                            const i = e[r.CHAR_DATA_CHAR_INDEX].charCodeAt(0);
                            if (55296 <= i && i <= 56319) {
                                const s = e[r.CHAR_DATA_CHAR_INDEX].charCodeAt(1);
                                56320 <= s && s <= 57343 ? this.content = 1024 * (i - 55296) + s - 56320 + 65536 | e[r.CHAR_DATA_WIDTH_INDEX] << 22 : t = !0;
                            } else t = !0;
                        } else this.content = e[r.CHAR_DATA_CHAR_INDEX].charCodeAt(0) | e[r.CHAR_DATA_WIDTH_INDEX] << 22;
                        t && (this.combinedData = e[r.CHAR_DATA_CHAR_INDEX], this.content = 2097152 | e[r.CHAR_DATA_WIDTH_INDEX] << 22);
                    }
                    getAsCharData() {
                        return [
                            this.fg,
                            this.getChars(),
                            this.getWidth(),
                            this.getCode()
                        ];
                    }
                }
                t.CellData = n;
            },
            855: (e, t)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.WHITESPACE_CELL_CODE = t.WHITESPACE_CELL_WIDTH = t.WHITESPACE_CELL_CHAR = t.NULL_CELL_CODE = t.NULL_CELL_WIDTH = t.NULL_CELL_CHAR = t.CHAR_DATA_CODE_INDEX = t.CHAR_DATA_WIDTH_INDEX = t.CHAR_DATA_CHAR_INDEX = t.CHAR_DATA_ATTR_INDEX = t.DEFAULT_EXT = t.DEFAULT_ATTR = t.DEFAULT_COLOR = void 0, t.DEFAULT_COLOR = 0, t.DEFAULT_ATTR = 256 | t.DEFAULT_COLOR << 9, t.DEFAULT_EXT = 0, t.CHAR_DATA_ATTR_INDEX = 0, t.CHAR_DATA_CHAR_INDEX = 1, t.CHAR_DATA_WIDTH_INDEX = 2, t.CHAR_DATA_CODE_INDEX = 3, t.NULL_CELL_CHAR = "", t.NULL_CELL_WIDTH = 1, t.NULL_CELL_CODE = 0, t.WHITESPACE_CELL_CHAR = " ", t.WHITESPACE_CELL_WIDTH = 1, t.WHITESPACE_CELL_CODE = 32;
            },
            133: (e, t)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.Utf8ToUtf32 = t.StringToUtf32 = t.utf32ToString = t.stringFromCodePoint = void 0, t.stringFromCodePoint = function(e) {
                    return e > 65535 ? (e -= 65536, String.fromCharCode(55296 + (e >> 10)) + String.fromCharCode(e % 1024 + 56320)) : String.fromCharCode(e);
                }, t.utf32ToString = function(e, t = 0, i = e.length) {
                    let s = "";
                    for(let r = t; r < i; ++r){
                        let t = e[r];
                        t > 65535 ? (t -= 65536, s += String.fromCharCode(55296 + (t >> 10)) + String.fromCharCode(t % 1024 + 56320)) : s += String.fromCharCode(t);
                    }
                    return s;
                }, t.StringToUtf32 = class {
                    constructor(){
                        this._interim = 0;
                    }
                    clear() {
                        this._interim = 0;
                    }
                    decode(e, t) {
                        const i = e.length;
                        if (!i) return 0;
                        let s = 0, r = 0;
                        if (this._interim) {
                            const i = e.charCodeAt(r++);
                            56320 <= i && i <= 57343 ? t[s++] = 1024 * (this._interim - 55296) + i - 56320 + 65536 : (t[s++] = this._interim, t[s++] = i), this._interim = 0;
                        }
                        for(let o = r; o < i; ++o){
                            const r = e.charCodeAt(o);
                            if (55296 <= r && r <= 56319) {
                                if (++o >= i) return this._interim = r, s;
                                const n = e.charCodeAt(o);
                                56320 <= n && n <= 57343 ? t[s++] = 1024 * (r - 55296) + n - 56320 + 65536 : (t[s++] = r, t[s++] = n);
                            } else 65279 !== r && (t[s++] = r);
                        }
                        return s;
                    }
                }, t.Utf8ToUtf32 = class {
                    constructor(){
                        this.interim = new Uint8Array(3);
                    }
                    clear() {
                        this.interim.fill(0);
                    }
                    decode(e, t) {
                        const i = e.length;
                        if (!i) return 0;
                        let s, r, o, n, a = 0, h = 0, l = 0;
                        if (this.interim[0]) {
                            let s = !1, r = this.interim[0];
                            r &= 192 == (224 & r) ? 31 : 224 == (240 & r) ? 15 : 7;
                            let o, n = 0;
                            for(; (o = 63 & this.interim[++n]) && n < 4;)r <<= 6, r |= o;
                            const h = 192 == (224 & this.interim[0]) ? 2 : 224 == (240 & this.interim[0]) ? 3 : 4, c = h - n;
                            for(; l < c;){
                                if (l >= i) return 0;
                                if (o = e[l++], 128 != (192 & o)) {
                                    l--, s = !0;
                                    break;
                                }
                                this.interim[n++] = o, r <<= 6, r |= 63 & o;
                            }
                            s || (2 === h ? r < 128 ? l-- : t[a++] = r : 3 === h ? r < 2048 || r >= 55296 && r <= 57343 || 65279 === r || (t[a++] = r) : r < 65536 || r > 1114111 || (t[a++] = r)), this.interim.fill(0);
                        }
                        const c = i - 4;
                        let d = l;
                        for(; d < i;){
                            for(; !(!(d < c) || 128 & (s = e[d]) || 128 & (r = e[d + 1]) || 128 & (o = e[d + 2]) || 128 & (n = e[d + 3]));)t[a++] = s, t[a++] = r, t[a++] = o, t[a++] = n, d += 4;
                            if (s = e[d++], s < 128) t[a++] = s;
                            else if (192 == (224 & s)) {
                                if (d >= i) return this.interim[0] = s, a;
                                if (r = e[d++], 128 != (192 & r)) {
                                    d--;
                                    continue;
                                }
                                if (h = (31 & s) << 6 | 63 & r, h < 128) {
                                    d--;
                                    continue;
                                }
                                t[a++] = h;
                            } else if (224 == (240 & s)) {
                                if (d >= i) return this.interim[0] = s, a;
                                if (r = e[d++], 128 != (192 & r)) {
                                    d--;
                                    continue;
                                }
                                if (d >= i) return this.interim[0] = s, this.interim[1] = r, a;
                                if (o = e[d++], 128 != (192 & o)) {
                                    d--;
                                    continue;
                                }
                                if (h = (15 & s) << 12 | (63 & r) << 6 | 63 & o, h < 2048 || h >= 55296 && h <= 57343 || 65279 === h) continue;
                                t[a++] = h;
                            } else if (240 == (248 & s)) {
                                if (d >= i) return this.interim[0] = s, a;
                                if (r = e[d++], 128 != (192 & r)) {
                                    d--;
                                    continue;
                                }
                                if (d >= i) return this.interim[0] = s, this.interim[1] = r, a;
                                if (o = e[d++], 128 != (192 & o)) {
                                    d--;
                                    continue;
                                }
                                if (d >= i) return this.interim[0] = s, this.interim[1] = r, this.interim[2] = o, a;
                                if (n = e[d++], 128 != (192 & n)) {
                                    d--;
                                    continue;
                                }
                                if (h = (7 & s) << 18 | (63 & r) << 12 | (63 & o) << 6 | 63 & n, h < 65536 || h > 1114111) continue;
                                t[a++] = h;
                            }
                        }
                        return a;
                    }
                };
            },
            726: (e, t)=>{
                function i(e, t, i) {
                    t.di$target === t ? t.di$dependencies.push({
                        id: e,
                        index: i
                    }) : (t.di$dependencies = [
                        {
                            id: e,
                            index: i
                        }
                    ], t.di$target = t);
                }
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.createDecorator = t.getServiceDependencies = t.serviceRegistry = void 0, t.serviceRegistry = new Map, t.getServiceDependencies = function(e) {
                    return e.di$dependencies || [];
                }, t.createDecorator = function(e) {
                    if (t.serviceRegistry.has(e)) return t.serviceRegistry.get(e);
                    const s = function(e, t, r) {
                        if (3 !== arguments.length) throw new Error("@IServiceName-decorator can only be used to decorate a parameter");
                        i(s, e, r);
                    };
                    return s.toString = ()=>e, t.serviceRegistry.set(e, s), s;
                };
            },
            97: (e, t, i)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.IDecorationService = t.IUnicodeService = t.IOscLinkService = t.IOptionsService = t.ILogService = t.LogLevelEnum = t.IInstantiationService = t.ICharsetService = t.ICoreService = t.ICoreMouseService = t.IBufferService = void 0;
                const s = i(726);
                var r;
                t.IBufferService = (0, s.createDecorator)("BufferService"), t.ICoreMouseService = (0, s.createDecorator)("CoreMouseService"), t.ICoreService = (0, s.createDecorator)("CoreService"), t.ICharsetService = (0, s.createDecorator)("CharsetService"), t.IInstantiationService = (0, s.createDecorator)("InstantiationService"), (r = t.LogLevelEnum || (t.LogLevelEnum = {}))[r.DEBUG = 0] = "DEBUG", r[r.INFO = 1] = "INFO", r[r.WARN = 2] = "WARN", r[r.ERROR = 3] = "ERROR", r[r.OFF = 4] = "OFF", t.ILogService = (0, s.createDecorator)("LogService"), t.IOptionsService = (0, s.createDecorator)("OptionsService"), t.IOscLinkService = (0, s.createDecorator)("OscLinkService"), t.IUnicodeService = (0, s.createDecorator)("UnicodeService"), t.IDecorationService = (0, s.createDecorator)("DecorationService");
            }
        }, t = {};
        function i(s) {
            var r = t[s];
            if (void 0 !== r) return r.exports;
            var o = t[s] = {
                exports: {}
            };
            return e[s].call(o.exports, o, o.exports, i), o.exports;
        }
        var s = {};
        return (()=>{
            var e = s;
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.CanvasAddon = void 0;
            const t = i(949), r = i(345), o = i(859);
            class n extends o.Disposable {
                constructor(){
                    super(...arguments), this._onChangeTextureAtlas = this.register(new r.EventEmitter), this.onChangeTextureAtlas = this._onChangeTextureAtlas.event, this._onAddTextureAtlasCanvas = this.register(new r.EventEmitter), this.onAddTextureAtlasCanvas = this._onAddTextureAtlasCanvas.event;
                }
                get textureAtlas() {
                    var e;
                    return null === (e = this._renderer) || void 0 === e ? void 0 : e.textureAtlas;
                }
                activate(e) {
                    const i = e._core;
                    if (!e.element) return void this.register(i.onWillOpen(()=>this.activate(e)));
                    this._terminal = e;
                    const s = i.coreService, n = i.optionsService, a = i.screenElement, h = i.linkifier2, l = i, c = l._bufferService, d = l._renderService, _ = l._characterJoinerService, u = l._charSizeService, g = l._coreBrowserService, f = l._decorationService, v = l._themeService;
                    this._renderer = new t.CanvasRenderer(e, a, h, c, u, n, _, s, g, f, v), this.register((0, r.forwardEvent)(this._renderer.onChangeTextureAtlas, this._onChangeTextureAtlas)), this.register((0, r.forwardEvent)(this._renderer.onAddTextureAtlasCanvas, this._onAddTextureAtlasCanvas)), d.setRenderer(this._renderer), d.handleResize(c.cols, c.rows), this.register((0, o.toDisposable)(()=>{
                        var t;
                        d.setRenderer(this._terminal._core._createRenderer()), d.handleResize(e.cols, e.rows), null === (t = this._renderer) || void 0 === t || t.dispose(), this._renderer = void 0;
                    }));
                }
            }
            e.CanvasAddon = n;
        })(), s;
    })());

},{}],"a5mjI":[function(require,module,exports) {
!function(e, t) {
    module.exports = t();
}(self, function() {
    return (()=>{
        "use strict";
        var e = {};
        return (()=>{
            var t = e;
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.FitAddon = void 0, t.FitAddon = class {
                constructor(){}
                activate(e) {
                    this._terminal = e;
                }
                dispose() {}
                fit() {
                    const e = this.proposeDimensions();
                    if (!e || !this._terminal || isNaN(e.cols) || isNaN(e.rows)) return;
                    const t = this._terminal._core;
                    this._terminal.rows === e.rows && this._terminal.cols === e.cols || (t._renderService.clear(), this._terminal.resize(e.cols, e.rows));
                }
                proposeDimensions() {
                    if (!this._terminal) return;
                    if (!this._terminal.element || !this._terminal.element.parentElement) return;
                    const e = this._terminal._core, t = e._renderService.dimensions;
                    if (0 === t.css.cell.width || 0 === t.css.cell.height) return;
                    const r = 0 === this._terminal.options.scrollback ? 0 : e.viewport.scrollBarWidth, i = window.getComputedStyle(this._terminal.element.parentElement), o = parseInt(i.getPropertyValue("height")), s = Math.max(0, parseInt(i.getPropertyValue("width"))), n = window.getComputedStyle(this._terminal.element), l = o - (parseInt(n.getPropertyValue("padding-top")) + parseInt(n.getPropertyValue("padding-bottom"))), a = s - (parseInt(n.getPropertyValue("padding-right")) + parseInt(n.getPropertyValue("padding-left"))) - r;
                    return {
                        cols: Math.max(2, Math.floor(a / t.css.cell.width)),
                        rows: Math.max(1, Math.floor(l / t.css.cell.height))
                    };
                }
            };
        })(), e;
    })();
});

},{}],"4b1al":[function(require,module,exports) {
/*! For license information please see xterm-addon-ligatures.js.LICENSE.txt */ var Buffer = require("a4c943ac8d0ae08e").Buffer;
var process = require("d50bdfad8e7bc7fb");
!function(e, t) {
    module.exports = t(require("62aeebf80b25c1cc"), require("fc9f6822e334ea8e"), require("74a0c9acd25cd8f1"), require("5c75180993035de"));
}(self, function(e, t, n, s) {
    return (()=>{
        var o = {
            185: (e, t)=>{
                "use strict";
                function n(e) {
                    const t = {};
                    for (const [n, o] of Object.entries(e.individual))t[n] = s(o);
                    for (const { range: n, entry: o } of e.range){
                        const e = s(o);
                        for(let s = n[0]; s < n[1]; s++)t[s] = e;
                    }
                    return t;
                }
                function s(e) {
                    const t = {};
                    return e.forward && (t.forward = n(e.forward)), e.reverse && (t.reverse = n(e.reverse)), e.lookup && (t.lookup = e.lookup), t;
                }
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = n;
            },
            98: (e, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                const s = n(602), o = n(593), r = n(233), a = n(694), i = n(532), l = n(595), u = n(223), c = n(439), p = n(349), f = n(185);
                class h {
                    constructor(e, t){
                        this._lookupTrees = [], this._glyphLookups = {}, this._font = e, t.cacheSize > 0 && (this._cache = new o({
                            max: t.cacheSize,
                            length: (e, t)=>t.length
                        }));
                        const n = (this._font.tables.gsub && this._font.tables.gsub.features.filter((e)=>"calt" === e.tag) || []).reduce((e, t)=>[
                                ...e,
                                ...t.feature.lookupListIndexes
                            ], []), s = this._font.tables.gsub && this._font.tables.gsub.lookups || [], a = s.filter((e, t)=>n.some((e)=>e === t));
                        for (const [e, t] of a.entries()){
                            const n = [];
                            switch(t.lookupType){
                                case 6:
                                    for (const [e, o] of t.subtables.entries())switch(o.substFormat){
                                        case 1:
                                            n.push(l.default(o, s, e));
                                            break;
                                        case 2:
                                            n.push(u.default(o, s, e));
                                            break;
                                        case 3:
                                            n.push(c.default(o, s, e));
                                    }
                                    break;
                                case 8:
                                    for (const [e, s] of t.subtables.entries())n.push(p.default(s, e));
                            }
                            const o = f.default(r.default(n));
                            this._lookupTrees.push({
                                tree: o,
                                processForward: 8 !== t.lookupType
                            });
                            for (const t of Object.keys(o))this._glyphLookups[t] || (this._glyphLookups[t] = []), this._glyphLookups[t].push(e);
                        }
                    }
                    findLigatures(e) {
                        const t = this._cache && this._cache.get(e);
                        if (t && !Array.isArray(t)) return t;
                        const n = [];
                        for (const t of e)n.push(this._font.charToGlyphIndex(t));
                        if (0 === this._lookupTrees.length) return {
                            inputGlyphs: n,
                            outputGlyphs: n,
                            contextRanges: []
                        };
                        const s = this._findInternal(n.slice()), o = {
                            inputGlyphs: n,
                            outputGlyphs: s.sequence,
                            contextRanges: s.ranges
                        };
                        return this._cache && this._cache.set(e, o), o;
                    }
                    findLigatureRanges(e) {
                        if (0 === this._lookupTrees.length) return [];
                        const t = this._cache && this._cache.get(e);
                        if (t) return Array.isArray(t) ? t : t.contextRanges;
                        const n = [];
                        for (const t of e)n.push(this._font.charToGlyphIndex(t));
                        const s = this._findInternal(n);
                        return this._cache && this._cache.set(e, s.ranges), s.ranges;
                    }
                    _findInternal(e) {
                        const t = [];
                        let n = this._getNextLookup(e, 0);
                        for(; null !== n.index;){
                            const s = this._lookupTrees[n.index];
                            if (s.processForward) {
                                let o = n.last;
                                for(let r = n.first; r < o; r++){
                                    const n = a.default(s.tree, e, r, r);
                                    if (n) {
                                        for(let t = 0; t < n.substitutions.length; t++){
                                            const s = n.substitutions[t];
                                            null !== s && (e[r + t] = s);
                                        }
                                        i.default(t, n.contextRange[0] + r, n.contextRange[1] + r), r + n.length >= o && (o = r + n.length + 1), r += n.length - 1;
                                    }
                                }
                            } else for(let o = n.last - 1; o >= n.first; o--){
                                const n = a.default(s.tree, e, o, o);
                                if (n) {
                                    for(let t = 0; t < n.substitutions.length; t++){
                                        const s = n.substitutions[t];
                                        null !== s && (e[o + t] = s);
                                    }
                                    i.default(t, n.contextRange[0] + o, n.contextRange[1] + o), o -= n.length - 1;
                                }
                            }
                            n = this._getNextLookup(e, n.index + 1);
                        }
                        return {
                            sequence: e,
                            ranges: t
                        };
                    }
                    _getNextLookup(e, t) {
                        const n = {
                            index: null,
                            first: 1 / 0,
                            last: -1
                        };
                        for(let s = 0; s < e.length; s++){
                            const o = this._glyphLookups[e[s]];
                            if (o) for(let e = 0; e < o.length; e++){
                                const r = o[e];
                                if (r >= t) {
                                    (null === n.index || r <= n.index) && (n.index = r, n.first > s && (n.first = s), n.last = s + 1);
                                    break;
                                }
                            }
                        }
                        return n;
                    }
                }
                async function d(e, t) {
                    const o = await Promise.resolve().then(()=>n(269)).then((t)=>t.promisify(s.load)(e));
                    return new h(o, Object.assign({
                        cacheSize: 0
                    }, t));
                }
                t.load = async function(e, t) {
                    const [s] = await Promise.resolve().then(()=>n(781)).then((t)=>t.listVariants(e));
                    if (!s) throw new Error(`Font ${e} not found`);
                    return d(s.path, t);
                }, t.loadFile = d, t.loadBuffer = function(e, t) {
                    const n = s.parse(e);
                    return new h(n, Object.assign({
                        cacheSize: 0
                    }, t));
                };
            },
            233: (e, t)=>{
                "use strict";
                function n(e, t) {
                    for (const [n, o] of Object.entries(t.individual))if (e.individual[n]) s(e.individual[n], o);
                    else {
                        let t = !1;
                        for (const [a, { range: l, entry: u }] of e.range.entries()){
                            const c = r(Number(n), l);
                            if (null !== c.both) {
                                t = !0, e.individual[n] = o, s(e.individual[n], i(u)), e.range.splice(a, 1);
                                for (const t of c.second)Array.isArray(t) ? e.range.push({
                                    range: t,
                                    entry: i(u)
                                }) : e.individual[t] = i(u);
                            }
                        }
                        t || (e.individual[n] = o);
                    }
                    for (const { range: n, entry: a } of t.range){
                        let t = [
                            n
                        ];
                        for(let n = 0; n < e.range.length; n++){
                            const { range: l, entry: u } = e.range[n];
                            for (const [c, p] of t.entries()){
                                if (!Array.isArray(p)) {
                                    const o = r(p, l);
                                    if (null === o.both) continue;
                                    e.individual[p] = i(a), s(e.individual[p], i(u)), e.range.splice(n, 1), n--;
                                    for (const t of o.second)Array.isArray(t) ? e.range.push({
                                        range: t,
                                        entry: i(u)
                                    }) : e.individual[t] = i(u);
                                    t.splice(c, 1, ...o.first);
                                    break;
                                }
                                {
                                    const r = o(p, l);
                                    if (null === r.both) continue;
                                    e.range.splice(n, 1), n--;
                                    const c = i(u);
                                    Array.isArray(r.both) ? e.range.push({
                                        range: r.both,
                                        entry: c
                                    }) : e.individual[r.both] = c, s(c, i(a));
                                    for (const t of r.second)Array.isArray(t) ? e.range.push({
                                        range: t,
                                        entry: i(u)
                                    }) : e.individual[t] = i(u);
                                    t = r.first;
                                }
                            }
                        }
                        for (const n of Object.keys(e.individual))for (const [o, l] of t.entries()){
                            if (Array.isArray(l)) {
                                const u = r(Number(n), l);
                                if (null === u.both) continue;
                                s(e.individual[n], i(a)), t.splice(o, 1, ...u.second);
                                break;
                            }
                            if (Number(n) === l) {
                                s(e.individual[n], i(a));
                                break;
                            }
                        }
                        for (const n of t)Array.isArray(n) ? e.range.push({
                            range: n,
                            entry: i(a)
                        }) : e.individual[n] = i(a);
                    }
                }
                function s(e, t) {
                    t.lookup && (!e.lookup || e.lookup.index > t.lookup.index || e.lookup.index === t.lookup.index && e.lookup.subIndex > t.lookup.subIndex) && (e.lookup = t.lookup), t.forward && (e.forward ? n(e.forward, t.forward) : e.forward = t.forward), t.reverse && (e.reverse ? n(e.reverse, t.reverse) : e.reverse = t.reverse);
                }
                function o(e, t) {
                    const n = {
                        first: [],
                        second: [],
                        both: null
                    };
                    if (e[0] < t[1] && t[0] < e[1]) {
                        const s = Math.max(e[0], t[0]), o = Math.min(e[1], t[1]);
                        n.both = a(s, o);
                    }
                    if (e[0] < t[0]) {
                        const s = e[0], o = Math.min(t[0], e[1]);
                        n.first.push(a(s, o));
                    } else if (t[0] < e[0]) {
                        const s = t[0], o = Math.min(t[1], e[0]);
                        n.second.push(a(s, o));
                    }
                    if (e[1] > t[1]) {
                        const s = Math.max(e[0], t[1]), o = e[1];
                        n.first.push(a(s, o));
                    } else if (t[1] > e[1]) {
                        const s = Math.max(e[1], t[0]), o = t[1];
                        n.second.push(a(s, o));
                    }
                    return n;
                }
                function r(e, t) {
                    if (e < t[0] || e > t[1]) return {
                        first: [
                            e
                        ],
                        second: [
                            t
                        ],
                        both: null
                    };
                    const n = {
                        first: [],
                        second: [],
                        both: e
                    };
                    return t[0] < e && n.second.push(a(t[0], e)), t[1] > e && n.second.push(a(e + 1, t[1])), n;
                }
                function a(e, t) {
                    return t - e == 1 ? e : [
                        e,
                        t
                    ];
                }
                function i(e) {
                    const t = {};
                    return e.forward && (t.forward = l(e.forward)), e.reverse && (t.reverse = l(e.reverse)), e.lookup && (t.lookup = {
                        contextRange: e.lookup.contextRange.slice(),
                        index: e.lookup.index,
                        length: e.lookup.length,
                        subIndex: e.lookup.subIndex,
                        substitutions: e.lookup.substitutions.slice()
                    }), t;
                }
                function l(e) {
                    const t = {};
                    for (const [n, s] of Object.entries(e.individual))t[n] = i(s);
                    return {
                        individual: t,
                        range: e.range.map(({ range: e, entry: t })=>({
                                range: e.slice(),
                                entry: i(t)
                            }))
                    };
                }
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e) {
                    const t = {
                        individual: {},
                        range: []
                    };
                    for (const s of e)n(t, s);
                    return t;
                };
            },
            532: (e, t)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e, t, n) {
                    let s = !1;
                    for(let o = 0; o < e.length; o++){
                        const r = e[o];
                        if (s) {
                            if (n <= r[0]) return e[o - 1][1] = n, e;
                            if (n <= r[1]) return e[o - 1][1] = Math.max(n, r[1]), e.splice(o, 1), s = !1, e;
                            e.splice(o, 1), o--;
                        } else {
                            if (n <= r[0]) return e.splice(o, 0, [
                                t,
                                n
                            ]), e;
                            if (n <= r[1]) return r[0] = Math.min(t, r[0]), e;
                            if (!(t < r[1])) continue;
                            r[0] = Math.min(t, r[0]), s = !0;
                        }
                    }
                    return s ? e[e.length - 1][1] = n : e.push([
                        t,
                        n
                    ]), e;
                };
            },
            595: (e, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                const s = n(283), o = n(267);
                t.default = function(e, t, n) {
                    const r = {
                        individual: {},
                        range: []
                    }, a = s.listGlyphsByIndex(e.coverage);
                    for (const { glyphId: s, index: i } of a){
                        const a = e.chainRuleSets[i];
                        if (a) for (const [e, i] of a.entries()){
                            let a = o.getInputTree(r, i.lookupRecords, t, 0, s).map(({ entry: e, substitution: t })=>({
                                    entry: e,
                                    substitutions: [
                                        t
                                    ]
                                }));
                            for (const [e, n] of i.input.entries())a = o.processInputPosition([
                                n
                            ], e + 1, a, i.lookupRecords, t);
                            for (const e of i.lookahead)a = o.processLookaheadPosition([
                                e
                            ], a);
                            for (const e of i.backtrack)a = o.processBacktrackPosition([
                                e
                            ], a);
                            for (const { entry: t, substitutions: s } of a)t.lookup = {
                                substitutions: s,
                                length: i.input.length + 1,
                                index: n,
                                subIndex: e,
                                contextRange: [
                                    -1 * i.backtrack.length,
                                    1 + i.input.length + i.lookahead.length
                                ]
                            };
                        }
                    }
                    return r;
                };
            },
            223: (e, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                const s = n(233), o = n(283), r = n(91), a = n(267);
                t.default = function(e, t, n) {
                    const i = [], l = o.listGlyphsByIndex(e.coverage);
                    for (const { glyphId: s } of l){
                        const o = r.default(e.inputClassDef, s);
                        for (const [s, l] of o.entries()){
                            if (null === l) continue;
                            const o = e.chainClassSet[l];
                            if (o) for (const [l, u] of o.entries()){
                                const o = {
                                    individual: {},
                                    range: []
                                };
                                let c = a.getInputTree(o, u.lookupRecords, t, 0, s).map(({ entry: e, substitution: t })=>({
                                        entry: e,
                                        substitutions: [
                                            t
                                        ]
                                    }));
                                for (const [n, s] of u.input.entries())c = a.processInputPosition(r.listClassGlyphs(e.inputClassDef, s), n + 1, c, u.lookupRecords, t);
                                for (const t of u.lookahead)c = a.processLookaheadPosition(r.listClassGlyphs(e.lookaheadClassDef, t), c);
                                for (const t of u.backtrack)c = a.processBacktrackPosition(r.listClassGlyphs(e.backtrackClassDef, t), c);
                                for (const { entry: e, substitutions: t } of c)e.lookup = {
                                    substitutions: t,
                                    index: n,
                                    subIndex: l,
                                    length: u.input.length + 1,
                                    contextRange: [
                                        -1 * u.backtrack.length,
                                        1 + u.input.length + u.lookahead.length
                                    ]
                                };
                                i.push(o);
                            }
                        }
                    }
                    return s.default(i);
                };
            },
            439: (e, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                const s = n(283), o = n(267);
                t.default = function(e, t, n) {
                    const r = {
                        individual: {},
                        range: []
                    }, a = s.listGlyphsByIndex(e.inputCoverage[0]);
                    for (const { glyphId: i } of a){
                        let a = o.getInputTree(r, e.lookupRecords, t, 0, i).map(({ entry: e, substitution: t })=>({
                                entry: e,
                                substitutions: [
                                    t
                                ]
                            }));
                        for (const [n, r] of e.inputCoverage.slice(1).entries())a = o.processInputPosition(s.listGlyphsByIndex(r).map((e)=>e.glyphId), n + 1, a, e.lookupRecords, t);
                        for (const t of e.lookaheadCoverage)a = o.processLookaheadPosition(s.listGlyphsByIndex(t).map((e)=>e.glyphId), a);
                        for (const t of e.backtrackCoverage)a = o.processBacktrackPosition(s.listGlyphsByIndex(t).map((e)=>e.glyphId), a);
                        for (const { entry: t, substitutions: s } of a)t.lookup = {
                            substitutions: s,
                            index: n,
                            subIndex: 0,
                            length: e.inputCoverage.length,
                            contextRange: [
                                -1 * e.backtrackCoverage.length,
                                e.inputCoverage.length + e.lookaheadCoverage.length
                            ]
                        };
                    }
                    return r;
                };
            },
            349: (e, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                const s = n(283), o = n(267);
                t.default = function(e, t) {
                    const n = {
                        individual: {},
                        range: []
                    }, r = s.listGlyphsByIndex(e.coverage);
                    for (const { glyphId: a, index: i } of r){
                        const r = {};
                        Array.isArray(a) ? n.range.push({
                            entry: r,
                            range: a
                        }) : n.individual[a] = r;
                        let l = [
                            {
                                entry: r,
                                substitutions: [
                                    e.substitutes[i]
                                ]
                            }
                        ];
                        for (const t of e.lookaheadCoverage)l = o.processLookaheadPosition(s.listGlyphsByIndex(t).map((e)=>e.glyphId), l);
                        for (const t of e.backtrackCoverage)l = o.processBacktrackPosition(s.listGlyphsByIndex(t).map((e)=>e.glyphId), l);
                        for (const { entry: n, substitutions: s } of l)n.lookup = {
                            substitutions: s,
                            index: t,
                            subIndex: 0,
                            length: 1,
                            contextRange: [
                                -1 * e.backtrackCoverage.length,
                                1 + e.lookaheadCoverage.length
                            ]
                        };
                    }
                    return n;
                };
            },
            91: (e, t)=>{
                "use strict";
                function n(e, t) {
                    for (const n of e.ranges)if (n.start <= t && n.end >= t) return n.classId;
                    return null;
                }
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e, t) {
                    return 2 === e.format ? Array.isArray(t) ? function(e, t) {
                        let s = t[0], o = n(e, s), r = t[0] + 1;
                        const a = new Map;
                        for(; r < t[1];)n(e, r) !== o && (r - s <= 1 ? a.set(s, o) : a.set([
                            s,
                            r
                        ], o)), r++;
                        return r - s <= 1 ? a.set(s, o) : a.set([
                            s,
                            r
                        ], o), a;
                    }(e, t) : new Map([
                        [
                            t,
                            n(e, t)
                        ]
                    ]) : new Map([
                        [
                            t,
                            null
                        ]
                    ]);
                }, t.listClassGlyphs = function(e, t) {
                    if (2 === e.format) {
                        const n = [];
                        for (const s of e.ranges)s.classId === t && (s.end === s.start ? n.push(s.start) : n.push([
                            s.start,
                            s.end + 1
                        ]));
                        return n;
                    }
                    return [];
                };
            },
            283: (e, t)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e, t) {
                    switch(e.format){
                        case 1:
                            const n = e.glyphs.indexOf(t);
                            return -1 !== n ? n : null;
                        case 2:
                            const s = e.ranges.find((e)=>e.start <= t && e.end >= t);
                            return s ? s.index : null;
                    }
                }, t.listGlyphsByIndex = function(e) {
                    switch(e.format){
                        case 1:
                            return e.glyphs.map((e, t)=>({
                                    glyphId: e,
                                    index: t
                                }));
                        case 2:
                            let t = [];
                            for (const [n, s] of e.ranges.entries())s.end === s.start ? t.push({
                                glyphId: s.start,
                                index: n
                            }) : t.push({
                                glyphId: [
                                    s.start,
                                    s.end + 1
                                ],
                                index: n
                            });
                            return t;
                    }
                };
            },
            267: (e, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                const s = n(603);
                function o(e, t, n, o, a) {
                    const i = [];
                    if (Array.isArray(a)) {
                        const r = function(e, t, n, o) {
                            for (const r of e.filter((e)=>e.sequenceIndex === n))for (const e of t[r.lookupListIndex].subtables){
                                const t = s.getRangeSubstitutionGlyphs(e, o);
                                if (!Array.from(t.values()).every((e)=>null !== e)) return t;
                            }
                            return new Map([
                                [
                                    o,
                                    null
                                ]
                            ]);
                        }(t, n, o, a);
                        for (const [t, n] of r){
                            const s = {};
                            Array.isArray(t) ? e.range.push({
                                range: t,
                                entry: s
                            }) : e.individual[t] = {}, i.push({
                                entry: s,
                                substitution: n
                            });
                        }
                    } else e.individual[a] = {}, i.push({
                        entry: e.individual[a],
                        substitution: r(t, n, o, a)
                    });
                    return i;
                }
                function r(e, t, n, o) {
                    for (const r of e.filter((e)=>e.sequenceIndex === n))for (const e of t[r.lookupListIndex].subtables){
                        const t = s.getIndividualSubstitutionGlyph(e, o);
                        if (null !== t) return t;
                    }
                    return null;
                }
                t.processInputPosition = function(e, t, n, s, r) {
                    const a = [];
                    for (const i of n){
                        i.entry.forward = {
                            individual: {},
                            range: []
                        };
                        for (const n of e)a.push(...o(i.entry.forward, s, r, t, n).map(({ entry: e, substitution: t })=>({
                                entry: e,
                                substitutions: [
                                    ...i.substitutions,
                                    t
                                ]
                            })));
                    }
                    return a;
                }, t.processLookaheadPosition = function(e, t) {
                    const n = [];
                    for (const s of t)for (const t of e){
                        const e = {};
                        s.entry.forward || (s.entry.forward = {
                            individual: {},
                            range: []
                        }), n.push({
                            entry: e,
                            substitutions: s.substitutions
                        }), Array.isArray(t) ? s.entry.forward.range.push({
                            entry: e,
                            range: t
                        }) : s.entry.forward.individual[t] = e;
                    }
                    return n;
                }, t.processBacktrackPosition = function(e, t) {
                    const n = [];
                    for (const s of t)for (const t of e){
                        const e = {};
                        s.entry.reverse || (s.entry.reverse = {
                            individual: {},
                            range: []
                        }), n.push({
                            entry: e,
                            substitutions: s.substitutions
                        }), Array.isArray(t) ? s.entry.reverse.range.push({
                            entry: e,
                            range: t
                        }) : s.entry.reverse.individual[t] = e;
                    }
                    return n;
                }, t.getInputTree = o;
            },
            603: (e, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                const s = n(283);
                function o(e, t) {
                    const n = s.default(e.coverage, t);
                    if (null === n) return null;
                    switch(e.substFormat){
                        case 1:
                            return (t + e.deltaGlyphId) % 65536;
                        case 2:
                            return null != e.substitute[n] ? e.substitute[n] : null;
                    }
                }
                t.getRangeSubstitutionGlyphs = function(e, t) {
                    let n = t[0], s = o(e, n), r = t[0] + 1;
                    const a = new Map;
                    for(; r < t[1];)o(e, r) !== s && (r - n <= 1 ? a.set(n, s) : a.set([
                        n,
                        r
                    ], s)), r++;
                    return r - n <= 1 ? a.set(n, s) : a.set([
                        n,
                        r
                    ], s), a;
                }, t.getIndividualSubstitutionGlyph = o;
            },
            694: (e, t)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function e(t, n, s, o) {
                    let r = t[n[o]];
                    if (!r) return;
                    let a = r.lookup;
                    if (r.reverse) {
                        const e = function(e, t, n) {
                            let s = e[t[--n]], o = s && s.lookup;
                            for(; s && ((!o && s.lookup || s.lookup && o && o.index > s.lookup.index) && (o = s.lookup), !(--n < 0) && s.reverse);)s = s.reverse[t[n]];
                            return o;
                        }(r.reverse, n, s);
                        (!a && e || e && a && (a.index > e.index || a.index === e.index && a.subIndex > e.subIndex)) && (a = e);
                    }
                    if (++o >= n.length || !r.forward) return a;
                    const i = e(r.forward, n, s, o);
                    return (!a && i || i && a && (a.index > i.index || a.index === i.index && a.subIndex > i.subIndex)) && (a = i), a;
                };
            },
            814: (e, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                const s = n(82);
                var o, r;
                !function(e) {
                    e.Serif = "serif", e.SansSerif = "sansSerif", e.Monospace = "monospace", e.Cursive = "cursive", e.Unknown = "unknown";
                }(o = t.Type || (t.Type = {})), function(e) {
                    e.Regular = "regular", e.Italic = "italic", e.Oblique = "oblique", e.Bold = "bold", e.BoldItalic = "boldItalic", e.BoldOblique = "boldOblique", e.Other = "other";
                }(r = t.Style || (t.Style = {}));
                const a = [
                    " Regular",
                    " Bold",
                    " Bold Italic",
                    " Bold Oblique",
                    " Italic",
                    " Oblique"
                ];
                function i(e) {
                    if (!e.os2 && !e.head) return r.Other;
                    const t = e.os2 ? 32 & e.os2.fsSelection : 1 & e.head.macStyle, n = e.os2 ? 1 & e.os2.fsSelection : e.post ? e.post.italicAngle < 0 : 2 & e.head.macStyle, s = e.os2 ? 512 & e.os2.fsSelection : e.post ? e.post.italicAngle > 0 : 0, o = e.os2 ? 320 & e.os2.fsSelection : 1;
                    return t ? s ? r.BoldOblique : n ? r.BoldItalic : r.Bold : s ? r.Oblique : n ? r.Italic : o ? r.Regular : r.Other;
                }
                t.name = function(e, t) {
                    const n = e.names.preferredFamily && e.names.preferredFamily[t] ? e.names.preferredFamily[t] : e.names.fontFamily[t];
                    if ("win32" === s.platform()) {
                        const s = `${n} ${e.names.preferredSubfamily && e.names.preferredSubfamily[t] ? e.names.preferredSubfamily[t] : e.names.fontSubfamily[t]}`;
                        let o = -1;
                        for (const e of a){
                            const t = s.lastIndexOf(e);
                            if (-1 !== t) {
                                o = t;
                                break;
                            }
                        }
                        return -1 !== o ? s.substring(0, o) : s;
                    }
                    return n;
                }, t.type = function(e) {
                    if (e.os2) switch(e.os2.panose[0]){
                        case 2:
                            return 9 === e.os2.panose[3] ? o.Monospace : e.os2.panose[1] >= 11 && e.os2.panose[1] <= 15 || 0 === e.os2.panose[1] ? o.SansSerif : o.Serif;
                        case 3:
                            return o.Cursive;
                    }
                    else if (e.post && e.post.isFixedPitch) return o.Monospace;
                    return o.Unknown;
                }, t.style = i;
                const l = [
                    r.Bold,
                    r.BoldItalic,
                    r.BoldOblique
                ];
                t.weight = function(e) {
                    return e.os2 ? e.os2.usWeightClass : l.includes(i(e)) ? 700 : 400;
                };
            },
            781: function(e, t, n) {
                "use strict";
                var s = this && this.__rest || function(e, t) {
                    var n = {};
                    for(var s in e)Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
                    if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
                        var o = 0;
                        for(s = Object.getOwnPropertySymbols(e); o < s.length; o++)t.indexOf(s[o]) < 0 && (n[s[o]] = e[s[o]]);
                    }
                    return n;
                };
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                const o = n(459), r = n(934), a = n(814);
                var i = n(814);
                async function l(e) {
                    const t = Object.assign({
                        concurrency: 4,
                        language: "en"
                    }, e), n = await o.default({
                        extensions: [
                            "ttf",
                            "otf"
                        ]
                    }), a = await async function(e, n, s) {
                        const o = [];
                        let a = 0;
                        const i = async (e)=>{
                            o.push(await (async (e)=>{
                                try {
                                    return u(e, await r.default(e), t.language);
                                } catch (e) {
                                    if ([
                                        "TypeError",
                                        "SyntaxError",
                                        "ReferenceError",
                                        "RangeError",
                                        "AssertionError"
                                    ].includes(e.name)) throw e;
                                }
                            })(n[e])), a < n.length && await i(a++);
                        }, l = [];
                        for(; a < n.length && a < s; a++)l.push(i(a));
                        return await Promise.all(l), o;
                    }(0, n, t.concurrency), i = {};
                    for (let e of a.filter((e)=>e)){
                        const { name: t } = e, n = s(e, [
                            "name"
                        ]);
                        i[t] || (i[t] = []), i[t].push(n);
                    }
                    return i;
                }
                function u(e, t, n) {
                    return {
                        name: a.name(t, n),
                        path: e,
                        type: a.type(t),
                        weight: a.weight(t),
                        style: a.style(t)
                    };
                }
                t.Type = i.Type, t.Style = i.Style, t.list = l, t.listVariants = async function(e, t) {
                    return (await l(t))[e] || [];
                }, t.get = async function(e, t) {
                    const n = Object.assign({
                        language: "en"
                    }, t);
                    return u(e, await r.default(e), n.language);
                };
            },
            934: (e, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                const s = n(89), o = n(896), r = n(380), a = n(879), i = n(130), l = n(731), u = n(954);
                var c;
                !function(e) {
                    e[e.TrueType = 0] = "TrueType", e[e.CFF = 1] = "CFF", e[e.Woff = 2] = "Woff";
                }(c || (c = {}));
                const p = {
                    name: {
                        tag: Buffer.from("name"),
                        parse: r.default
                    },
                    ltag: {
                        tag: Buffer.from("ltag"),
                        parse: a.default
                    },
                    os2: {
                        tag: Buffer.from("OS/2"),
                        parse: i.default
                    },
                    head: {
                        tag: Buffer.from("head"),
                        parse: l.default
                    },
                    post: {
                        tag: Buffer.from("post"),
                        parse: u.default
                    }
                };
                t.default = async function(e) {
                    return new Promise((t, n)=>{
                        (async ()=>{
                            const t = o.default(), r = s.createReadStream(e);
                            let a = !1;
                            const i = ()=>{
                                a = !0;
                            };
                            r.once("close", i), r.once("end", i), r.once("error", (e)=>{
                                a = !0, n(e);
                            }), r.pipe(t);
                            try {
                                switch(function(e) {
                                    if (e.equals(f.one) || e.equals(f.true) || e.equals(f.typ1)) return c.TrueType;
                                    if (e.equals(f.otto)) return c.CFF;
                                    if (e.equals(f.woff)) return c.Woff;
                                    throw new Error(`Unsupported signature type: ${e}`);
                                }(await t.read(4))){
                                    case c.TrueType:
                                    case c.CFF:
                                        const n = (await t.read(2)).readUInt16BE(0);
                                        await t.skip(6);
                                        const s = await async function(e, t) {
                                            const n = {};
                                            for(let s = 0; s < t; s++){
                                                const t = await e.read(4), s = await e.read(12);
                                                for (const [e, o] of Object.entries(p))if (t.equals(o.tag) && (n[e] = {
                                                    offset: s.readUInt32BE(4),
                                                    length: s.readUInt32BE(8)
                                                }, n.name && n.ltag && n.os2)) return n;
                                            }
                                            return n;
                                        }(t, n), o = Object.entries(s).sort((e, t)=>e[1].offset - t[1].offset), r = {};
                                        for (const [e, n] of o)await t.skip(n.offset - t.offset), r[e] = await t.read(n.length);
                                        let a = [];
                                        if (r.ltag && (a = p.ltag.parse(r.ltag)), !r.name) throw new Error(`missing required OpenType table 'name' in font file: ${e}`);
                                        return {
                                            names: p.name.parse(r.name, a),
                                            os2: r.os2 && p.os2.parse(r.os2),
                                            head: r.head && p.head.parse(r.head),
                                            post: r.post && p.post.parse(r.post)
                                        };
                                    case c.Woff:
                                    default:
                                        throw new Error("provided font type is not supported yet");
                                }
                            } finally{
                                r.unpipe(t), a || (r.destroy(), t.destroy());
                            }
                        })().then(t, n);
                    });
                };
                const f = {
                    one: Buffer.from([
                        0,
                        1,
                        0,
                        0
                    ]),
                    otto: Buffer.from("OTTO"),
                    true: Buffer.from("true"),
                    typ1: Buffer.from("typ1"),
                    woff: Buffer.from("wOFF")
                };
            },
            731: (e, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                const s = n(980);
                t.default = function(e) {
                    return {
                        version: s.formatFixed(e.readUInt16BE(0), e.readUInt16BE(2)),
                        fontRevision: s.formatFixed(e.readUInt16BE(4), e.readUInt16BE(6)),
                        checkSumAdjustment: e.readUInt32BE(8),
                        magicNumber: e.readUInt32BE(12),
                        flags: e.readUInt16BE(16),
                        unitsPerEm: e.readUInt16BE(18),
                        created: s.formatLongDateTime(e.readUInt32BE(20), e.readUInt32BE(24)),
                        modified: s.formatLongDateTime(e.readUInt32BE(28), e.readUInt32BE(32)),
                        xMin: e.readInt16BE(36),
                        yMin: e.readInt16BE(38),
                        xMax: e.readInt16BE(40),
                        yMax: e.readInt16BE(42),
                        macStyle: e.readUInt16BE(44),
                        lowestRecPPEM: e.readUInt16BE(46),
                        fontDirectionHint: e.readInt16BE(48),
                        indexToLocFormat: e.readInt16BE(50),
                        glyphDataFormat: e.readInt16BE(52)
                    };
                };
            },
            879: (e, t)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e) {
                    if (1 !== e.readUInt32BE(0)) throw new Error("Unsupported ltag table version.");
                    const t = e.readUInt32BE(8), n = [];
                    for(let s = 0; s < t; s++){
                        let t = "";
                        const o = e.readUInt16BE(12 + 4 * s), r = e.readUInt16BE(14 + 4 * s);
                        for(let n = o; n < o + r; ++n)t += String.fromCharCode(e.readInt8(n));
                        n.push(t);
                    }
                    return n;
                };
            },
            380: (e, t)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                const n = [
                    "copyright",
                    "fontFamily",
                    "fontSubfamily",
                    "uniqueID",
                    "fullName",
                    "version",
                    "postScriptName",
                    "trademark",
                    "manufacturer",
                    "designer",
                    "description",
                    "manufacturerURL",
                    "designerURL",
                    "license",
                    "licenseURL",
                    "reserved",
                    "preferredFamily",
                    "preferredSubfamily",
                    "compatibleFullName",
                    "sampleText",
                    "postScriptFindFontName",
                    "wwsFamily",
                    "wwsSubfamily"
                ], s = {
                    0: "en",
                    1: "fr",
                    2: "de",
                    3: "it",
                    4: "nl",
                    5: "sv",
                    6: "es",
                    7: "da",
                    8: "pt",
                    9: "no",
                    10: "he",
                    11: "ja",
                    12: "ar",
                    13: "fi",
                    14: "el",
                    15: "is",
                    16: "mt",
                    17: "tr",
                    18: "hr",
                    19: "zh-Hant",
                    20: "ur",
                    21: "hi",
                    22: "th",
                    23: "ko",
                    24: "lt",
                    25: "pl",
                    26: "hu",
                    27: "es",
                    28: "lv",
                    29: "se",
                    30: "fo",
                    31: "fa",
                    32: "ru",
                    33: "zh",
                    34: "nl-BE",
                    35: "ga",
                    36: "sq",
                    37: "ro",
                    38: "cz",
                    39: "sk",
                    40: "si",
                    41: "yi",
                    42: "sr",
                    43: "mk",
                    44: "bg",
                    45: "uk",
                    46: "be",
                    47: "uz",
                    48: "kk",
                    49: "az-Cyrl",
                    50: "az-Arab",
                    51: "hy",
                    52: "ka",
                    53: "mo",
                    54: "ky",
                    55: "tg",
                    56: "tk",
                    57: "mn-CN",
                    58: "mn",
                    59: "ps",
                    60: "ks",
                    61: "ku",
                    62: "sd",
                    63: "bo",
                    64: "ne",
                    65: "sa",
                    66: "mr",
                    67: "bn",
                    68: "as",
                    69: "gu",
                    70: "pa",
                    71: "or",
                    72: "ml",
                    73: "kn",
                    74: "ta",
                    75: "te",
                    76: "si",
                    77: "my",
                    78: "km",
                    79: "lo",
                    80: "vi",
                    81: "id",
                    82: "tl",
                    83: "ms",
                    84: "ms-Arab",
                    85: "am",
                    86: "ti",
                    87: "om",
                    88: "so",
                    89: "sw",
                    90: "rw",
                    91: "rn",
                    92: "ny",
                    93: "mg",
                    94: "eo",
                    128: "cy",
                    129: "eu",
                    130: "ca",
                    131: "la",
                    132: "qu",
                    133: "gn",
                    134: "ay",
                    135: "tt",
                    136: "ug",
                    137: "dz",
                    138: "jv",
                    139: "su",
                    140: "gl",
                    141: "af",
                    142: "br",
                    143: "iu",
                    144: "gd",
                    145: "gv",
                    146: "ga",
                    147: "to",
                    148: "el-polyton",
                    149: "kl",
                    150: "az",
                    151: "nn"
                }, o = {
                    1078: "af",
                    1052: "sq",
                    1156: "gsw",
                    1118: "am",
                    5121: "ar-DZ",
                    15361: "ar-BH",
                    3073: "ar",
                    2049: "ar-IQ",
                    11265: "ar-JO",
                    13313: "ar-KW",
                    12289: "ar-LB",
                    4097: "ar-LY",
                    6145: "ary",
                    8193: "ar-OM",
                    16385: "ar-QA",
                    1025: "ar-SA",
                    10241: "ar-SY",
                    7169: "aeb",
                    14337: "ar-AE",
                    9217: "ar-YE",
                    1067: "hy",
                    1101: "as",
                    2092: "az-Cyrl",
                    1068: "az",
                    1133: "ba",
                    1069: "eu",
                    1059: "be",
                    2117: "bn",
                    1093: "bn-IN",
                    8218: "bs-Cyrl",
                    5146: "bs",
                    1150: "br",
                    1026: "bg",
                    1027: "ca",
                    3076: "zh-HK",
                    5124: "zh-MO",
                    2052: "zh",
                    4100: "zh-SG",
                    1028: "zh-TW",
                    1155: "co",
                    1050: "hr",
                    4122: "hr-BA",
                    1029: "cs",
                    1030: "da",
                    1164: "prs",
                    1125: "dv",
                    2067: "nl-BE",
                    1043: "nl",
                    3081: "en-AU",
                    10249: "en-BZ",
                    4105: "en-CA",
                    9225: "en-029",
                    16393: "en-IN",
                    6153: "en-IE",
                    8201: "en-JM",
                    17417: "en-MY",
                    5129: "en-NZ",
                    13321: "en-PH",
                    18441: "en-SG",
                    7177: "en-ZA",
                    11273: "en-TT",
                    2057: "en-GB",
                    1033: "en",
                    12297: "en-ZW",
                    1061: "et",
                    1080: "fo",
                    1124: "fil",
                    1035: "fi",
                    2060: "fr-BE",
                    3084: "fr-CA",
                    1036: "fr",
                    5132: "fr-LU",
                    6156: "fr-MC",
                    4108: "fr-CH",
                    1122: "fy",
                    1110: "gl",
                    1079: "ka",
                    3079: "de-AT",
                    1031: "de",
                    5127: "de-LI",
                    4103: "de-LU",
                    2055: "de-CH",
                    1032: "el",
                    1135: "kl",
                    1095: "gu",
                    1128: "ha",
                    1037: "he",
                    1081: "hi",
                    1038: "hu",
                    1039: "is",
                    1136: "ig",
                    1057: "id",
                    1117: "iu",
                    2141: "iu-Latn",
                    2108: "ga",
                    1076: "xh",
                    1077: "zu",
                    1040: "it",
                    2064: "it-CH",
                    1041: "ja",
                    1099: "kn",
                    1087: "kk",
                    1107: "km",
                    1158: "quc",
                    1159: "rw",
                    1089: "sw",
                    1111: "kok",
                    1042: "ko",
                    1088: "ky",
                    1108: "lo",
                    1062: "lv",
                    1063: "lt",
                    2094: "dsb",
                    1134: "lb",
                    1071: "mk",
                    2110: "ms-BN",
                    1086: "ms",
                    1100: "ml",
                    1082: "mt",
                    1153: "mi",
                    1146: "arn",
                    1102: "mr",
                    1148: "moh",
                    1104: "mn",
                    2128: "mn-CN",
                    1121: "ne",
                    1044: "nb",
                    2068: "nn",
                    1154: "oc",
                    1096: "or",
                    1123: "ps",
                    1045: "pl",
                    1046: "pt",
                    2070: "pt-PT",
                    1094: "pa",
                    1131: "qu-BO",
                    2155: "qu-EC",
                    3179: "qu",
                    1048: "ro",
                    1047: "rm",
                    1049: "ru",
                    9275: "smn",
                    4155: "smj-NO",
                    5179: "smj",
                    3131: "se-FI",
                    1083: "se",
                    2107: "se-SE",
                    8251: "sms",
                    6203: "sma-NO",
                    7227: "sms",
                    1103: "sa",
                    7194: "sr-Cyrl-BA",
                    3098: "sr",
                    6170: "sr-Latn-BA",
                    2074: "sr-Latn",
                    1132: "nso",
                    1074: "tn",
                    1115: "si",
                    1051: "sk",
                    1060: "sl",
                    11274: "es-AR",
                    16394: "es-BO",
                    13322: "es-CL",
                    9226: "es-CO",
                    5130: "es-CR",
                    7178: "es-DO",
                    12298: "es-EC",
                    17418: "es-SV",
                    4106: "es-GT",
                    18442: "es-HN",
                    2058: "es-MX",
                    19466: "es-NI",
                    6154: "es-PA",
                    15370: "es-PY",
                    10250: "es-PE",
                    20490: "es-PR",
                    3082: "es",
                    1034: "es",
                    21514: "es-US",
                    14346: "es-UY",
                    8202: "es-VE",
                    2077: "sv-FI",
                    1053: "sv",
                    1114: "syr",
                    1064: "tg",
                    2143: "tzm",
                    1097: "ta",
                    1092: "tt",
                    1098: "te",
                    1054: "th",
                    1105: "bo",
                    1055: "tr",
                    1090: "tk",
                    1152: "ug",
                    1058: "uk",
                    1070: "hsb",
                    1056: "ur",
                    2115: "uz-Cyrl",
                    1091: "uz",
                    1066: "vi",
                    1106: "cy",
                    1160: "wo",
                    1157: "sah",
                    1144: "ii",
                    1130: "yo"
                };
                function r(e, t, n) {
                    switch(e){
                        case 0:
                            if (65535 === t) return "und";
                            if (n) return n[t];
                            break;
                        case 1:
                            return s[t];
                        case 3:
                            return o[t];
                    }
                }
                const a = "utf-16", i = {
                    0: "macintosh",
                    1: "x-mac-japanese",
                    2: "x-mac-chinesetrad",
                    3: "x-mac-korean",
                    6: "x-mac-greek",
                    7: "x-mac-cyrillic",
                    9: "x-mac-devanagai",
                    10: "x-mac-gurmukhi",
                    11: "x-mac-gujarati",
                    12: "x-mac-oriya",
                    13: "x-mac-bengali",
                    14: "x-mac-tamil",
                    15: "x-mac-telugu",
                    16: "x-mac-kannada",
                    17: "x-mac-malayalam",
                    18: "x-mac-sinhalese",
                    19: "x-mac-burmese",
                    20: "x-mac-khmer",
                    21: "x-mac-thai",
                    22: "x-mac-lao",
                    23: "x-mac-georgian",
                    24: "x-mac-armenian",
                    25: "x-mac-chinesesimp",
                    26: "x-mac-tibetan",
                    27: "x-mac-mongolian",
                    28: "x-mac-ethiopic",
                    29: "x-mac-ce",
                    30: "x-mac-vietnamese",
                    31: "x-mac-extarabic"
                }, l = {
                    15: "x-mac-icelandic",
                    17: "x-mac-turkish",
                    18: "x-mac-croatian",
                    24: "x-mac-ce",
                    25: "x-mac-ce",
                    26: "x-mac-ce",
                    27: "x-mac-ce",
                    28: "x-mac-ce",
                    30: "x-mac-icelandic",
                    37: "x-mac-romanian",
                    38: "x-mac-ce",
                    39: "x-mac-ce",
                    40: "x-mac-ce",
                    143: "x-mac-inuit",
                    146: "x-mac-gaelic"
                };
                function u(e, t, n) {
                    switch(e){
                        case 0:
                            return a;
                        case 1:
                            return l[n] || i[t];
                        case 3:
                            if (1 === t || 10 === t) return a;
                    }
                }
                t.default = function(e, t) {
                    const s = {}, o = e.readUInt16BE(2), i = e.readUInt16BE(4);
                    let l = 6;
                    for(let c = 0; c < o; c++){
                        const o = e.readUInt16BE(l + 0), c = e.readUInt16BE(l + 2), f = e.readUInt16BE(l + 4), h = e.readUInt16BE(l + 6), d = n[h] || String(h), g = e.readUInt16BE(l + 8), m = e.readUInt16BE(l + 10), y = r(o, f, t), v = u(o, c, f);
                        if (l += 12, void 0 !== v && void 0 !== y) {
                            let t;
                            if (v === a) {
                                const n = g / 2, s = Array(n);
                                for(let t = 0; t < n; t++)s[t] = e.readUInt16BE(i + m + 2 * t);
                                t = String.fromCharCode(...s);
                            } else t = p(e, i + m, g, v);
                            if (t) {
                                let e = s[d];
                                void 0 === e && (e = s[d] = {}), e[y] = t;
                            }
                        }
                    }
                    return s;
                };
                const c = {
                    "x-mac-croatian": "\xc4\xc5\xc7\xc9\xd1\xd6\xdc\xe1\xe0\xe2\xe4\xe3\xe5\xe7\xe9\xe8\xea\xeb\xed\xec\xee\xef\xf1\xf3\xf2\xf4\xf6\xf5\xfa\xf9\xfb\xfc†\xb0\xa2\xa3\xa7•\xb6\xdf\xaeŠ™\xb4\xa8≠Ž\xd8∞\xb1≤≥∆\xb5∂∑∏š∫\xaa\xbaΩž\xf8\xbf\xa1\xac√ƒ≈Ć\xabČ… \xc0\xc3\xd5ŒœĐ—“”‘’\xf7◊\xa9⁄€‹›\xc6\xbb–\xb7‚„‰\xc2ć\xc1č\xc8\xcd\xce\xcf\xcc\xd3\xd4đ\xd2\xda\xdb\xd9ıˆ˜\xafπ\xcb˚\xb8\xca\xe6ˇ",
                    "x-mac-cyrillic": "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ†\xb0Ґ\xa3\xa7•\xb6І\xae\xa9™Ђђ≠Ѓѓ∞\xb1≤≥і\xb5ґЈЄєЇїЉљЊњјЅ\xac√ƒ≈∆\xab\xbb… ЋћЌќѕ–—“”‘’\xf7„ЎўЏџ№Ёёяабвгдежзийклмнопрстуфхцчшщъыьэю",
                    "x-mac-gaelic": "\xc4\xc5\xc7\xc9\xd1\xd6\xdc\xe1\xe0\xe2\xe4\xe3\xe5\xe7\xe9\xe8\xea\xeb\xed\xec\xee\xef\xf1\xf3\xf2\xf4\xf6\xf5\xfa\xf9\xfb\xfc†\xb0\xa2\xa3\xa7•\xb6\xdf\xae\xa9™\xb4\xa8≠\xc6\xd8Ḃ\xb1≤≥ḃĊċḊḋḞḟĠġṀ\xe6\xf8ṁṖṗɼƒſṠ\xab\xbb… \xc0\xc3\xd5Œœ–—“”‘’ṡẛ\xffŸṪ€‹›Ŷŷṫ\xb7Ỳỳ⁊\xc2\xca\xc1\xcb\xc8\xcd\xce\xcf\xcc\xd3\xd4♣\xd2\xda\xdb\xd9ı\xdd\xfdŴŵẄẅẀẁẂẃ",
                    "x-mac-greek": "\xc4\xb9\xb2\xc9\xb3\xd6\xdc΅\xe0\xe2\xe4΄\xa8\xe7\xe9\xe8\xea\xeb\xa3™\xee\xef•\xbd‰\xf4\xf6\xa6€\xf9\xfb\xfc†ΓΔΘΛΞΠ\xdf\xae\xa9ΣΪ\xa7≠\xb0\xb7Α\xb1≤≥\xa5ΒΕΖΗΙΚΜΦΫΨΩάΝ\xacΟΡ≈Τ\xab\xbb… ΥΧΆΈœ–―“”‘’\xf7ΉΊΌΎέήίόΏύαβψδεφγηιξκλμνοπώρστθωςχυζϊϋΐΰ\xad",
                    "x-mac-icelandic": "\xc4\xc5\xc7\xc9\xd1\xd6\xdc\xe1\xe0\xe2\xe4\xe3\xe5\xe7\xe9\xe8\xea\xeb\xed\xec\xee\xef\xf1\xf3\xf2\xf4\xf6\xf5\xfa\xf9\xfb\xfc\xdd\xb0\xa2\xa3\xa7•\xb6\xdf\xae\xa9™\xb4\xa8≠\xc6\xd8∞\xb1≤≥\xa5\xb5∂∑∏π∫\xaa\xbaΩ\xe6\xf8\xbf\xa1\xac√ƒ≈∆\xab\xbb… \xc0\xc3\xd5Œœ–—“”‘’\xf7◊\xffŸ⁄€\xd0\xf0\xde\xfe\xfd\xb7‚„‰\xc2\xca\xc1\xcb\xc8\xcd\xce\xcf\xcc\xd3\xd4\xd2\xda\xdb\xd9ıˆ˜\xaf˘˙˚\xb8˝˛ˇ",
                    "x-mac-inuit": "ᐃᐄᐅᐆᐊᐋᐱᐲᐳᐴᐸᐹᑉᑎᑏᑐᑑᑕᑖᑦᑭᑮᑯᑰᑲᑳᒃᒋᒌᒍᒎᒐᒑ\xb0ᒡᒥᒦ•\xb6ᒧ\xae\xa9™ᒨᒪᒫᒻᓂᓃᓄᓅᓇᓈᓐᓯᓰᓱᓲᓴᓵᔅᓕᓖᓗᓘᓚᓛᓪᔨᔩᔪᔫᔭ… ᔮᔾᕕᕖᕗ–—“”‘’ᕘᕙᕚᕝᕆᕇᕈᕉᕋᕌᕐᕿᖀᖁᖂᖃᖄᖅᖏᖐᖑᖒᖓᖔᖕᙱᙲᙳᙴᙵᙶᖖᖠᖡᖢᖣᖤᖥᖦᕼŁł",
                    "x-mac-ce": "\xc4Āā\xc9Ą\xd6\xdc\xe1ąČ\xe4čĆć\xe9ŹźĎ\xedďĒēĖ\xf3ė\xf4\xf6\xf5\xfaĚě\xfc†\xb0Ę\xa3\xa7•\xb6\xdf\xae\xa9™ę\xa8≠ģĮįĪ≤≥īĶ∂∑łĻļĽľĹĺŅņŃ\xac√ńŇ∆\xab\xbb… ňŐ\xd5őŌ–—“”‘’\xf7◊ōŔŕŘ‹›řŖŗŠ‚„šŚś\xc1Ťť\xcdŽžŪ\xd3\xd4ūŮ\xdaůŰűŲų\xdd\xfdķŻŁżĢˇ",
                    macintosh: "\xc4\xc5\xc7\xc9\xd1\xd6\xdc\xe1\xe0\xe2\xe4\xe3\xe5\xe7\xe9\xe8\xea\xeb\xed\xec\xee\xef\xf1\xf3\xf2\xf4\xf6\xf5\xfa\xf9\xfb\xfc†\xb0\xa2\xa3\xa7•\xb6\xdf\xae\xa9™\xb4\xa8≠\xc6\xd8∞\xb1≤≥\xa5\xb5∂∑∏π∫\xaa\xbaΩ\xe6\xf8\xbf\xa1\xac√ƒ≈∆\xab\xbb… \xc0\xc3\xd5Œœ–—“”‘’\xf7◊\xffŸ⁄€‹›ﬁﬂ‡\xb7‚„‰\xc2\xca\xc1\xcb\xc8\xcd\xce\xcf\xcc\xd3\xd4\xd2\xda\xdb\xd9ıˆ˜\xaf˘˙˚\xb8˝˛ˇ",
                    "x-mac-romanian": "\xc4\xc5\xc7\xc9\xd1\xd6\xdc\xe1\xe0\xe2\xe4\xe3\xe5\xe7\xe9\xe8\xea\xeb\xed\xec\xee\xef\xf1\xf3\xf2\xf4\xf6\xf5\xfa\xf9\xfb\xfc†\xb0\xa2\xa3\xa7•\xb6\xdf\xae\xa9™\xb4\xa8≠ĂȘ∞\xb1≤≥\xa5\xb5∂∑∏π∫\xaa\xbaΩăș\xbf\xa1\xac√ƒ≈∆\xab\xbb… \xc0\xc3\xd5Œœ–—“”‘’\xf7◊\xffŸ⁄€‹›Țț‡\xb7‚„‰\xc2\xca\xc1\xcb\xc8\xcd\xce\xcf\xcc\xd3\xd4\xd2\xda\xdb\xd9ıˆ˜\xaf˘˙˚\xb8˝˛ˇ",
                    "x-mac-turkish": "\xc4\xc5\xc7\xc9\xd1\xd6\xdc\xe1\xe0\xe2\xe4\xe3\xe5\xe7\xe9\xe8\xea\xeb\xed\xec\xee\xef\xf1\xf3\xf2\xf4\xf6\xf5\xfa\xf9\xfb\xfc†\xb0\xa2\xa3\xa7•\xb6\xdf\xae\xa9™\xb4\xa8≠\xc6\xd8∞\xb1≤≥\xa5\xb5∂∑∏π∫\xaa\xbaΩ\xe6\xf8\xbf\xa1\xac√ƒ≈∆\xab\xbb… \xc0\xc3\xd5Œœ–—“”‘’\xf7◊\xffŸĞğİıŞş‡\xb7‚„‰\xc2\xca\xc1\xcb\xc8\xcd\xce\xcf\xcc\xd3\xd4\xd2\xda\xdb\xd9ˆ˜\xaf˘˙˚\xb8˝˛ˇ"
                };
                function p(e, t, n, s) {
                    const o = c[s];
                    if (void 0 === o) return;
                    let r = "";
                    for(let s = 0; s < n; s++){
                        const n = e.readUInt8(t + s);
                        r += n <= 127 ? String.fromCharCode(n) : o[127 & n];
                    }
                    return r;
                }
            },
            130: (e, t)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e) {
                    const t = {
                        version: e.readUInt16BE(0),
                        xAvgCharWidth: e.readUInt16BE(2),
                        usWeightClass: e.readUInt16BE(4),
                        usWidthClass: e.readUInt16BE(6),
                        fsType: e.readUInt16BE(8),
                        ySubscriptXSize: e.readInt16BE(10),
                        ySubscriptYSize: e.readInt16BE(12),
                        ySubscriptXOffset: e.readInt16BE(14),
                        ySubscriptYOffset: e.readInt16BE(16),
                        ySuperscriptXSize: e.readInt16BE(18),
                        ySuperscriptYSize: e.readInt16BE(20),
                        ySuperscriptXOffset: e.readInt16BE(22),
                        ySuperscriptYOffset: e.readInt16BE(24),
                        yStrikeoutSize: e.readInt16BE(26),
                        yStrikeoutPosition: e.readInt16BE(28),
                        sFamilyClass: e.readInt16BE(30),
                        panose: [
                            e.readUInt8(32),
                            e.readUInt8(33),
                            e.readUInt8(34),
                            e.readUInt8(35),
                            e.readUInt8(36),
                            e.readUInt8(37),
                            e.readUInt8(38),
                            e.readUInt8(39),
                            e.readUInt8(40),
                            e.readUInt8(41)
                        ],
                        ulUnicodeRange1: e.readUInt32BE(42),
                        ulUnicodeRange2: e.readUInt32BE(46),
                        ulUnicodeRange3: e.readUInt32BE(50),
                        ulUnicodeRange4: e.readUInt32BE(54),
                        achVendID: String.fromCharCode(e.readUInt8(58), e.readUInt8(59), e.readUInt8(60), e.readUInt8(61)),
                        fsSelection: e.readUInt16BE(62),
                        usFirstCharIndex: e.readUInt16BE(64),
                        usLastCharIndex: e.readUInt16BE(66),
                        sTypoAscender: e.readInt16BE(68),
                        sTypoDescender: e.readInt16BE(70),
                        sTypoLineGap: e.readInt16BE(72),
                        usWinAscent: e.readUInt16BE(74),
                        usWinDescent: e.readUInt16BE(76)
                    };
                    return t.version >= 1 && (t.ulCodePageRange1 = e.readUInt32BE(78), t.ulCodePageRange2 = e.readUInt32BE(82)), t.version >= 2 && (t.sxHeight = e.readInt16BE(86), t.sCapHeight = e.readInt16BE(88), t.usDefaultChar = e.readUInt16BE(90), t.usBreakChar = e.readUInt16BE(92), t.usMaxContent = e.readUInt16BE(94)), t;
                };
            },
            954: (e, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                const s = n(980);
                t.default = function(e) {
                    return {
                        version: s.formatFixed(e.readUInt16BE(0), e.readUInt16BE(2)),
                        italicAngle: s.formatFixed(e.readUInt16BE(4), e.readUInt16BE(6)),
                        underlinePosition: e.readInt16BE(8),
                        underlineThickness: e.readInt16BE(10),
                        isFixedPitch: e.readUInt32BE(12),
                        minMemType42: e.readUInt32BE(16),
                        maxMemType42: e.readUInt32BE(20),
                        minMemType1: e.readUInt32BE(24),
                        maxMemType1: e.readUInt32BE(28)
                    };
                };
            },
            980: (e, t)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.formatFixed = function(e, t) {
                    return e + t / 65536;
                }, t.formatLongDateTime = function(e, t) {
                    return 1e3 * (e * 2 ** 32 + t - 2082844800);
                };
            },
            459: (e, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                const s = n(56), o = n(456), r = n(49), a = {
                    win32: ()=>[
                            "C:\\Windows\\Fonts"
                        ],
                    darwin: ()=>{
                        const e = o.homedir();
                        return [
                            ...e ? [
                                s.join(e, "/Library/Fonts")
                            ] : [],
                            "/Library/Fonts",
                            "/Network/Library/Fonts",
                            "/System/Library/Fonts",
                            "/System Folder/Fonts"
                        ];
                    },
                    linux: ()=>{
                        const e = o.homedir();
                        return [
                            "/usr/share/fonts",
                            "/usr/local/share/fonts",
                            ...e ? [
                                s.join(e, ".fonts"),
                                s.join(e, ".local/share/fonts")
                            ] : []
                        ];
                    }
                };
                function i(e) {
                    const t = Object.assign({
                        extensions: [
                            "ttf",
                            "otf",
                            "ttc",
                            "woff",
                            "woff2"
                        ],
                        additionalFolders: []
                    }, e), n = o.platform(), s = a[n];
                    if (!s) throw new Error(`Unsupported platform: ${n}`);
                    const i = s();
                    return r.default([
                        ...i,
                        ...t.additionalFolders
                    ], t.extensions);
                }
                e.exports = Object.assign(i, {
                    default: i
                }), t.default = i;
            },
            49: (e, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                const s = n(89), o = n(269), r = n(56), a = o.promisify(s.readdir), i = o.promisify(s.stat);
                async function l(e, t, n = 10) {
                    if (n <= 0) return [];
                    let s;
                    try {
                        s = await a(e);
                    } catch (e) {
                        return [];
                    }
                    const o = [];
                    return await Promise.all(s.map(async (s)=>{
                        const a = r.join(e, s);
                        let u;
                        try {
                            u = await i(a);
                        } catch (e) {
                            return;
                        }
                        u.isFile() && t.test(a) ? o.push(a) : u.isDirectory() && o.push(...await l(a, t, n - 1));
                    })), o;
                }
                t.default = async function(e, t) {
                    const n = new Set;
                    return await Promise.all(e.map(async (e)=>{
                        const s = await l(r.resolve(e), new RegExp(`\\.${t.map((e)=>`(?:${e})`).join("|")}$`));
                        for (const e of s)n.add(e);
                    })), [
                        ...n
                    ];
                };
            },
            593: (e, t, n)=>{
                "use strict";
                const s = n(411), o = Symbol("max"), r = Symbol("length"), a = Symbol("lengthCalculator"), i = Symbol("allowStale"), l = Symbol("maxAge"), u = Symbol("dispose"), c = Symbol("noDisposeOnSet"), p = Symbol("lruList"), f = Symbol("cache"), h = Symbol("updateAgeOnGet"), d = ()=>1, g = (e, t, n)=>{
                    const s = e[f].get(t);
                    if (s) {
                        const t = s.value;
                        if (m(e, t)) {
                            if (v(e, s), !e[i]) return;
                        } else n && (e[h] && (s.value.now = Date.now()), e[p].unshiftNode(s));
                        return t.value;
                    }
                }, m = (e, t)=>{
                    if (!t || !t.maxAge && !e[l]) return !1;
                    const n = Date.now() - t.now;
                    return t.maxAge ? n > t.maxAge : e[l] && n > e[l];
                }, y = (e)=>{
                    if (e[r] > e[o]) for(let t = e[p].tail; e[r] > e[o] && null !== t;){
                        const n = t.prev;
                        v(e, t), t = n;
                    }
                }, v = (e, t)=>{
                    if (t) {
                        const n = t.value;
                        e[u] && e[u](n.key, n.value), e[r] -= n.length, e[f].delete(n.key), e[p].removeNode(t);
                    }
                };
                class b {
                    constructor(e, t, n, s, o){
                        this.key = e, this.value = t, this.length = n, this.now = s, this.maxAge = o || 0;
                    }
                }
                const x = (e, t, n, s)=>{
                    let o = n.value;
                    m(e, o) && (v(e, n), e[i] || (o = void 0)), o && t.call(s, o.value, o.key, e);
                };
                e.exports = class {
                    constructor(e){
                        if ("number" == typeof e && (e = {
                            max: e
                        }), e || (e = {}), e.max && ("number" != typeof e.max || e.max < 0)) throw new TypeError("max must be a non-negative number");
                        this[o] = e.max || 1 / 0;
                        const t = e.length || d;
                        if (this[a] = "function" != typeof t ? d : t, this[i] = e.stale || !1, e.maxAge && "number" != typeof e.maxAge) throw new TypeError("maxAge must be a number");
                        this[l] = e.maxAge || 0, this[u] = e.dispose, this[c] = e.noDisposeOnSet || !1, this[h] = e.updateAgeOnGet || !1, this.reset();
                    }
                    set max(e) {
                        if ("number" != typeof e || e < 0) throw new TypeError("max must be a non-negative number");
                        this[o] = e || 1 / 0, y(this);
                    }
                    get max() {
                        return this[o];
                    }
                    set allowStale(e) {
                        this[i] = !!e;
                    }
                    get allowStale() {
                        return this[i];
                    }
                    set maxAge(e) {
                        if ("number" != typeof e) throw new TypeError("maxAge must be a non-negative number");
                        this[l] = e, y(this);
                    }
                    get maxAge() {
                        return this[l];
                    }
                    set lengthCalculator(e) {
                        "function" != typeof e && (e = d), e !== this[a] && (this[a] = e, this[r] = 0, this[p].forEach((e)=>{
                            e.length = this[a](e.value, e.key), this[r] += e.length;
                        })), y(this);
                    }
                    get lengthCalculator() {
                        return this[a];
                    }
                    get length() {
                        return this[r];
                    }
                    get itemCount() {
                        return this[p].length;
                    }
                    rforEach(e, t) {
                        t = t || this;
                        for(let n = this[p].tail; null !== n;){
                            const s = n.prev;
                            x(this, e, n, t), n = s;
                        }
                    }
                    forEach(e, t) {
                        t = t || this;
                        for(let n = this[p].head; null !== n;){
                            const s = n.next;
                            x(this, e, n, t), n = s;
                        }
                    }
                    keys() {
                        return this[p].toArray().map((e)=>e.key);
                    }
                    values() {
                        return this[p].toArray().map((e)=>e.value);
                    }
                    reset() {
                        this[u] && this[p] && this[p].length && this[p].forEach((e)=>this[u](e.key, e.value)), this[f] = new Map, this[p] = new s, this[r] = 0;
                    }
                    dump() {
                        return this[p].map((e)=>!m(this, e) && {
                                k: e.key,
                                v: e.value,
                                e: e.now + (e.maxAge || 0)
                            }).toArray().filter((e)=>e);
                    }
                    dumpLru() {
                        return this[p];
                    }
                    set(e, t, n) {
                        if ((n = n || this[l]) && "number" != typeof n) throw new TypeError("maxAge must be a number");
                        const s = n ? Date.now() : 0, i = this[a](t, e);
                        if (this[f].has(e)) {
                            if (i > this[o]) return v(this, this[f].get(e)), !1;
                            const a = this[f].get(e).value;
                            return this[u] && (this[c] || this[u](e, a.value)), a.now = s, a.maxAge = n, a.value = t, this[r] += i - a.length, a.length = i, this.get(e), y(this), !0;
                        }
                        const h = new b(e, t, i, s, n);
                        return h.length > this[o] ? (this[u] && this[u](e, t), !1) : (this[r] += h.length, this[p].unshift(h), this[f].set(e, this[p].head), y(this), !0);
                    }
                    has(e) {
                        if (!this[f].has(e)) return !1;
                        const t = this[f].get(e).value;
                        return !m(this, t);
                    }
                    get(e) {
                        return g(this, e, !0);
                    }
                    peek(e) {
                        return g(this, e, !1);
                    }
                    pop() {
                        const e = this[p].tail;
                        return e ? (v(this, e), e.value) : null;
                    }
                    del(e) {
                        v(this, this[f].get(e));
                    }
                    load(e) {
                        this.reset();
                        const t = Date.now();
                        for(let n = e.length - 1; n >= 0; n--){
                            const s = e[n], o = s.e || 0;
                            if (0 === o) this.set(s.k, s.v);
                            else {
                                const e = o - t;
                                e > 0 && this.set(s.k, s.v, e);
                            }
                        }
                    }
                    prune() {
                        this[f].forEach((e, t)=>g(this, t, !1));
                    }
                };
            },
            602: (e, t, n)=>{
                "use strict";
                n.r(t), n.d(t, {
                    BoundingBox: ()=>i,
                    Font: ()=>In,
                    Glyph: ()=>le,
                    Path: ()=>u,
                    _parse: ()=>z,
                    load: ()=>Hn,
                    loadSync: ()=>zn,
                    parse: ()=>_n
                });
                var s = n(311), o = n.n(s);
                function r(e, t, n, s, o) {
                    return Math.pow(1 - o, 3) * e + 3 * Math.pow(1 - o, 2) * o * t + 3 * (1 - o) * Math.pow(o, 2) * n + Math.pow(o, 3) * s;
                }
                function a() {
                    this.x1 = Number.NaN, this.y1 = Number.NaN, this.x2 = Number.NaN, this.y2 = Number.NaN;
                }
                a.prototype.isEmpty = function() {
                    return isNaN(this.x1) || isNaN(this.y1) || isNaN(this.x2) || isNaN(this.y2);
                }, a.prototype.addPoint = function(e, t) {
                    "number" == typeof e && ((isNaN(this.x1) || isNaN(this.x2)) && (this.x1 = e, this.x2 = e), e < this.x1 && (this.x1 = e), e > this.x2 && (this.x2 = e)), "number" == typeof t && ((isNaN(this.y1) || isNaN(this.y2)) && (this.y1 = t, this.y2 = t), t < this.y1 && (this.y1 = t), t > this.y2 && (this.y2 = t));
                }, a.prototype.addX = function(e) {
                    this.addPoint(e, null);
                }, a.prototype.addY = function(e) {
                    this.addPoint(null, e);
                }, a.prototype.addBezier = function(e, t, n, s, o, a, i, l) {
                    const u = [
                        e,
                        t
                    ], c = [
                        n,
                        s
                    ], p = [
                        o,
                        a
                    ], f = [
                        i,
                        l
                    ];
                    this.addPoint(e, t), this.addPoint(i, l);
                    for(let e = 0; e <= 1; e++){
                        const t = 6 * u[e] - 12 * c[e] + 6 * p[e], n = -3 * u[e] + 9 * c[e] - 9 * p[e] + 3 * f[e], s = 3 * c[e] - 3 * u[e];
                        if (0 === n) {
                            if (0 === t) continue;
                            const n = -s / t;
                            0 < n && n < 1 && (0 === e && this.addX(r(u[e], c[e], p[e], f[e], n)), 1 === e && this.addY(r(u[e], c[e], p[e], f[e], n)));
                            continue;
                        }
                        const o = Math.pow(t, 2) - 4 * s * n;
                        if (o < 0) continue;
                        const a = (-t + Math.sqrt(o)) / (2 * n);
                        0 < a && a < 1 && (0 === e && this.addX(r(u[e], c[e], p[e], f[e], a)), 1 === e && this.addY(r(u[e], c[e], p[e], f[e], a)));
                        const i = (-t - Math.sqrt(o)) / (2 * n);
                        0 < i && i < 1 && (0 === e && this.addX(r(u[e], c[e], p[e], f[e], i)), 1 === e && this.addY(r(u[e], c[e], p[e], f[e], i)));
                    }
                }, a.prototype.addQuad = function(e, t, n, s, o, r) {
                    const a = e + 2 / 3 * (n - e), i = t + 2 / 3 * (s - t), l = a + 1 / 3 * (o - e), u = i + 1 / 3 * (r - t);
                    this.addBezier(e, t, a, i, l, u, o, r);
                };
                const i = a;
                function l() {
                    this.commands = [], this.fill = "black", this.stroke = null, this.strokeWidth = 1;
                }
                l.prototype.moveTo = function(e, t) {
                    this.commands.push({
                        type: "M",
                        x: e,
                        y: t
                    });
                }, l.prototype.lineTo = function(e, t) {
                    this.commands.push({
                        type: "L",
                        x: e,
                        y: t
                    });
                }, l.prototype.curveTo = l.prototype.bezierCurveTo = function(e, t, n, s, o, r) {
                    this.commands.push({
                        type: "C",
                        x1: e,
                        y1: t,
                        x2: n,
                        y2: s,
                        x: o,
                        y: r
                    });
                }, l.prototype.quadTo = l.prototype.quadraticCurveTo = function(e, t, n, s) {
                    this.commands.push({
                        type: "Q",
                        x1: e,
                        y1: t,
                        x: n,
                        y: s
                    });
                }, l.prototype.close = l.prototype.closePath = function() {
                    this.commands.push({
                        type: "Z"
                    });
                }, l.prototype.extend = function(e) {
                    if (e.commands) e = e.commands;
                    else if (e instanceof i) {
                        const t = e;
                        return this.moveTo(t.x1, t.y1), this.lineTo(t.x2, t.y1), this.lineTo(t.x2, t.y2), this.lineTo(t.x1, t.y2), void this.close();
                    }
                    Array.prototype.push.apply(this.commands, e);
                }, l.prototype.getBoundingBox = function() {
                    const e = new i;
                    let t = 0, n = 0, s = 0, o = 0;
                    for(let r = 0; r < this.commands.length; r++){
                        const a = this.commands[r];
                        switch(a.type){
                            case "M":
                                e.addPoint(a.x, a.y), t = s = a.x, n = o = a.y;
                                break;
                            case "L":
                                e.addPoint(a.x, a.y), s = a.x, o = a.y;
                                break;
                            case "Q":
                                e.addQuad(s, o, a.x1, a.y1, a.x, a.y), s = a.x, o = a.y;
                                break;
                            case "C":
                                e.addBezier(s, o, a.x1, a.y1, a.x2, a.y2, a.x, a.y), s = a.x, o = a.y;
                                break;
                            case "Z":
                                s = t, o = n;
                                break;
                            default:
                                throw new Error("Unexpected path command " + a.type);
                        }
                    }
                    return e.isEmpty() && e.addPoint(0, 0), e;
                }, l.prototype.draw = function(e) {
                    e.beginPath();
                    for(let t = 0; t < this.commands.length; t += 1){
                        const n = this.commands[t];
                        "M" === n.type ? e.moveTo(n.x, n.y) : "L" === n.type ? e.lineTo(n.x, n.y) : "C" === n.type ? e.bezierCurveTo(n.x1, n.y1, n.x2, n.y2, n.x, n.y) : "Q" === n.type ? e.quadraticCurveTo(n.x1, n.y1, n.x, n.y) : "Z" === n.type && e.closePath();
                    }
                    this.fill && (e.fillStyle = this.fill, e.fill()), this.stroke && (e.strokeStyle = this.stroke, e.lineWidth = this.strokeWidth, e.stroke());
                }, l.prototype.toPathData = function(e) {
                    function t(t) {
                        return Math.round(t) === t ? "" + Math.round(t) : t.toFixed(e);
                    }
                    function n() {
                        let e = "";
                        for(let n = 0; n < arguments.length; n += 1){
                            const s = arguments[n];
                            s >= 0 && n > 0 && (e += " "), e += t(s);
                        }
                        return e;
                    }
                    e = void 0 !== e ? e : 2;
                    let s = "";
                    for(let e = 0; e < this.commands.length; e += 1){
                        const t = this.commands[e];
                        "M" === t.type ? s += "M" + n(t.x, t.y) : "L" === t.type ? s += "L" + n(t.x, t.y) : "C" === t.type ? s += "C" + n(t.x1, t.y1, t.x2, t.y2, t.x, t.y) : "Q" === t.type ? s += "Q" + n(t.x1, t.y1, t.x, t.y) : "Z" === t.type && (s += "Z");
                    }
                    return s;
                }, l.prototype.toSVG = function(e) {
                    let t = '<path d="';
                    return t += this.toPathData(e), t += '"', this.fill && "black" !== this.fill && (null === this.fill ? t += ' fill="none"' : t += ' fill="' + this.fill + '"'), this.stroke && (t += ' stroke="' + this.stroke + '" stroke-width="' + this.strokeWidth + '"'), t += "/>", t;
                }, l.prototype.toDOMElement = function(e) {
                    const t = this.toPathData(e), n = document.createElementNS("http://www.w3.org/2000/svg", "path");
                    return n.setAttribute("d", t), n;
                };
                const u = l;
                function c(e) {
                    throw new Error(e);
                }
                function p(e, t) {
                    e || c(t);
                }
                const f = {
                    fail: c,
                    argument: p,
                    assert: p
                }, h = 2147483648, d = {}, g = {}, m = {};
                function y(e) {
                    return function() {
                        return e;
                    };
                }
                g.BYTE = function(e) {
                    return f.argument(e >= 0 && e <= 255, "Byte value should be between 0 and 255."), [
                        e
                    ];
                }, m.BYTE = y(1), g.CHAR = function(e) {
                    return [
                        e.charCodeAt(0)
                    ];
                }, m.CHAR = y(1), g.CHARARRAY = function(e) {
                    const t = [];
                    for(let n = 0; n < e.length; n += 1)t[n] = e.charCodeAt(n);
                    return t;
                }, m.CHARARRAY = function(e) {
                    return e.length;
                }, g.USHORT = function(e) {
                    return [
                        e >> 8 & 255,
                        255 & e
                    ];
                }, m.USHORT = y(2), g.SHORT = function(e) {
                    return e >= 32768 && (e = -(65536 - e)), [
                        e >> 8 & 255,
                        255 & e
                    ];
                }, m.SHORT = y(2), g.UINT24 = function(e) {
                    return [
                        e >> 16 & 255,
                        e >> 8 & 255,
                        255 & e
                    ];
                }, m.UINT24 = y(3), g.ULONG = function(e) {
                    return [
                        e >> 24 & 255,
                        e >> 16 & 255,
                        e >> 8 & 255,
                        255 & e
                    ];
                }, m.ULONG = y(4), g.LONG = function(e) {
                    return e >= h && (e = -(2 * h - e)), [
                        e >> 24 & 255,
                        e >> 16 & 255,
                        e >> 8 & 255,
                        255 & e
                    ];
                }, m.LONG = y(4), g.FIXED = g.ULONG, m.FIXED = m.ULONG, g.FWORD = g.SHORT, m.FWORD = m.SHORT, g.UFWORD = g.USHORT, m.UFWORD = m.USHORT, g.LONGDATETIME = function(e) {
                    return [
                        0,
                        0,
                        0,
                        0,
                        e >> 24 & 255,
                        e >> 16 & 255,
                        e >> 8 & 255,
                        255 & e
                    ];
                }, m.LONGDATETIME = y(8), g.TAG = function(e) {
                    return f.argument(4 === e.length, "Tag should be exactly 4 ASCII characters."), [
                        e.charCodeAt(0),
                        e.charCodeAt(1),
                        e.charCodeAt(2),
                        e.charCodeAt(3)
                    ];
                }, m.TAG = y(4), g.Card8 = g.BYTE, m.Card8 = m.BYTE, g.Card16 = g.USHORT, m.Card16 = m.USHORT, g.OffSize = g.BYTE, m.OffSize = m.BYTE, g.SID = g.USHORT, m.SID = m.USHORT, g.NUMBER = function(e) {
                    return e >= -107 && e <= 107 ? [
                        e + 139
                    ] : e >= 108 && e <= 1131 ? [
                        247 + ((e -= 108) >> 8),
                        255 & e
                    ] : e >= -1131 && e <= -108 ? [
                        251 + ((e = -e - 108) >> 8),
                        255 & e
                    ] : e >= -32768 && e <= 32767 ? g.NUMBER16(e) : g.NUMBER32(e);
                }, m.NUMBER = function(e) {
                    return g.NUMBER(e).length;
                }, g.NUMBER16 = function(e) {
                    return [
                        28,
                        e >> 8 & 255,
                        255 & e
                    ];
                }, m.NUMBER16 = y(3), g.NUMBER32 = function(e) {
                    return [
                        29,
                        e >> 24 & 255,
                        e >> 16 & 255,
                        e >> 8 & 255,
                        255 & e
                    ];
                }, m.NUMBER32 = y(5), g.REAL = function(e) {
                    let t = e.toString();
                    const n = /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/.exec(t);
                    if (n) {
                        const s = parseFloat("1e" + ((n[2] ? +n[2] : 0) + n[1].length));
                        t = (Math.round(e * s) / s).toString();
                    }
                    let s = "";
                    for(let e = 0, n = t.length; e < n; e += 1){
                        const n = t[e];
                        s += "e" === n ? "-" === t[++e] ? "c" : "b" : "." === n ? "a" : "-" === n ? "e" : n;
                    }
                    s += 1 & s.length ? "f" : "ff";
                    const o = [
                        30
                    ];
                    for(let e = 0, t = s.length; e < t; e += 2)o.push(parseInt(s.substr(e, 2), 16));
                    return o;
                }, m.REAL = function(e) {
                    return g.REAL(e).length;
                }, g.NAME = g.CHARARRAY, m.NAME = m.CHARARRAY, g.STRING = g.CHARARRAY, m.STRING = m.CHARARRAY, d.UTF8 = function(e, t, n) {
                    const s = [], o = n;
                    for(let n = 0; n < o; n++, t += 1)s[n] = e.getUint8(t);
                    return String.fromCharCode.apply(null, s);
                }, d.UTF16 = function(e, t, n) {
                    const s = [], o = n / 2;
                    for(let n = 0; n < o; n++, t += 2)s[n] = e.getUint16(t);
                    return String.fromCharCode.apply(null, s);
                }, g.UTF16 = function(e) {
                    const t = [];
                    for(let n = 0; n < e.length; n += 1){
                        const s = e.charCodeAt(n);
                        t[t.length] = s >> 8 & 255, t[t.length] = 255 & s;
                    }
                    return t;
                }, m.UTF16 = function(e) {
                    return 2 * e.length;
                };
                const v = {
                    "x-mac-croatian": "\xc4\xc5\xc7\xc9\xd1\xd6\xdc\xe1\xe0\xe2\xe4\xe3\xe5\xe7\xe9\xe8\xea\xeb\xed\xec\xee\xef\xf1\xf3\xf2\xf4\xf6\xf5\xfa\xf9\xfb\xfc†\xb0\xa2\xa3\xa7•\xb6\xdf\xaeŠ™\xb4\xa8≠Ž\xd8∞\xb1≤≥∆\xb5∂∑∏š∫\xaa\xbaΩž\xf8\xbf\xa1\xac√ƒ≈Ć\xabČ…\xa0\xc0\xc3\xd5ŒœĐ—“”‘’\xf7◊\xa9⁄€‹›\xc6\xbb–\xb7‚„‰\xc2ć\xc1č\xc8\xcd\xce\xcf\xcc\xd3\xd4đ\xd2\xda\xdb\xd9ıˆ˜\xafπ\xcb˚\xb8\xca\xe6ˇ",
                    "x-mac-cyrillic": "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ†\xb0Ґ\xa3\xa7•\xb6І\xae\xa9™Ђђ≠Ѓѓ∞\xb1≤≥і\xb5ґЈЄєЇїЉљЊњјЅ\xac√ƒ≈∆\xab\xbb…\xa0ЋћЌќѕ–—“”‘’\xf7„ЎўЏџ№Ёёяабвгдежзийклмнопрстуфхцчшщъыьэю",
                    "x-mac-gaelic": "\xc4\xc5\xc7\xc9\xd1\xd6\xdc\xe1\xe0\xe2\xe4\xe3\xe5\xe7\xe9\xe8\xea\xeb\xed\xec\xee\xef\xf1\xf3\xf2\xf4\xf6\xf5\xfa\xf9\xfb\xfc†\xb0\xa2\xa3\xa7•\xb6\xdf\xae\xa9™\xb4\xa8≠\xc6\xd8Ḃ\xb1≤≥ḃĊċḊḋḞḟĠġṀ\xe6\xf8ṁṖṗɼƒſṠ\xab\xbb…\xa0\xc0\xc3\xd5Œœ–—“”‘’ṡẛ\xffŸṪ€‹›Ŷŷṫ\xb7Ỳỳ⁊\xc2\xca\xc1\xcb\xc8\xcd\xce\xcf\xcc\xd3\xd4♣\xd2\xda\xdb\xd9ı\xdd\xfdŴŵẄẅẀẁẂẃ",
                    "x-mac-greek": "\xc4\xb9\xb2\xc9\xb3\xd6\xdc΅\xe0\xe2\xe4΄\xa8\xe7\xe9\xe8\xea\xeb\xa3™\xee\xef•\xbd‰\xf4\xf6\xa6€\xf9\xfb\xfc†ΓΔΘΛΞΠ\xdf\xae\xa9ΣΪ\xa7≠\xb0\xb7Α\xb1≤≥\xa5ΒΕΖΗΙΚΜΦΫΨΩάΝ\xacΟΡ≈Τ\xab\xbb…\xa0ΥΧΆΈœ–―“”‘’\xf7ΉΊΌΎέήίόΏύαβψδεφγηιξκλμνοπώρστθωςχυζϊϋΐΰ\xad",
                    "x-mac-icelandic": "\xc4\xc5\xc7\xc9\xd1\xd6\xdc\xe1\xe0\xe2\xe4\xe3\xe5\xe7\xe9\xe8\xea\xeb\xed\xec\xee\xef\xf1\xf3\xf2\xf4\xf6\xf5\xfa\xf9\xfb\xfc\xdd\xb0\xa2\xa3\xa7•\xb6\xdf\xae\xa9™\xb4\xa8≠\xc6\xd8∞\xb1≤≥\xa5\xb5∂∑∏π∫\xaa\xbaΩ\xe6\xf8\xbf\xa1\xac√ƒ≈∆\xab\xbb…\xa0\xc0\xc3\xd5Œœ–—“”‘’\xf7◊\xffŸ⁄€\xd0\xf0\xde\xfe\xfd\xb7‚„‰\xc2\xca\xc1\xcb\xc8\xcd\xce\xcf\xcc\xd3\xd4\xd2\xda\xdb\xd9ıˆ˜\xaf˘˙˚\xb8˝˛ˇ",
                    "x-mac-inuit": "ᐃᐄᐅᐆᐊᐋᐱᐲᐳᐴᐸᐹᑉᑎᑏᑐᑑᑕᑖᑦᑭᑮᑯᑰᑲᑳᒃᒋᒌᒍᒎᒐᒑ\xb0ᒡᒥᒦ•\xb6ᒧ\xae\xa9™ᒨᒪᒫᒻᓂᓃᓄᓅᓇᓈᓐᓯᓰᓱᓲᓴᓵᔅᓕᓖᓗᓘᓚᓛᓪᔨᔩᔪᔫᔭ…\xa0ᔮᔾᕕᕖᕗ–—“”‘’ᕘᕙᕚᕝᕆᕇᕈᕉᕋᕌᕐᕿᖀᖁᖂᖃᖄᖅᖏᖐᖑᖒᖓᖔᖕᙱᙲᙳᙴᙵᙶᖖᖠᖡᖢᖣᖤᖥᖦᕼŁł",
                    "x-mac-ce": "\xc4Āā\xc9Ą\xd6\xdc\xe1ąČ\xe4čĆć\xe9ŹźĎ\xedďĒēĖ\xf3ė\xf4\xf6\xf5\xfaĚě\xfc†\xb0Ę\xa3\xa7•\xb6\xdf\xae\xa9™ę\xa8≠ģĮįĪ≤≥īĶ∂∑łĻļĽľĹĺŅņŃ\xac√ńŇ∆\xab\xbb…\xa0ňŐ\xd5őŌ–—“”‘’\xf7◊ōŔŕŘ‹›řŖŗŠ‚„šŚś\xc1Ťť\xcdŽžŪ\xd3\xd4ūŮ\xdaůŰűŲų\xdd\xfdķŻŁżĢˇ",
                    macintosh: "\xc4\xc5\xc7\xc9\xd1\xd6\xdc\xe1\xe0\xe2\xe4\xe3\xe5\xe7\xe9\xe8\xea\xeb\xed\xec\xee\xef\xf1\xf3\xf2\xf4\xf6\xf5\xfa\xf9\xfb\xfc†\xb0\xa2\xa3\xa7•\xb6\xdf\xae\xa9™\xb4\xa8≠\xc6\xd8∞\xb1≤≥\xa5\xb5∂∑∏π∫\xaa\xbaΩ\xe6\xf8\xbf\xa1\xac√ƒ≈∆\xab\xbb…\xa0\xc0\xc3\xd5Œœ–—“”‘’\xf7◊\xffŸ⁄€‹›ﬁﬂ‡\xb7‚„‰\xc2\xca\xc1\xcb\xc8\xcd\xce\xcf\xcc\xd3\xd4\xd2\xda\xdb\xd9ıˆ˜\xaf˘˙˚\xb8˝˛ˇ",
                    "x-mac-romanian": "\xc4\xc5\xc7\xc9\xd1\xd6\xdc\xe1\xe0\xe2\xe4\xe3\xe5\xe7\xe9\xe8\xea\xeb\xed\xec\xee\xef\xf1\xf3\xf2\xf4\xf6\xf5\xfa\xf9\xfb\xfc†\xb0\xa2\xa3\xa7•\xb6\xdf\xae\xa9™\xb4\xa8≠ĂȘ∞\xb1≤≥\xa5\xb5∂∑∏π∫\xaa\xbaΩăș\xbf\xa1\xac√ƒ≈∆\xab\xbb…\xa0\xc0\xc3\xd5Œœ–—“”‘’\xf7◊\xffŸ⁄€‹›Țț‡\xb7‚„‰\xc2\xca\xc1\xcb\xc8\xcd\xce\xcf\xcc\xd3\xd4\xd2\xda\xdb\xd9ıˆ˜\xaf˘˙˚\xb8˝˛ˇ",
                    "x-mac-turkish": "\xc4\xc5\xc7\xc9\xd1\xd6\xdc\xe1\xe0\xe2\xe4\xe3\xe5\xe7\xe9\xe8\xea\xeb\xed\xec\xee\xef\xf1\xf3\xf2\xf4\xf6\xf5\xfa\xf9\xfb\xfc†\xb0\xa2\xa3\xa7•\xb6\xdf\xae\xa9™\xb4\xa8≠\xc6\xd8∞\xb1≤≥\xa5\xb5∂∑∏π∫\xaa\xbaΩ\xe6\xf8\xbf\xa1\xac√ƒ≈∆\xab\xbb…\xa0\xc0\xc3\xd5Œœ–—“”‘’\xf7◊\xffŸĞğİıŞş‡\xb7‚„‰\xc2\xca\xc1\xcb\xc8\xcd\xce\xcf\xcc\xd3\xd4\xd2\xda\xdb\xd9ˆ˜\xaf˘˙˚\xb8˝˛ˇ"
                };
                d.MACSTRING = function(e, t, n, s) {
                    const o = v[s];
                    if (void 0 === o) return;
                    let r = "";
                    for(let s = 0; s < n; s++){
                        const n = e.getUint8(t + s);
                        r += n <= 127 ? String.fromCharCode(n) : o[127 & n];
                    }
                    return r;
                };
                const b = "function" == typeof WeakMap && new WeakMap;
                let x;
                function S(e) {
                    return e >= -128 && e <= 127;
                }
                function U(e, t, n) {
                    let s = 0;
                    const o = e.length;
                    for(; t < o && s < 64 && 0 === e[t];)++t, ++s;
                    return n.push(128 | s - 1), t;
                }
                function T(e, t, n) {
                    let s = 0;
                    const o = e.length;
                    let r = t;
                    for(; r < o && s < 64;){
                        const t = e[r];
                        if (!S(t)) break;
                        if (0 === t && r + 1 < o && 0 === e[r + 1]) break;
                        ++r, ++s;
                    }
                    n.push(s - 1);
                    for(let s = t; s < r; ++s)n.push(e[s] + 256 & 255);
                    return r;
                }
                function E(e, t, n) {
                    let s = 0;
                    const o = e.length;
                    let r = t;
                    for(; r < o && s < 64;){
                        const t = e[r];
                        if (0 === t) break;
                        if (S(t) && r + 1 < o && S(e[r + 1])) break;
                        ++r, ++s;
                    }
                    n.push(64 | s - 1);
                    for(let s = t; s < r; ++s){
                        const t = e[s];
                        n.push(t + 65536 >> 8 & 255, t + 256 & 255);
                    }
                    return r;
                }
                g.MACSTRING = function(e, t) {
                    const n = function(e) {
                        if (!x) {
                            x = {};
                            for(let e in v)x[e] = new String(e);
                        }
                        const t = x[e];
                        if (void 0 === t) return;
                        if (b) {
                            const e = b.get(t);
                            if (void 0 !== e) return e;
                        }
                        const n = v[e];
                        if (void 0 === n) return;
                        const s = {};
                        for(let e = 0; e < n.length; e++)s[n.charCodeAt(e)] = e + 128;
                        return b && b.set(t, s), s;
                    }(t);
                    if (void 0 === n) return;
                    const s = [];
                    for(let t = 0; t < e.length; t++){
                        let o = e.charCodeAt(t);
                        if (o >= 128 && (o = n[o], void 0 === o)) return;
                        s[t] = o;
                    }
                    return s;
                }, m.MACSTRING = function(e, t) {
                    const n = g.MACSTRING(e, t);
                    return void 0 !== n ? n.length : 0;
                }, g.VARDELTAS = function(e) {
                    let t = 0;
                    const n = [];
                    for(; t < e.length;){
                        const s = e[t];
                        t = 0 === s ? U(e, t, n) : s >= -128 && s <= 127 ? T(e, t, n) : E(e, t, n);
                    }
                    return n;
                }, g.INDEX = function(e) {
                    let t = 1;
                    const n = [
                        t
                    ], s = [];
                    for(let o = 0; o < e.length; o += 1){
                        const r = g.OBJECT(e[o]);
                        Array.prototype.push.apply(s, r), t += r.length, n.push(t);
                    }
                    if (0 === s.length) return [
                        0,
                        0
                    ];
                    const o = [], r = 1 + Math.floor(Math.log(t) / Math.log(2)) / 8 | 0, a = [
                        void 0,
                        g.BYTE,
                        g.USHORT,
                        g.UINT24,
                        g.ULONG
                    ][r];
                    for(let e = 0; e < n.length; e += 1){
                        const t = a(n[e]);
                        Array.prototype.push.apply(o, t);
                    }
                    return Array.prototype.concat(g.Card16(e.length), g.OffSize(r), o, s);
                }, m.INDEX = function(e) {
                    return g.INDEX(e).length;
                }, g.DICT = function(e) {
                    let t = [];
                    const n = Object.keys(e), s = n.length;
                    for(let o = 0; o < s; o += 1){
                        const s = parseInt(n[o], 0), r = e[s];
                        t = t.concat(g.OPERAND(r.value, r.type)), t = t.concat(g.OPERATOR(s));
                    }
                    return t;
                }, m.DICT = function(e) {
                    return g.DICT(e).length;
                }, g.OPERATOR = function(e) {
                    return e < 1200 ? [
                        e
                    ] : [
                        12,
                        e - 1200
                    ];
                }, g.OPERAND = function(e, t) {
                    let n = [];
                    if (Array.isArray(t)) for(let s = 0; s < t.length; s += 1)f.argument(e.length === t.length, "Not enough arguments given for type" + t), n = n.concat(g.OPERAND(e[s], t[s]));
                    else if ("SID" === t) n = n.concat(g.NUMBER(e));
                    else if ("offset" === t) n = n.concat(g.NUMBER32(e));
                    else if ("number" === t) n = n.concat(g.NUMBER(e));
                    else {
                        if ("real" !== t) throw new Error("Unknown operand type " + t);
                        n = n.concat(g.REAL(e));
                    }
                    return n;
                }, g.OP = g.BYTE, m.OP = m.BYTE;
                const k = "function" == typeof WeakMap && new WeakMap;
                function w(e, t, n) {
                    for(let e = 0; e < t.length; e += 1){
                        const n = t[e];
                        this[n.name] = n.value;
                    }
                    if (this.tableName = e, this.fields = t, n) {
                        const e = Object.keys(n);
                        for(let t = 0; t < e.length; t += 1){
                            const s = e[t], o = n[s];
                            void 0 !== this[s] && (this[s] = o);
                        }
                    }
                }
                function O(e, t, n) {
                    void 0 === n && (n = t.length);
                    const s = new Array(t.length + 1);
                    s[0] = {
                        name: e + "Count",
                        type: "USHORT",
                        value: n
                    };
                    for(let n = 0; n < t.length; n++)s[n + 1] = {
                        name: e + n,
                        type: "USHORT",
                        value: t[n]
                    };
                    return s;
                }
                function I(e, t, n) {
                    const s = t.length, o = new Array(s + 1);
                    o[0] = {
                        name: e + "Count",
                        type: "USHORT",
                        value: s
                    };
                    for(let r = 0; r < s; r++)o[r + 1] = {
                        name: e + r,
                        type: "TABLE",
                        value: n(t[r], r)
                    };
                    return o;
                }
                function R(e, t, n) {
                    const s = t.length;
                    let o = [];
                    o[0] = {
                        name: e + "Count",
                        type: "USHORT",
                        value: s
                    };
                    for(let e = 0; e < s; e++)o = o.concat(n(t[e], e));
                    return o;
                }
                function L(e) {
                    1 === e.format ? w.call(this, "coverageTable", [
                        {
                            name: "coverageFormat",
                            type: "USHORT",
                            value: 1
                        }
                    ].concat(O("glyph", e.glyphs))) : f.assert(!1, "Can't create coverage table format 2 yet.");
                }
                function B(e) {
                    w.call(this, "scriptListTable", R("scriptRecord", e, function(e, t) {
                        const n = e.script;
                        let s = n.defaultLangSys;
                        return f.assert(!!s, "Unable to write GSUB: script " + e.tag + " has no default language system."), [
                            {
                                name: "scriptTag" + t,
                                type: "TAG",
                                value: e.tag
                            },
                            {
                                name: "script" + t,
                                type: "TABLE",
                                value: new w("scriptTable", [
                                    {
                                        name: "defaultLangSys",
                                        type: "TABLE",
                                        value: new w("defaultLangSys", [
                                            {
                                                name: "lookupOrder",
                                                type: "USHORT",
                                                value: 0
                                            },
                                            {
                                                name: "reqFeatureIndex",
                                                type: "USHORT",
                                                value: s.reqFeatureIndex
                                            }
                                        ].concat(O("featureIndex", s.featureIndexes)))
                                    }
                                ].concat(R("langSys", n.langSysRecords, function(e, t) {
                                    const n = e.langSys;
                                    return [
                                        {
                                            name: "langSysTag" + t,
                                            type: "TAG",
                                            value: e.tag
                                        },
                                        {
                                            name: "langSys" + t,
                                            type: "TABLE",
                                            value: new w("langSys", [
                                                {
                                                    name: "lookupOrder",
                                                    type: "USHORT",
                                                    value: 0
                                                },
                                                {
                                                    name: "reqFeatureIndex",
                                                    type: "USHORT",
                                                    value: n.reqFeatureIndex
                                                }
                                            ].concat(O("featureIndex", n.featureIndexes)))
                                        }
                                    ];
                                })))
                            }
                        ];
                    }));
                }
                function C(e) {
                    w.call(this, "featureListTable", R("featureRecord", e, function(e, t) {
                        const n = e.feature;
                        return [
                            {
                                name: "featureTag" + t,
                                type: "TAG",
                                value: e.tag
                            },
                            {
                                name: "feature" + t,
                                type: "TABLE",
                                value: new w("featureTable", [
                                    {
                                        name: "featureParams",
                                        type: "USHORT",
                                        value: n.featureParams
                                    }
                                ].concat(O("lookupListIndex", n.lookupListIndexes)))
                            }
                        ];
                    }));
                }
                function D(e, t) {
                    w.call(this, "lookupListTable", I("lookup", e, function(e) {
                        let n = t[e.lookupType];
                        return f.assert(!!n, "Unable to write GSUB lookup type " + e.lookupType + " tables."), new w("lookupTable", [
                            {
                                name: "lookupType",
                                type: "USHORT",
                                value: e.lookupType
                            },
                            {
                                name: "lookupFlag",
                                type: "USHORT",
                                value: e.lookupFlag
                            }
                        ].concat(I("subtable", e.subtables, n)));
                    }));
                }
                g.CHARSTRING = function(e) {
                    if (k) {
                        const t = k.get(e);
                        if (void 0 !== t) return t;
                    }
                    let t = [];
                    const n = e.length;
                    for(let s = 0; s < n; s += 1){
                        const n = e[s];
                        t = t.concat(g[n.type](n.value));
                    }
                    return k && k.set(e, t), t;
                }, m.CHARSTRING = function(e) {
                    return g.CHARSTRING(e).length;
                }, g.OBJECT = function(e) {
                    const t = g[e.type];
                    return f.argument(void 0 !== t, "No encoding function for type " + e.type), t(e.value);
                }, m.OBJECT = function(e) {
                    const t = m[e.type];
                    return f.argument(void 0 !== t, "No sizeOf function for type " + e.type), t(e.value);
                }, g.TABLE = function(e) {
                    let t = [];
                    const n = e.fields.length, s = [], o = [];
                    for(let r = 0; r < n; r += 1){
                        const n = e.fields[r], a = g[n.type];
                        f.argument(void 0 !== a, "No encoding function for field type " + n.type + " (" + n.name + ")");
                        let i = e[n.name];
                        void 0 === i && (i = n.value);
                        const l = a(i);
                        "TABLE" === n.type ? (o.push(t.length), t = t.concat([
                            0,
                            0
                        ]), s.push(l)) : t = t.concat(l);
                    }
                    for(let n = 0; n < s.length; n += 1){
                        const r = o[n], a = t.length;
                        f.argument(a < 65536, "Table " + e.tableName + " too big."), t[r] = a >> 8, t[r + 1] = 255 & a, t = t.concat(s[n]);
                    }
                    return t;
                }, m.TABLE = function(e) {
                    let t = 0;
                    const n = e.fields.length;
                    for(let s = 0; s < n; s += 1){
                        const n = e.fields[s], o = m[n.type];
                        f.argument(void 0 !== o, "No sizeOf function for field type " + n.type + " (" + n.name + ")");
                        let r = e[n.name];
                        void 0 === r && (r = n.value), t += o(r), "TABLE" === n.type && (t += 2);
                    }
                    return t;
                }, g.RECORD = g.TABLE, m.RECORD = m.TABLE, g.LITERAL = function(e) {
                    return e;
                }, m.LITERAL = function(e) {
                    return e.length;
                }, w.prototype.encode = function() {
                    return g.TABLE(this);
                }, w.prototype.sizeOf = function() {
                    return m.TABLE(this);
                }, L.prototype = Object.create(w.prototype), L.prototype.constructor = L, B.prototype = Object.create(w.prototype), B.prototype.constructor = B, C.prototype = Object.create(w.prototype), C.prototype.constructor = C, D.prototype = Object.create(w.prototype), D.prototype.constructor = D;
                const M = {
                    Table: w,
                    Record: w,
                    Coverage: L,
                    ScriptList: B,
                    FeatureList: C,
                    LookupList: D,
                    ushortList: O,
                    tableList: I,
                    recordList: R
                };
                function P(e, t) {
                    return e.getUint8(t);
                }
                function A(e, t) {
                    return e.getUint16(t, !1);
                }
                function G(e, t) {
                    return e.getUint32(t, !1);
                }
                function N(e, t) {
                    return e.getInt16(t, !1) + e.getUint16(t + 2, !1) / 65535;
                }
                const F = {
                    byte: 1,
                    uShort: 2,
                    short: 2,
                    uLong: 4,
                    fixed: 4,
                    longDateTime: 8,
                    tag: 4
                };
                function _(e, t) {
                    this.data = e, this.offset = t, this.relativeOffset = 0;
                }
                _.prototype.parseByte = function() {
                    const e = this.data.getUint8(this.offset + this.relativeOffset);
                    return this.relativeOffset += 1, e;
                }, _.prototype.parseChar = function() {
                    const e = this.data.getInt8(this.offset + this.relativeOffset);
                    return this.relativeOffset += 1, e;
                }, _.prototype.parseCard8 = _.prototype.parseByte, _.prototype.parseUShort = function() {
                    const e = this.data.getUint16(this.offset + this.relativeOffset);
                    return this.relativeOffset += 2, e;
                }, _.prototype.parseCard16 = _.prototype.parseUShort, _.prototype.parseSID = _.prototype.parseUShort, _.prototype.parseOffset16 = _.prototype.parseUShort, _.prototype.parseShort = function() {
                    const e = this.data.getInt16(this.offset + this.relativeOffset);
                    return this.relativeOffset += 2, e;
                }, _.prototype.parseF2Dot14 = function() {
                    const e = this.data.getInt16(this.offset + this.relativeOffset) / 16384;
                    return this.relativeOffset += 2, e;
                }, _.prototype.parseULong = function() {
                    const e = G(this.data, this.offset + this.relativeOffset);
                    return this.relativeOffset += 4, e;
                }, _.prototype.parseOffset32 = _.prototype.parseULong, _.prototype.parseFixed = function() {
                    const e = N(this.data, this.offset + this.relativeOffset);
                    return this.relativeOffset += 4, e;
                }, _.prototype.parseString = function(e) {
                    const t = this.data, n = this.offset + this.relativeOffset;
                    let s = "";
                    this.relativeOffset += e;
                    for(let o = 0; o < e; o++)s += String.fromCharCode(t.getUint8(n + o));
                    return s;
                }, _.prototype.parseTag = function() {
                    return this.parseString(4);
                }, _.prototype.parseLongDateTime = function() {
                    let e = G(this.data, this.offset + this.relativeOffset + 4);
                    return e -= 2082844800, this.relativeOffset += 8, e;
                }, _.prototype.parseVersion = function(e) {
                    const t = A(this.data, this.offset + this.relativeOffset), n = A(this.data, this.offset + this.relativeOffset + 2);
                    return this.relativeOffset += 4, void 0 === e && (e = 4096), t + n / e / 10;
                }, _.prototype.skip = function(e, t) {
                    void 0 === t && (t = 1), this.relativeOffset += F[e] * t;
                }, _.prototype.parseULongList = function(e) {
                    void 0 === e && (e = this.parseULong());
                    const t = new Array(e), n = this.data;
                    let s = this.offset + this.relativeOffset;
                    for(let o = 0; o < e; o++)t[o] = n.getUint32(s), s += 4;
                    return this.relativeOffset += 4 * e, t;
                }, _.prototype.parseOffset16List = _.prototype.parseUShortList = function(e) {
                    void 0 === e && (e = this.parseUShort());
                    const t = new Array(e), n = this.data;
                    let s = this.offset + this.relativeOffset;
                    for(let o = 0; o < e; o++)t[o] = n.getUint16(s), s += 2;
                    return this.relativeOffset += 2 * e, t;
                }, _.prototype.parseShortList = function(e) {
                    const t = new Array(e), n = this.data;
                    let s = this.offset + this.relativeOffset;
                    for(let o = 0; o < e; o++)t[o] = n.getInt16(s), s += 2;
                    return this.relativeOffset += 2 * e, t;
                }, _.prototype.parseByteList = function(e) {
                    const t = new Array(e), n = this.data;
                    let s = this.offset + this.relativeOffset;
                    for(let o = 0; o < e; o++)t[o] = n.getUint8(s++);
                    return this.relativeOffset += e, t;
                }, _.prototype.parseList = function(e, t) {
                    t || (t = e, e = this.parseUShort());
                    const n = new Array(e);
                    for(let s = 0; s < e; s++)n[s] = t.call(this);
                    return n;
                }, _.prototype.parseList32 = function(e, t) {
                    t || (t = e, e = this.parseULong());
                    const n = new Array(e);
                    for(let s = 0; s < e; s++)n[s] = t.call(this);
                    return n;
                }, _.prototype.parseRecordList = function(e, t) {
                    t || (t = e, e = this.parseUShort());
                    const n = new Array(e), s = Object.keys(t);
                    for(let o = 0; o < e; o++){
                        const e = {};
                        for(let n = 0; n < s.length; n++){
                            const o = s[n], r = t[o];
                            e[o] = r.call(this);
                        }
                        n[o] = e;
                    }
                    return n;
                }, _.prototype.parseRecordList32 = function(e, t) {
                    t || (t = e, e = this.parseULong());
                    const n = new Array(e), s = Object.keys(t);
                    for(let o = 0; o < e; o++){
                        const e = {};
                        for(let n = 0; n < s.length; n++){
                            const o = s[n], r = t[o];
                            e[o] = r.call(this);
                        }
                        n[o] = e;
                    }
                    return n;
                }, _.prototype.parseStruct = function(e) {
                    if ("function" == typeof e) return e.call(this);
                    {
                        const t = Object.keys(e), n = {};
                        for(let s = 0; s < t.length; s++){
                            const o = t[s], r = e[o];
                            n[o] = r.call(this);
                        }
                        return n;
                    }
                }, _.prototype.parseValueRecord = function(e) {
                    if (void 0 === e && (e = this.parseUShort()), 0 === e) return;
                    const t = {};
                    return 1 & e && (t.xPlacement = this.parseShort()), 2 & e && (t.yPlacement = this.parseShort()), 4 & e && (t.xAdvance = this.parseShort()), 8 & e && (t.yAdvance = this.parseShort()), 16 & e && (t.xPlaDevice = void 0, this.parseShort()), 32 & e && (t.yPlaDevice = void 0, this.parseShort()), 64 & e && (t.xAdvDevice = void 0, this.parseShort()), 128 & e && (t.yAdvDevice = void 0, this.parseShort()), t;
                }, _.prototype.parseValueRecordList = function() {
                    const e = this.parseUShort(), t = this.parseUShort(), n = new Array(t);
                    for(let s = 0; s < t; s++)n[s] = this.parseValueRecord(e);
                    return n;
                }, _.prototype.parsePointer = function(e) {
                    const t = this.parseOffset16();
                    if (t > 0) return new _(this.data, this.offset + t).parseStruct(e);
                }, _.prototype.parsePointer32 = function(e) {
                    const t = this.parseOffset32();
                    if (t > 0) return new _(this.data, this.offset + t).parseStruct(e);
                }, _.prototype.parseListOfLists = function(e) {
                    const t = this.parseOffset16List(), n = t.length, s = this.relativeOffset, o = new Array(n);
                    for(let s = 0; s < n; s++){
                        const n = t[s];
                        if (0 !== n) {
                            if (this.relativeOffset = n, e) {
                                const t = this.parseOffset16List(), r = new Array(t.length);
                                for(let s = 0; s < t.length; s++)this.relativeOffset = n + t[s], r[s] = e.call(this);
                                o[s] = r;
                            } else o[s] = this.parseUShortList();
                        } else o[s] = void 0;
                    }
                    return this.relativeOffset = s, o;
                }, _.prototype.parseCoverage = function() {
                    const e = this.offset + this.relativeOffset, t = this.parseUShort(), n = this.parseUShort();
                    if (1 === t) return {
                        format: 1,
                        glyphs: this.parseUShortList(n)
                    };
                    if (2 === t) {
                        const e = new Array(n);
                        for(let t = 0; t < n; t++)e[t] = {
                            start: this.parseUShort(),
                            end: this.parseUShort(),
                            index: this.parseUShort()
                        };
                        return {
                            format: 2,
                            ranges: e
                        };
                    }
                    throw new Error("0x" + e.toString(16) + ": Coverage format must be 1 or 2.");
                }, _.prototype.parseClassDef = function() {
                    const e = this.offset + this.relativeOffset, t = this.parseUShort();
                    if (1 === t) return {
                        format: 1,
                        startGlyph: this.parseUShort(),
                        classes: this.parseUShortList()
                    };
                    if (2 === t) return {
                        format: 2,
                        ranges: this.parseRecordList({
                            start: _.uShort,
                            end: _.uShort,
                            classId: _.uShort
                        })
                    };
                    throw new Error("0x" + e.toString(16) + ": ClassDef format must be 1 or 2.");
                }, _.list = function(e, t) {
                    return function() {
                        return this.parseList(e, t);
                    };
                }, _.list32 = function(e, t) {
                    return function() {
                        return this.parseList32(e, t);
                    };
                }, _.recordList = function(e, t) {
                    return function() {
                        return this.parseRecordList(e, t);
                    };
                }, _.recordList32 = function(e, t) {
                    return function() {
                        return this.parseRecordList32(e, t);
                    };
                }, _.pointer = function(e) {
                    return function() {
                        return this.parsePointer(e);
                    };
                }, _.pointer32 = function(e) {
                    return function() {
                        return this.parsePointer32(e);
                    };
                }, _.tag = _.prototype.parseTag, _.byte = _.prototype.parseByte, _.uShort = _.offset16 = _.prototype.parseUShort, _.uShortList = _.prototype.parseUShortList, _.uLong = _.offset32 = _.prototype.parseULong, _.uLongList = _.prototype.parseULongList, _.struct = _.prototype.parseStruct, _.coverage = _.prototype.parseCoverage, _.classDef = _.prototype.parseClassDef;
                const H = {
                    reserved: _.uShort,
                    reqFeatureIndex: _.uShort,
                    featureIndexes: _.uShortList
                };
                _.prototype.parseScriptList = function() {
                    return this.parsePointer(_.recordList({
                        tag: _.tag,
                        script: _.pointer({
                            defaultLangSys: _.pointer(H),
                            langSysRecords: _.recordList({
                                tag: _.tag,
                                langSys: _.pointer(H)
                            })
                        })
                    })) || [];
                }, _.prototype.parseFeatureList = function() {
                    return this.parsePointer(_.recordList({
                        tag: _.tag,
                        feature: _.pointer({
                            featureParams: _.offset16,
                            lookupListIndexes: _.uShortList
                        })
                    })) || [];
                }, _.prototype.parseLookupList = function(e) {
                    return this.parsePointer(_.list(_.pointer(function() {
                        const t = this.parseUShort();
                        f.argument(1 <= t && t <= 9, "GPOS/GSUB lookup type " + t + " unknown.");
                        const n = this.parseUShort(), s = 16 & n;
                        return {
                            lookupType: t,
                            lookupFlag: n,
                            subtables: this.parseList(_.pointer(e[t])),
                            markFilteringSet: s ? this.parseUShort() : void 0
                        };
                    }))) || [];
                }, _.prototype.parseFeatureVariationsList = function() {
                    return this.parsePointer32(function() {
                        const e = this.parseUShort(), t = this.parseUShort();
                        return f.argument(1 === e && t < 1, "GPOS/GSUB feature variations table unknown."), this.parseRecordList32({
                            conditionSetOffset: _.offset32,
                            featureTableSubstitutionOffset: _.offset32
                        });
                    }) || [];
                };
                const z = {
                    getByte: P,
                    getCard8: P,
                    getUShort: A,
                    getCard16: A,
                    getShort: function(e, t) {
                        return e.getInt16(t, !1);
                    },
                    getULong: G,
                    getFixed: N,
                    getTag: function(e, t) {
                        let n = "";
                        for(let s = t; s < t + 4; s += 1)n += String.fromCharCode(e.getInt8(s));
                        return n;
                    },
                    getOffset: function(e, t, n) {
                        let s = 0;
                        for(let o = 0; o < n; o += 1)s <<= 8, s += e.getUint8(t + o);
                        return s;
                    },
                    getBytes: function(e, t, n) {
                        const s = [];
                        for(let o = t; o < n; o += 1)s.push(e.getUint8(o));
                        return s;
                    },
                    bytesToString: function(e) {
                        let t = "";
                        for(let n = 0; n < e.length; n += 1)t += String.fromCharCode(e[n]);
                        return t;
                    },
                    Parser: _
                };
                function W(e, t, n) {
                    e.segments.push({
                        end: t,
                        start: t,
                        delta: -(t - n),
                        offset: 0,
                        glyphIndex: n
                    });
                }
                const q = function(e, t) {
                    const n = {};
                    n.version = z.getUShort(e, t), f.argument(0 === n.version, "cmap table version should be 0."), n.numTables = z.getUShort(e, t + 2);
                    let s = -1;
                    for(let o = n.numTables - 1; o >= 0; o -= 1){
                        const n = z.getUShort(e, t + 4 + 8 * o), r = z.getUShort(e, t + 4 + 8 * o + 2);
                        if (3 === n && (0 === r || 1 === r || 10 === r)) {
                            s = z.getULong(e, t + 4 + 8 * o + 4);
                            break;
                        }
                    }
                    if (-1 === s) throw new Error("No valid cmap sub-tables found.");
                    const o = new z.Parser(e, t + s);
                    if (n.format = o.parseUShort(), 12 === n.format) !function(e, t) {
                        let n;
                        t.parseUShort(), e.length = t.parseULong(), e.language = t.parseULong(), e.groupCount = n = t.parseULong(), e.glyphIndexMap = {};
                        for(let s = 0; s < n; s += 1){
                            const n = t.parseULong(), s = t.parseULong();
                            let o = t.parseULong();
                            for(let t = n; t <= s; t += 1)e.glyphIndexMap[t] = o, o++;
                        }
                    }(n, o);
                    else {
                        if (4 !== n.format) throw new Error("Only format 4 and 12 cmap tables are supported (found format " + n.format + ").");
                        !function(e, t, n, s, o) {
                            let r;
                            e.length = t.parseUShort(), e.language = t.parseUShort(), e.segCount = r = t.parseUShort() >> 1, t.skip("uShort", 3), e.glyphIndexMap = {};
                            const a = new z.Parser(n, s + o + 14), i = new z.Parser(n, s + o + 16 + 2 * r), l = new z.Parser(n, s + o + 16 + 4 * r), u = new z.Parser(n, s + o + 16 + 6 * r);
                            let c = s + o + 16 + 8 * r;
                            for(let t = 0; t < r - 1; t += 1){
                                let t;
                                const s = a.parseUShort(), o = i.parseUShort(), r = l.parseShort(), p = u.parseUShort();
                                for(let a = o; a <= s; a += 1)0 !== p ? (c = u.offset + u.relativeOffset - 2, c += p, c += 2 * (a - o), t = z.getUShort(n, c), 0 !== t && (t = t + r & 65535)) : t = a + r & 65535, e.glyphIndexMap[a] = t;
                            }
                        }(n, o, e, t, s);
                    }
                    return n;
                }, j = function(e) {
                    let t, n = !0;
                    for(t = e.length - 1; t > 0; t -= 1)if (e.get(t).unicode > 65535) {
                        console.log("Adding CMAP format 12 (needed!)"), n = !1;
                        break;
                    }
                    let s = [
                        {
                            name: "version",
                            type: "USHORT",
                            value: 0
                        },
                        {
                            name: "numTables",
                            type: "USHORT",
                            value: n ? 1 : 2
                        },
                        {
                            name: "platformID",
                            type: "USHORT",
                            value: 3
                        },
                        {
                            name: "encodingID",
                            type: "USHORT",
                            value: 1
                        },
                        {
                            name: "offset",
                            type: "ULONG",
                            value: n ? 12 : 20
                        }
                    ];
                    n || (s = s.concat([
                        {
                            name: "cmap12PlatformID",
                            type: "USHORT",
                            value: 3
                        },
                        {
                            name: "cmap12EncodingID",
                            type: "USHORT",
                            value: 10
                        },
                        {
                            name: "cmap12Offset",
                            type: "ULONG",
                            value: 0
                        }
                    ])), s = s.concat([
                        {
                            name: "format",
                            type: "USHORT",
                            value: 4
                        },
                        {
                            name: "cmap4Length",
                            type: "USHORT",
                            value: 0
                        },
                        {
                            name: "language",
                            type: "USHORT",
                            value: 0
                        },
                        {
                            name: "segCountX2",
                            type: "USHORT",
                            value: 0
                        },
                        {
                            name: "searchRange",
                            type: "USHORT",
                            value: 0
                        },
                        {
                            name: "entrySelector",
                            type: "USHORT",
                            value: 0
                        },
                        {
                            name: "rangeShift",
                            type: "USHORT",
                            value: 0
                        }
                    ]);
                    const o = new M.Table("cmap", s);
                    for(o.segments = [], t = 0; t < e.length; t += 1){
                        const n = e.get(t);
                        for(let e = 0; e < n.unicodes.length; e += 1)W(o, n.unicodes[e], t);
                        o.segments = o.segments.sort(function(e, t) {
                            return e.start - t.start;
                        });
                    }
                    !function(e) {
                        e.segments.push({
                            end: 65535,
                            start: 65535,
                            delta: 1,
                            offset: 0
                        });
                    }(o);
                    const r = o.segments.length;
                    let a = 0, i = [], l = [], u = [], c = [], p = [], f = [];
                    for(t = 0; t < r; t += 1){
                        const e = o.segments[t];
                        e.end <= 65535 && e.start <= 65535 ? (i = i.concat({
                            name: "end_" + t,
                            type: "USHORT",
                            value: e.end
                        }), l = l.concat({
                            name: "start_" + t,
                            type: "USHORT",
                            value: e.start
                        }), u = u.concat({
                            name: "idDelta_" + t,
                            type: "SHORT",
                            value: e.delta
                        }), c = c.concat({
                            name: "idRangeOffset_" + t,
                            type: "USHORT",
                            value: e.offset
                        }), void 0 !== e.glyphId && (p = p.concat({
                            name: "glyph_" + t,
                            type: "USHORT",
                            value: e.glyphId
                        }))) : a += 1, n || void 0 === e.glyphIndex || (f = f.concat({
                            name: "cmap12Start_" + t,
                            type: "ULONG",
                            value: e.start
                        }), f = f.concat({
                            name: "cmap12End_" + t,
                            type: "ULONG",
                            value: e.end
                        }), f = f.concat({
                            name: "cmap12Glyph_" + t,
                            type: "ULONG",
                            value: e.glyphIndex
                        }));
                    }
                    if (o.segCountX2 = 2 * (r - a), o.searchRange = 2 * Math.pow(2, Math.floor(Math.log(r - a) / Math.log(2))), o.entrySelector = Math.log(o.searchRange / 2) / Math.log(2), o.rangeShift = o.segCountX2 - o.searchRange, o.fields = o.fields.concat(i), o.fields.push({
                        name: "reservedPad",
                        type: "USHORT",
                        value: 0
                    }), o.fields = o.fields.concat(l), o.fields = o.fields.concat(u), o.fields = o.fields.concat(c), o.fields = o.fields.concat(p), o.cmap4Length = 14 + 2 * i.length + 2 + 2 * l.length + 2 * u.length + 2 * c.length + 2 * p.length, !n) {
                        const e = 16 + 4 * f.length;
                        o.cmap12Offset = 20 + o.cmap4Length, o.fields = o.fields.concat([
                            {
                                name: "cmap12Format",
                                type: "USHORT",
                                value: 12
                            },
                            {
                                name: "cmap12Reserved",
                                type: "USHORT",
                                value: 0
                            },
                            {
                                name: "cmap12Length",
                                type: "ULONG",
                                value: e
                            },
                            {
                                name: "cmap12Language",
                                type: "ULONG",
                                value: 0
                            },
                            {
                                name: "cmap12nGroups",
                                type: "ULONG",
                                value: f.length / 3
                            }
                        ]), o.fields = o.fields.concat(f);
                    }
                    return o;
                }, X = [
                    ".notdef",
                    "space",
                    "exclam",
                    "quotedbl",
                    "numbersign",
                    "dollar",
                    "percent",
                    "ampersand",
                    "quoteright",
                    "parenleft",
                    "parenright",
                    "asterisk",
                    "plus",
                    "comma",
                    "hyphen",
                    "period",
                    "slash",
                    "zero",
                    "one",
                    "two",
                    "three",
                    "four",
                    "five",
                    "six",
                    "seven",
                    "eight",
                    "nine",
                    "colon",
                    "semicolon",
                    "less",
                    "equal",
                    "greater",
                    "question",
                    "at",
                    "A",
                    "B",
                    "C",
                    "D",
                    "E",
                    "F",
                    "G",
                    "H",
                    "I",
                    "J",
                    "K",
                    "L",
                    "M",
                    "N",
                    "O",
                    "P",
                    "Q",
                    "R",
                    "S",
                    "T",
                    "U",
                    "V",
                    "W",
                    "X",
                    "Y",
                    "Z",
                    "bracketleft",
                    "backslash",
                    "bracketright",
                    "asciicircum",
                    "underscore",
                    "quoteleft",
                    "a",
                    "b",
                    "c",
                    "d",
                    "e",
                    "f",
                    "g",
                    "h",
                    "i",
                    "j",
                    "k",
                    "l",
                    "m",
                    "n",
                    "o",
                    "p",
                    "q",
                    "r",
                    "s",
                    "t",
                    "u",
                    "v",
                    "w",
                    "x",
                    "y",
                    "z",
                    "braceleft",
                    "bar",
                    "braceright",
                    "asciitilde",
                    "exclamdown",
                    "cent",
                    "sterling",
                    "fraction",
                    "yen",
                    "florin",
                    "section",
                    "currency",
                    "quotesingle",
                    "quotedblleft",
                    "guillemotleft",
                    "guilsinglleft",
                    "guilsinglright",
                    "fi",
                    "fl",
                    "endash",
                    "dagger",
                    "daggerdbl",
                    "periodcentered",
                    "paragraph",
                    "bullet",
                    "quotesinglbase",
                    "quotedblbase",
                    "quotedblright",
                    "guillemotright",
                    "ellipsis",
                    "perthousand",
                    "questiondown",
                    "grave",
                    "acute",
                    "circumflex",
                    "tilde",
                    "macron",
                    "breve",
                    "dotaccent",
                    "dieresis",
                    "ring",
                    "cedilla",
                    "hungarumlaut",
                    "ogonek",
                    "caron",
                    "emdash",
                    "AE",
                    "ordfeminine",
                    "Lslash",
                    "Oslash",
                    "OE",
                    "ordmasculine",
                    "ae",
                    "dotlessi",
                    "lslash",
                    "oslash",
                    "oe",
                    "germandbls",
                    "onesuperior",
                    "logicalnot",
                    "mu",
                    "trademark",
                    "Eth",
                    "onehalf",
                    "plusminus",
                    "Thorn",
                    "onequarter",
                    "divide",
                    "brokenbar",
                    "degree",
                    "thorn",
                    "threequarters",
                    "twosuperior",
                    "registered",
                    "minus",
                    "eth",
                    "multiply",
                    "threesuperior",
                    "copyright",
                    "Aacute",
                    "Acircumflex",
                    "Adieresis",
                    "Agrave",
                    "Aring",
                    "Atilde",
                    "Ccedilla",
                    "Eacute",
                    "Ecircumflex",
                    "Edieresis",
                    "Egrave",
                    "Iacute",
                    "Icircumflex",
                    "Idieresis",
                    "Igrave",
                    "Ntilde",
                    "Oacute",
                    "Ocircumflex",
                    "Odieresis",
                    "Ograve",
                    "Otilde",
                    "Scaron",
                    "Uacute",
                    "Ucircumflex",
                    "Udieresis",
                    "Ugrave",
                    "Yacute",
                    "Ydieresis",
                    "Zcaron",
                    "aacute",
                    "acircumflex",
                    "adieresis",
                    "agrave",
                    "aring",
                    "atilde",
                    "ccedilla",
                    "eacute",
                    "ecircumflex",
                    "edieresis",
                    "egrave",
                    "iacute",
                    "icircumflex",
                    "idieresis",
                    "igrave",
                    "ntilde",
                    "oacute",
                    "ocircumflex",
                    "odieresis",
                    "ograve",
                    "otilde",
                    "scaron",
                    "uacute",
                    "ucircumflex",
                    "udieresis",
                    "ugrave",
                    "yacute",
                    "ydieresis",
                    "zcaron",
                    "exclamsmall",
                    "Hungarumlautsmall",
                    "dollaroldstyle",
                    "dollarsuperior",
                    "ampersandsmall",
                    "Acutesmall",
                    "parenleftsuperior",
                    "parenrightsuperior",
                    "266 ff",
                    "onedotenleader",
                    "zerooldstyle",
                    "oneoldstyle",
                    "twooldstyle",
                    "threeoldstyle",
                    "fouroldstyle",
                    "fiveoldstyle",
                    "sixoldstyle",
                    "sevenoldstyle",
                    "eightoldstyle",
                    "nineoldstyle",
                    "commasuperior",
                    "threequartersemdash",
                    "periodsuperior",
                    "questionsmall",
                    "asuperior",
                    "bsuperior",
                    "centsuperior",
                    "dsuperior",
                    "esuperior",
                    "isuperior",
                    "lsuperior",
                    "msuperior",
                    "nsuperior",
                    "osuperior",
                    "rsuperior",
                    "ssuperior",
                    "tsuperior",
                    "ff",
                    "ffi",
                    "ffl",
                    "parenleftinferior",
                    "parenrightinferior",
                    "Circumflexsmall",
                    "hyphensuperior",
                    "Gravesmall",
                    "Asmall",
                    "Bsmall",
                    "Csmall",
                    "Dsmall",
                    "Esmall",
                    "Fsmall",
                    "Gsmall",
                    "Hsmall",
                    "Ismall",
                    "Jsmall",
                    "Ksmall",
                    "Lsmall",
                    "Msmall",
                    "Nsmall",
                    "Osmall",
                    "Psmall",
                    "Qsmall",
                    "Rsmall",
                    "Ssmall",
                    "Tsmall",
                    "Usmall",
                    "Vsmall",
                    "Wsmall",
                    "Xsmall",
                    "Ysmall",
                    "Zsmall",
                    "colonmonetary",
                    "onefitted",
                    "rupiah",
                    "Tildesmall",
                    "exclamdownsmall",
                    "centoldstyle",
                    "Lslashsmall",
                    "Scaronsmall",
                    "Zcaronsmall",
                    "Dieresissmall",
                    "Brevesmall",
                    "Caronsmall",
                    "Dotaccentsmall",
                    "Macronsmall",
                    "figuredash",
                    "hypheninferior",
                    "Ogoneksmall",
                    "Ringsmall",
                    "Cedillasmall",
                    "questiondownsmall",
                    "oneeighth",
                    "threeeighths",
                    "fiveeighths",
                    "seveneighths",
                    "onethird",
                    "twothirds",
                    "zerosuperior",
                    "foursuperior",
                    "fivesuperior",
                    "sixsuperior",
                    "sevensuperior",
                    "eightsuperior",
                    "ninesuperior",
                    "zeroinferior",
                    "oneinferior",
                    "twoinferior",
                    "threeinferior",
                    "fourinferior",
                    "fiveinferior",
                    "sixinferior",
                    "seveninferior",
                    "eightinferior",
                    "nineinferior",
                    "centinferior",
                    "dollarinferior",
                    "periodinferior",
                    "commainferior",
                    "Agravesmall",
                    "Aacutesmall",
                    "Acircumflexsmall",
                    "Atildesmall",
                    "Adieresissmall",
                    "Aringsmall",
                    "AEsmall",
                    "Ccedillasmall",
                    "Egravesmall",
                    "Eacutesmall",
                    "Ecircumflexsmall",
                    "Edieresissmall",
                    "Igravesmall",
                    "Iacutesmall",
                    "Icircumflexsmall",
                    "Idieresissmall",
                    "Ethsmall",
                    "Ntildesmall",
                    "Ogravesmall",
                    "Oacutesmall",
                    "Ocircumflexsmall",
                    "Otildesmall",
                    "Odieresissmall",
                    "OEsmall",
                    "Oslashsmall",
                    "Ugravesmall",
                    "Uacutesmall",
                    "Ucircumflexsmall",
                    "Udieresissmall",
                    "Yacutesmall",
                    "Thornsmall",
                    "Ydieresissmall",
                    "001.000",
                    "001.001",
                    "001.002",
                    "001.003",
                    "Black",
                    "Bold",
                    "Book",
                    "Light",
                    "Medium",
                    "Regular",
                    "Roman",
                    "Semibold"
                ], Y = [
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "space",
                    "exclam",
                    "quotedbl",
                    "numbersign",
                    "dollar",
                    "percent",
                    "ampersand",
                    "quoteright",
                    "parenleft",
                    "parenright",
                    "asterisk",
                    "plus",
                    "comma",
                    "hyphen",
                    "period",
                    "slash",
                    "zero",
                    "one",
                    "two",
                    "three",
                    "four",
                    "five",
                    "six",
                    "seven",
                    "eight",
                    "nine",
                    "colon",
                    "semicolon",
                    "less",
                    "equal",
                    "greater",
                    "question",
                    "at",
                    "A",
                    "B",
                    "C",
                    "D",
                    "E",
                    "F",
                    "G",
                    "H",
                    "I",
                    "J",
                    "K",
                    "L",
                    "M",
                    "N",
                    "O",
                    "P",
                    "Q",
                    "R",
                    "S",
                    "T",
                    "U",
                    "V",
                    "W",
                    "X",
                    "Y",
                    "Z",
                    "bracketleft",
                    "backslash",
                    "bracketright",
                    "asciicircum",
                    "underscore",
                    "quoteleft",
                    "a",
                    "b",
                    "c",
                    "d",
                    "e",
                    "f",
                    "g",
                    "h",
                    "i",
                    "j",
                    "k",
                    "l",
                    "m",
                    "n",
                    "o",
                    "p",
                    "q",
                    "r",
                    "s",
                    "t",
                    "u",
                    "v",
                    "w",
                    "x",
                    "y",
                    "z",
                    "braceleft",
                    "bar",
                    "braceright",
                    "asciitilde",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "exclamdown",
                    "cent",
                    "sterling",
                    "fraction",
                    "yen",
                    "florin",
                    "section",
                    "currency",
                    "quotesingle",
                    "quotedblleft",
                    "guillemotleft",
                    "guilsinglleft",
                    "guilsinglright",
                    "fi",
                    "fl",
                    "",
                    "endash",
                    "dagger",
                    "daggerdbl",
                    "periodcentered",
                    "",
                    "paragraph",
                    "bullet",
                    "quotesinglbase",
                    "quotedblbase",
                    "quotedblright",
                    "guillemotright",
                    "ellipsis",
                    "perthousand",
                    "",
                    "questiondown",
                    "",
                    "grave",
                    "acute",
                    "circumflex",
                    "tilde",
                    "macron",
                    "breve",
                    "dotaccent",
                    "dieresis",
                    "",
                    "ring",
                    "cedilla",
                    "",
                    "hungarumlaut",
                    "ogonek",
                    "caron",
                    "emdash",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "AE",
                    "",
                    "ordfeminine",
                    "",
                    "",
                    "",
                    "",
                    "Lslash",
                    "Oslash",
                    "OE",
                    "ordmasculine",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "ae",
                    "",
                    "",
                    "",
                    "dotlessi",
                    "",
                    "",
                    "lslash",
                    "oslash",
                    "oe",
                    "germandbls"
                ], V = [
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "space",
                    "exclamsmall",
                    "Hungarumlautsmall",
                    "",
                    "dollaroldstyle",
                    "dollarsuperior",
                    "ampersandsmall",
                    "Acutesmall",
                    "parenleftsuperior",
                    "parenrightsuperior",
                    "twodotenleader",
                    "onedotenleader",
                    "comma",
                    "hyphen",
                    "period",
                    "fraction",
                    "zerooldstyle",
                    "oneoldstyle",
                    "twooldstyle",
                    "threeoldstyle",
                    "fouroldstyle",
                    "fiveoldstyle",
                    "sixoldstyle",
                    "sevenoldstyle",
                    "eightoldstyle",
                    "nineoldstyle",
                    "colon",
                    "semicolon",
                    "commasuperior",
                    "threequartersemdash",
                    "periodsuperior",
                    "questionsmall",
                    "",
                    "asuperior",
                    "bsuperior",
                    "centsuperior",
                    "dsuperior",
                    "esuperior",
                    "",
                    "",
                    "isuperior",
                    "",
                    "",
                    "lsuperior",
                    "msuperior",
                    "nsuperior",
                    "osuperior",
                    "",
                    "",
                    "rsuperior",
                    "ssuperior",
                    "tsuperior",
                    "",
                    "ff",
                    "fi",
                    "fl",
                    "ffi",
                    "ffl",
                    "parenleftinferior",
                    "",
                    "parenrightinferior",
                    "Circumflexsmall",
                    "hyphensuperior",
                    "Gravesmall",
                    "Asmall",
                    "Bsmall",
                    "Csmall",
                    "Dsmall",
                    "Esmall",
                    "Fsmall",
                    "Gsmall",
                    "Hsmall",
                    "Ismall",
                    "Jsmall",
                    "Ksmall",
                    "Lsmall",
                    "Msmall",
                    "Nsmall",
                    "Osmall",
                    "Psmall",
                    "Qsmall",
                    "Rsmall",
                    "Ssmall",
                    "Tsmall",
                    "Usmall",
                    "Vsmall",
                    "Wsmall",
                    "Xsmall",
                    "Ysmall",
                    "Zsmall",
                    "colonmonetary",
                    "onefitted",
                    "rupiah",
                    "Tildesmall",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "exclamdownsmall",
                    "centoldstyle",
                    "Lslashsmall",
                    "",
                    "",
                    "Scaronsmall",
                    "Zcaronsmall",
                    "Dieresissmall",
                    "Brevesmall",
                    "Caronsmall",
                    "",
                    "Dotaccentsmall",
                    "",
                    "",
                    "Macronsmall",
                    "",
                    "",
                    "figuredash",
                    "hypheninferior",
                    "",
                    "",
                    "Ogoneksmall",
                    "Ringsmall",
                    "Cedillasmall",
                    "",
                    "",
                    "",
                    "onequarter",
                    "onehalf",
                    "threequarters",
                    "questiondownsmall",
                    "oneeighth",
                    "threeeighths",
                    "fiveeighths",
                    "seveneighths",
                    "onethird",
                    "twothirds",
                    "",
                    "",
                    "zerosuperior",
                    "onesuperior",
                    "twosuperior",
                    "threesuperior",
                    "foursuperior",
                    "fivesuperior",
                    "sixsuperior",
                    "sevensuperior",
                    "eightsuperior",
                    "ninesuperior",
                    "zeroinferior",
                    "oneinferior",
                    "twoinferior",
                    "threeinferior",
                    "fourinferior",
                    "fiveinferior",
                    "sixinferior",
                    "seveninferior",
                    "eightinferior",
                    "nineinferior",
                    "centinferior",
                    "dollarinferior",
                    "periodinferior",
                    "commainferior",
                    "Agravesmall",
                    "Aacutesmall",
                    "Acircumflexsmall",
                    "Atildesmall",
                    "Adieresissmall",
                    "Aringsmall",
                    "AEsmall",
                    "Ccedillasmall",
                    "Egravesmall",
                    "Eacutesmall",
                    "Ecircumflexsmall",
                    "Edieresissmall",
                    "Igravesmall",
                    "Iacutesmall",
                    "Icircumflexsmall",
                    "Idieresissmall",
                    "Ethsmall",
                    "Ntildesmall",
                    "Ogravesmall",
                    "Oacutesmall",
                    "Ocircumflexsmall",
                    "Otildesmall",
                    "Odieresissmall",
                    "OEsmall",
                    "Oslashsmall",
                    "Ugravesmall",
                    "Uacutesmall",
                    "Ucircumflexsmall",
                    "Udieresissmall",
                    "Yacutesmall",
                    "Thornsmall",
                    "Ydieresissmall"
                ], Z = [
                    ".notdef",
                    ".null",
                    "nonmarkingreturn",
                    "space",
                    "exclam",
                    "quotedbl",
                    "numbersign",
                    "dollar",
                    "percent",
                    "ampersand",
                    "quotesingle",
                    "parenleft",
                    "parenright",
                    "asterisk",
                    "plus",
                    "comma",
                    "hyphen",
                    "period",
                    "slash",
                    "zero",
                    "one",
                    "two",
                    "three",
                    "four",
                    "five",
                    "six",
                    "seven",
                    "eight",
                    "nine",
                    "colon",
                    "semicolon",
                    "less",
                    "equal",
                    "greater",
                    "question",
                    "at",
                    "A",
                    "B",
                    "C",
                    "D",
                    "E",
                    "F",
                    "G",
                    "H",
                    "I",
                    "J",
                    "K",
                    "L",
                    "M",
                    "N",
                    "O",
                    "P",
                    "Q",
                    "R",
                    "S",
                    "T",
                    "U",
                    "V",
                    "W",
                    "X",
                    "Y",
                    "Z",
                    "bracketleft",
                    "backslash",
                    "bracketright",
                    "asciicircum",
                    "underscore",
                    "grave",
                    "a",
                    "b",
                    "c",
                    "d",
                    "e",
                    "f",
                    "g",
                    "h",
                    "i",
                    "j",
                    "k",
                    "l",
                    "m",
                    "n",
                    "o",
                    "p",
                    "q",
                    "r",
                    "s",
                    "t",
                    "u",
                    "v",
                    "w",
                    "x",
                    "y",
                    "z",
                    "braceleft",
                    "bar",
                    "braceright",
                    "asciitilde",
                    "Adieresis",
                    "Aring",
                    "Ccedilla",
                    "Eacute",
                    "Ntilde",
                    "Odieresis",
                    "Udieresis",
                    "aacute",
                    "agrave",
                    "acircumflex",
                    "adieresis",
                    "atilde",
                    "aring",
                    "ccedilla",
                    "eacute",
                    "egrave",
                    "ecircumflex",
                    "edieresis",
                    "iacute",
                    "igrave",
                    "icircumflex",
                    "idieresis",
                    "ntilde",
                    "oacute",
                    "ograve",
                    "ocircumflex",
                    "odieresis",
                    "otilde",
                    "uacute",
                    "ugrave",
                    "ucircumflex",
                    "udieresis",
                    "dagger",
                    "degree",
                    "cent",
                    "sterling",
                    "section",
                    "bullet",
                    "paragraph",
                    "germandbls",
                    "registered",
                    "copyright",
                    "trademark",
                    "acute",
                    "dieresis",
                    "notequal",
                    "AE",
                    "Oslash",
                    "infinity",
                    "plusminus",
                    "lessequal",
                    "greaterequal",
                    "yen",
                    "mu",
                    "partialdiff",
                    "summation",
                    "product",
                    "pi",
                    "integral",
                    "ordfeminine",
                    "ordmasculine",
                    "Omega",
                    "ae",
                    "oslash",
                    "questiondown",
                    "exclamdown",
                    "logicalnot",
                    "radical",
                    "florin",
                    "approxequal",
                    "Delta",
                    "guillemotleft",
                    "guillemotright",
                    "ellipsis",
                    "nonbreakingspace",
                    "Agrave",
                    "Atilde",
                    "Otilde",
                    "OE",
                    "oe",
                    "endash",
                    "emdash",
                    "quotedblleft",
                    "quotedblright",
                    "quoteleft",
                    "quoteright",
                    "divide",
                    "lozenge",
                    "ydieresis",
                    "Ydieresis",
                    "fraction",
                    "currency",
                    "guilsinglleft",
                    "guilsinglright",
                    "fi",
                    "fl",
                    "daggerdbl",
                    "periodcentered",
                    "quotesinglbase",
                    "quotedblbase",
                    "perthousand",
                    "Acircumflex",
                    "Ecircumflex",
                    "Aacute",
                    "Edieresis",
                    "Egrave",
                    "Iacute",
                    "Icircumflex",
                    "Idieresis",
                    "Igrave",
                    "Oacute",
                    "Ocircumflex",
                    "apple",
                    "Ograve",
                    "Uacute",
                    "Ucircumflex",
                    "Ugrave",
                    "dotlessi",
                    "circumflex",
                    "tilde",
                    "macron",
                    "breve",
                    "dotaccent",
                    "ring",
                    "cedilla",
                    "hungarumlaut",
                    "ogonek",
                    "caron",
                    "Lslash",
                    "lslash",
                    "Scaron",
                    "scaron",
                    "Zcaron",
                    "zcaron",
                    "brokenbar",
                    "Eth",
                    "eth",
                    "Yacute",
                    "yacute",
                    "Thorn",
                    "thorn",
                    "minus",
                    "multiply",
                    "onesuperior",
                    "twosuperior",
                    "threesuperior",
                    "onehalf",
                    "onequarter",
                    "threequarters",
                    "franc",
                    "Gbreve",
                    "gbreve",
                    "Idotaccent",
                    "Scedilla",
                    "scedilla",
                    "Cacute",
                    "cacute",
                    "Ccaron",
                    "ccaron",
                    "dcroat"
                ];
                function Q(e) {
                    this.font = e;
                }
                function J(e) {
                    this.cmap = e;
                }
                function K(e, t) {
                    this.encoding = e, this.charset = t;
                }
                function $(e) {
                    switch(e.version){
                        case 1:
                            this.names = Z.slice();
                            break;
                        case 2:
                            this.names = new Array(e.numberOfGlyphs);
                            for(let t = 0; t < e.numberOfGlyphs; t++)e.glyphNameIndex[t] < Z.length ? this.names[t] = Z[e.glyphNameIndex[t]] : this.names[t] = e.names[e.glyphNameIndex[t] - Z.length];
                            break;
                        case 2.5:
                            this.names = new Array(e.numberOfGlyphs);
                            for(let t = 0; t < e.numberOfGlyphs; t++)this.names[t] = Z[t + e.glyphNameIndex[t]];
                            break;
                        default:
                            this.names = [];
                    }
                }
                Q.prototype.charToGlyphIndex = function(e) {
                    const t = e.charCodeAt(0), n = this.font.glyphs;
                    if (n) for(let e = 0; e < n.length; e += 1){
                        const s = n.get(e);
                        for(let n = 0; n < s.unicodes.length; n += 1)if (s.unicodes[n] === t) return e;
                    }
                    return null;
                }, J.prototype.charToGlyphIndex = function(e) {
                    return this.cmap.glyphIndexMap[e.charCodeAt(0)] || 0;
                }, K.prototype.charToGlyphIndex = function(e) {
                    const t = e.charCodeAt(0), n = this.encoding[t];
                    return this.charset.indexOf(n);
                }, $.prototype.nameToGlyphIndex = function(e) {
                    return this.names.indexOf(e);
                }, $.prototype.glyphIndexToName = function(e) {
                    return this.names[e];
                };
                const ee = function(e, t, n, s, o) {
                    e.beginPath(), e.moveTo(t, n), e.lineTo(s, o), e.stroke();
                };
                function te(e, t, n, s, o) {
                    let r;
                    return (t & s) > 0 ? (r = e.parseByte(), 0 == (t & o) && (r = -r), r = n + r) : r = (t & o) > 0 ? n : n + e.parseShort(), r;
                }
                function ne(e, t, n) {
                    const s = new z.Parser(t, n);
                    let o, r;
                    if (e.numberOfContours = s.parseShort(), e._xMin = s.parseShort(), e._yMin = s.parseShort(), e._xMax = s.parseShort(), e._yMax = s.parseShort(), e.numberOfContours > 0) {
                        const t = e.endPointIndices = [];
                        for(let n = 0; n < e.numberOfContours; n += 1)t.push(s.parseUShort());
                        e.instructionLength = s.parseUShort(), e.instructions = [];
                        for(let t = 0; t < e.instructionLength; t += 1)e.instructions.push(s.parseByte());
                        const n = t[t.length - 1] + 1;
                        o = [];
                        for(let e = 0; e < n; e += 1)if (r = s.parseByte(), o.push(r), (8 & r) > 0) {
                            const t = s.parseByte();
                            for(let n = 0; n < t; n += 1)o.push(r), e += 1;
                        }
                        if (f.argument(o.length === n, "Bad flags."), t.length > 0) {
                            const a = [];
                            let i;
                            if (n > 0) {
                                for(let e = 0; e < n; e += 1)r = o[e], i = {}, i.onCurve = !!(1 & r), i.lastPointOfContour = t.indexOf(e) >= 0, a.push(i);
                                let e = 0;
                                for(let t = 0; t < n; t += 1)r = o[t], i = a[t], i.x = te(s, r, e, 2, 16), e = i.x;
                                let l = 0;
                                for(let e = 0; e < n; e += 1)r = o[e], i = a[e], i.y = te(s, r, l, 4, 32), l = i.y;
                            }
                            e.points = a;
                        } else e.points = [];
                    } else if (0 === e.numberOfContours) e.points = [];
                    else {
                        e.isComposite = !0, e.points = [], e.components = [];
                        let t = !0;
                        for(; t;){
                            o = s.parseUShort();
                            const n = {
                                glyphIndex: s.parseUShort(),
                                xScale: 1,
                                scale01: 0,
                                scale10: 0,
                                yScale: 1,
                                dx: 0,
                                dy: 0
                            };
                            (1 & o) > 0 ? (2 & o) > 0 ? (n.dx = s.parseShort(), n.dy = s.parseShort()) : n.matchedPoints = [
                                s.parseUShort(),
                                s.parseUShort()
                            ] : (2 & o) > 0 ? (n.dx = s.parseChar(), n.dy = s.parseChar()) : n.matchedPoints = [
                                s.parseByte(),
                                s.parseByte()
                            ], (8 & o) > 0 ? n.xScale = n.yScale = s.parseF2Dot14() : (64 & o) > 0 ? (n.xScale = s.parseF2Dot14(), n.yScale = s.parseF2Dot14()) : (128 & o) > 0 && (n.xScale = s.parseF2Dot14(), n.scale01 = s.parseF2Dot14(), n.scale10 = s.parseF2Dot14(), n.yScale = s.parseF2Dot14()), e.components.push(n), t = !!(32 & o);
                        }
                        if (256 & o) {
                            e.instructionLength = s.parseUShort(), e.instructions = [];
                            for(let t = 0; t < e.instructionLength; t += 1)e.instructions.push(s.parseByte());
                        }
                    }
                }
                function se(e, t) {
                    const n = [];
                    for(let s = 0; s < e.length; s += 1){
                        const o = e[s], r = {
                            x: t.xScale * o.x + t.scale01 * o.y + t.dx,
                            y: t.scale10 * o.x + t.yScale * o.y + t.dy,
                            onCurve: o.onCurve,
                            lastPointOfContour: o.lastPointOfContour
                        };
                        n.push(r);
                    }
                    return n;
                }
                function oe(e) {
                    const t = new u;
                    if (!e) return t;
                    const n = function(e) {
                        const t = [];
                        let n = [];
                        for(let s = 0; s < e.length; s += 1){
                            const o = e[s];
                            n.push(o), o.lastPointOfContour && (t.push(n), n = []);
                        }
                        return f.argument(0 === n.length, "There are still points left in the current contour."), t;
                    }(e);
                    for(let e = 0; e < n.length; ++e){
                        const s = n[e];
                        let o = null, r = s[s.length - 1], a = s[0];
                        if (r.onCurve) t.moveTo(r.x, r.y);
                        else if (a.onCurve) t.moveTo(a.x, a.y);
                        else {
                            const e = {
                                x: .5 * (r.x + a.x),
                                y: .5 * (r.y + a.y)
                            };
                            t.moveTo(e.x, e.y);
                        }
                        for(let e = 0; e < s.length; ++e)if (o = r, r = a, a = s[(e + 1) % s.length], r.onCurve) t.lineTo(r.x, r.y);
                        else {
                            let e = o, n = a;
                            o.onCurve || (e = {
                                x: .5 * (r.x + o.x),
                                y: .5 * (r.y + o.y)
                            }, t.lineTo(e.x, e.y)), a.onCurve || (n = {
                                x: .5 * (r.x + a.x),
                                y: .5 * (r.y + a.y)
                            }), t.lineTo(e.x, e.y), t.quadraticCurveTo(r.x, r.y, n.x, n.y);
                        }
                        t.closePath();
                    }
                    return t;
                }
                function re(e, t) {
                    if (t.isComposite) for(let n = 0; n < t.components.length; n += 1){
                        const s = t.components[n], o = e.get(s.glyphIndex);
                        if (o.getPath(), o.points) {
                            let e;
                            if (void 0 === s.matchedPoints) e = se(o.points, s);
                            else {
                                if (s.matchedPoints[0] > t.points.length - 1 || s.matchedPoints[1] > o.points.length - 1) throw Error("Matched points out of range in " + t.name);
                                const n = t.points[s.matchedPoints[0]];
                                let r = o.points[s.matchedPoints[1]];
                                const a = {
                                    xScale: s.xScale,
                                    scale01: s.scale01,
                                    scale10: s.scale10,
                                    yScale: s.yScale,
                                    dx: 0,
                                    dy: 0
                                };
                                r = se([
                                    r
                                ], a)[0], a.dx = n.x - r.x, a.dy = n.y - r.y, e = se(o.points, a);
                            }
                            t.points = t.points.concat(e);
                        }
                    }
                    return oe(t.points);
                }
                const ae = {
                    getPath: oe,
                    parse: function(e, t, n, s) {
                        const o = new pe.GlyphSet(s);
                        for(let r = 0; r < n.length - 1; r += 1){
                            const a = n[r];
                            a !== n[r + 1] ? o.push(r, pe.ttfGlyphLoader(s, r, ne, e, t + a, re)) : o.push(r, pe.glyphLoader(s, r));
                        }
                        return o;
                    }
                };
                function ie(e) {
                    this.bindConstructorValues(e);
                }
                ie.prototype.bindConstructorValues = function(e) {
                    this.index = e.index || 0, this.name = e.name || null, this.unicode = e.unicode || void 0, this.unicodes = e.unicodes || void 0 !== e.unicode ? [
                        e.unicode
                    ] : [], e.xMin && (this.xMin = e.xMin), e.yMin && (this.yMin = e.yMin), e.xMax && (this.xMax = e.xMax), e.yMax && (this.yMax = e.yMax), e.advanceWidth && (this.advanceWidth = e.advanceWidth), Object.defineProperty(this, "path", function(e, t) {
                        let n = t || new u;
                        return {
                            configurable: !0,
                            get: function() {
                                return "function" == typeof n && (n = n()), n;
                            },
                            set: function(e) {
                                n = e;
                            }
                        };
                    }(0, e.path));
                }, ie.prototype.addUnicode = function(e) {
                    0 === this.unicodes.length && (this.unicode = e), this.unicodes.push(e);
                }, ie.prototype.getBoundingBox = function() {
                    return this.path.getBoundingBox();
                }, ie.prototype.getPath = function(e, t, n, s, o) {
                    let r, a;
                    e = void 0 !== e ? e : 0, t = void 0 !== t ? t : 0, n = void 0 !== n ? n : 72, s || (s = {});
                    let i = s.xScale, l = s.yScale;
                    if (s.hinting && o && o.hinting && (a = this.path && o.hinting.exec(this, n)), a) r = ae.getPath(a).commands, e = Math.round(e), t = Math.round(t), i = l = 1;
                    else {
                        r = this.path.commands;
                        const e = 1 / this.path.unitsPerEm * n;
                        void 0 === i && (i = e), void 0 === l && (l = e);
                    }
                    const c = new u;
                    for(let n = 0; n < r.length; n += 1){
                        const s = r[n];
                        "M" === s.type ? c.moveTo(e + s.x * i, t + -s.y * l) : "L" === s.type ? c.lineTo(e + s.x * i, t + -s.y * l) : "Q" === s.type ? c.quadraticCurveTo(e + s.x1 * i, t + -s.y1 * l, e + s.x * i, t + -s.y * l) : "C" === s.type ? c.curveTo(e + s.x1 * i, t + -s.y1 * l, e + s.x2 * i, t + -s.y2 * l, e + s.x * i, t + -s.y * l) : "Z" === s.type && c.closePath();
                    }
                    return c;
                }, ie.prototype.getContours = function() {
                    if (void 0 === this.points) return [];
                    const e = [];
                    let t = [];
                    for(let n = 0; n < this.points.length; n += 1){
                        const s = this.points[n];
                        t.push(s), s.lastPointOfContour && (e.push(t), t = []);
                    }
                    return f.argument(0 === t.length, "There are still points left in the current contour."), e;
                }, ie.prototype.getMetrics = function() {
                    const e = this.path.commands, t = [], n = [];
                    for(let s = 0; s < e.length; s += 1){
                        const o = e[s];
                        "Z" !== o.type && (t.push(o.x), n.push(o.y)), "Q" !== o.type && "C" !== o.type || (t.push(o.x1), n.push(o.y1)), "C" === o.type && (t.push(o.x2), n.push(o.y2));
                    }
                    const s = {
                        xMin: Math.min.apply(null, t),
                        yMin: Math.min.apply(null, n),
                        xMax: Math.max.apply(null, t),
                        yMax: Math.max.apply(null, n),
                        leftSideBearing: this.leftSideBearing
                    };
                    return isFinite(s.xMin) || (s.xMin = 0), isFinite(s.xMax) || (s.xMax = this.advanceWidth), isFinite(s.yMin) || (s.yMin = 0), isFinite(s.yMax) || (s.yMax = 0), s.rightSideBearing = this.advanceWidth - s.leftSideBearing - (s.xMax - s.xMin), s;
                }, ie.prototype.draw = function(e, t, n, s, o) {
                    this.getPath(t, n, s, o).draw(e);
                }, ie.prototype.drawPoints = function(e, t, n, s) {
                    function o(t, n, s, o) {
                        const r = 2 * Math.PI;
                        e.beginPath();
                        for(let a = 0; a < t.length; a += 1)e.moveTo(n + t[a].x * o, s + t[a].y * o), e.arc(n + t[a].x * o, s + t[a].y * o, 2, 0, r, !1);
                        e.closePath(), e.fill();
                    }
                    t = void 0 !== t ? t : 0, n = void 0 !== n ? n : 0, s = void 0 !== s ? s : 24;
                    const r = 1 / this.path.unitsPerEm * s, a = [], i = [], l = this.path;
                    for(let e = 0; e < l.commands.length; e += 1){
                        const t = l.commands[e];
                        void 0 !== t.x && a.push({
                            x: t.x,
                            y: -t.y
                        }), void 0 !== t.x1 && i.push({
                            x: t.x1,
                            y: -t.y1
                        }), void 0 !== t.x2 && i.push({
                            x: t.x2,
                            y: -t.y2
                        });
                    }
                    e.fillStyle = "blue", o(a, t, n, r), e.fillStyle = "red", o(i, t, n, r);
                }, ie.prototype.drawMetrics = function(e, t, n, s) {
                    let o;
                    t = void 0 !== t ? t : 0, n = void 0 !== n ? n : 0, s = void 0 !== s ? s : 24, o = 1 / this.path.unitsPerEm * s, e.lineWidth = 1, e.strokeStyle = "black", ee(e, t, -10000, t, 1e4), ee(e, -10000, n, 1e4, n);
                    const r = this.xMin || 0;
                    let a = this.yMin || 0;
                    const i = this.xMax || 0;
                    let l = this.yMax || 0;
                    const u = this.advanceWidth || 0;
                    e.strokeStyle = "blue", ee(e, t + r * o, -10000, t + r * o, 1e4), ee(e, t + i * o, -10000, t + i * o, 1e4), ee(e, -10000, n + -a * o, 1e4, n + -a * o), ee(e, -10000, n + -l * o, 1e4, n + -l * o), e.strokeStyle = "green", ee(e, t + u * o, -10000, t + u * o, 1e4);
                };
                const le = ie;
                function ue(e, t, n) {
                    Object.defineProperty(e, t, {
                        get: function() {
                            return e.path, e[n];
                        },
                        set: function(t) {
                            e[n] = t;
                        },
                        enumerable: !0,
                        configurable: !0
                    });
                }
                function ce(e, t) {
                    if (this.font = e, this.glyphs = {}, Array.isArray(t)) for(let e = 0; e < t.length; e++)this.glyphs[e] = t[e];
                    this.length = t && t.length || 0;
                }
                ce.prototype.get = function(e) {
                    return "function" == typeof this.glyphs[e] && (this.glyphs[e] = this.glyphs[e]()), this.glyphs[e];
                }, ce.prototype.push = function(e, t) {
                    this.glyphs[e] = t, this.length++;
                };
                const pe = {
                    GlyphSet: ce,
                    glyphLoader: function(e, t) {
                        return new le({
                            index: t,
                            font: e
                        });
                    },
                    ttfGlyphLoader: function(e, t, n, s, o, r) {
                        return function() {
                            const a = new le({
                                index: t,
                                font: e
                            });
                            return a.path = function() {
                                n(a, s, o);
                                const t = r(e.glyphs, a);
                                return t.unitsPerEm = e.unitsPerEm, t;
                            }, ue(a, "xMin", "_xMin"), ue(a, "xMax", "_xMax"), ue(a, "yMin", "_yMin"), ue(a, "yMax", "_yMax"), a;
                        };
                    },
                    cffGlyphLoader: function(e, t, n, s) {
                        return function() {
                            const o = new le({
                                index: t,
                                font: e
                            });
                            return o.path = function() {
                                const t = n(e, o, s);
                                return t.unitsPerEm = e.unitsPerEm, t;
                            }, o;
                        };
                    }
                };
                function fe(e, t) {
                    if (e === t) return !0;
                    if (Array.isArray(e) && Array.isArray(t)) {
                        if (e.length !== t.length) return !1;
                        for(let n = 0; n < e.length; n += 1)if (!fe(e[n], t[n])) return !1;
                        return !0;
                    }
                    return !1;
                }
                function he(e) {
                    let t;
                    return t = e.length < 1240 ? 107 : e.length < 33900 ? 1131 : 32768, t;
                }
                function de(e, t, n) {
                    const s = [], o = [], r = z.getCard16(e, t);
                    let a, i;
                    if (0 !== r) {
                        const n = z.getByte(e, t + 2);
                        a = t + (r + 1) * n + 2;
                        let o = t + 3;
                        for(let t = 0; t < r + 1; t += 1)s.push(z.getOffset(e, o, n)), o += n;
                        i = a + s[r];
                    } else i = t + 2;
                    for(let t = 0; t < s.length - 1; t += 1){
                        let r = z.getBytes(e, a + s[t], a + s[t + 1]);
                        n && (r = n(r)), o.push(r);
                    }
                    return {
                        objects: o,
                        startOffset: t,
                        endOffset: i
                    };
                }
                function ge(e, t) {
                    let n, s, o, r;
                    if (28 === t) return n = e.parseByte(), s = e.parseByte(), n << 8 | s;
                    if (29 === t) return n = e.parseByte(), s = e.parseByte(), o = e.parseByte(), r = e.parseByte(), n << 24 | s << 16 | o << 8 | r;
                    if (30 === t) return function(e) {
                        let t = "";
                        const n = [
                            "0",
                            "1",
                            "2",
                            "3",
                            "4",
                            "5",
                            "6",
                            "7",
                            "8",
                            "9",
                            ".",
                            "E",
                            "E-",
                            null,
                            "-"
                        ];
                        for(;;){
                            const s = e.parseByte(), o = s >> 4, r = 15 & s;
                            if (15 === o) break;
                            if (t += n[o], 15 === r) break;
                            t += n[r];
                        }
                        return parseFloat(t);
                    }(e);
                    if (t >= 32 && t <= 246) return t - 139;
                    if (t >= 247 && t <= 250) return n = e.parseByte(), 256 * (t - 247) + n + 108;
                    if (t >= 251 && t <= 254) return n = e.parseByte(), 256 * -(t - 251) - n - 108;
                    throw new Error("Invalid b0 " + t);
                }
                function me(e, t, n) {
                    t = void 0 !== t ? t : 0;
                    const s = new z.Parser(e, t), o = [];
                    let r = [];
                    for(n = void 0 !== n ? n : e.length; s.relativeOffset < n;){
                        let e = s.parseByte();
                        e <= 21 ? (12 === e && (e = 1200 + s.parseByte()), o.push([
                            e,
                            r
                        ]), r = []) : r.push(ge(s, e));
                    }
                    return function(e) {
                        const t = {};
                        for(let n = 0; n < e.length; n += 1){
                            const s = e[n][0], o = e[n][1];
                            let r;
                            if (r = 1 === o.length ? o[0] : o, t.hasOwnProperty(s) && !isNaN(t[s])) throw new Error("Object " + t + " already has key " + s);
                            t[s] = r;
                        }
                        return t;
                    }(o);
                }
                function ye(e, t) {
                    return t <= 390 ? X[t] : e[t - 391];
                }
                function ve(e, t, n) {
                    const s = {};
                    let o;
                    for(let r = 0; r < t.length; r += 1){
                        const a = t[r];
                        if (Array.isArray(a.type)) {
                            const t = [];
                            t.length = a.type.length;
                            for(let s = 0; s < a.type.length; s++)o = void 0 !== e[a.op] ? e[a.op][s] : void 0, void 0 === o && (o = void 0 !== a.value && void 0 !== a.value[s] ? a.value[s] : null), "SID" === a.type[s] && (o = ye(n, o)), t[s] = o;
                            s[a.name] = t;
                        } else o = e[a.op], void 0 === o && (o = void 0 !== a.value ? a.value : null), "SID" === a.type && (o = ye(n, o)), s[a.name] = o;
                    }
                    return s;
                }
                const be = [
                    {
                        name: "version",
                        op: 0,
                        type: "SID"
                    },
                    {
                        name: "notice",
                        op: 1,
                        type: "SID"
                    },
                    {
                        name: "copyright",
                        op: 1200,
                        type: "SID"
                    },
                    {
                        name: "fullName",
                        op: 2,
                        type: "SID"
                    },
                    {
                        name: "familyName",
                        op: 3,
                        type: "SID"
                    },
                    {
                        name: "weight",
                        op: 4,
                        type: "SID"
                    },
                    {
                        name: "isFixedPitch",
                        op: 1201,
                        type: "number",
                        value: 0
                    },
                    {
                        name: "italicAngle",
                        op: 1202,
                        type: "number",
                        value: 0
                    },
                    {
                        name: "underlinePosition",
                        op: 1203,
                        type: "number",
                        value: -100
                    },
                    {
                        name: "underlineThickness",
                        op: 1204,
                        type: "number",
                        value: 50
                    },
                    {
                        name: "paintType",
                        op: 1205,
                        type: "number",
                        value: 0
                    },
                    {
                        name: "charstringType",
                        op: 1206,
                        type: "number",
                        value: 2
                    },
                    {
                        name: "fontMatrix",
                        op: 1207,
                        type: [
                            "real",
                            "real",
                            "real",
                            "real",
                            "real",
                            "real"
                        ],
                        value: [
                            .001,
                            0,
                            0,
                            .001,
                            0,
                            0
                        ]
                    },
                    {
                        name: "uniqueId",
                        op: 13,
                        type: "number"
                    },
                    {
                        name: "fontBBox",
                        op: 5,
                        type: [
                            "number",
                            "number",
                            "number",
                            "number"
                        ],
                        value: [
                            0,
                            0,
                            0,
                            0
                        ]
                    },
                    {
                        name: "strokeWidth",
                        op: 1208,
                        type: "number",
                        value: 0
                    },
                    {
                        name: "xuid",
                        op: 14,
                        type: [],
                        value: null
                    },
                    {
                        name: "charset",
                        op: 15,
                        type: "offset",
                        value: 0
                    },
                    {
                        name: "encoding",
                        op: 16,
                        type: "offset",
                        value: 0
                    },
                    {
                        name: "charStrings",
                        op: 17,
                        type: "offset",
                        value: 0
                    },
                    {
                        name: "private",
                        op: 18,
                        type: [
                            "number",
                            "offset"
                        ],
                        value: [
                            0,
                            0
                        ]
                    },
                    {
                        name: "ros",
                        op: 1230,
                        type: [
                            "SID",
                            "SID",
                            "number"
                        ]
                    },
                    {
                        name: "cidFontVersion",
                        op: 1231,
                        type: "number",
                        value: 0
                    },
                    {
                        name: "cidFontRevision",
                        op: 1232,
                        type: "number",
                        value: 0
                    },
                    {
                        name: "cidFontType",
                        op: 1233,
                        type: "number",
                        value: 0
                    },
                    {
                        name: "cidCount",
                        op: 1234,
                        type: "number",
                        value: 8720
                    },
                    {
                        name: "uidBase",
                        op: 1235,
                        type: "number"
                    },
                    {
                        name: "fdArray",
                        op: 1236,
                        type: "offset"
                    },
                    {
                        name: "fdSelect",
                        op: 1237,
                        type: "offset"
                    },
                    {
                        name: "fontName",
                        op: 1238,
                        type: "SID"
                    }
                ], xe = [
                    {
                        name: "subrs",
                        op: 19,
                        type: "offset",
                        value: 0
                    },
                    {
                        name: "defaultWidthX",
                        op: 20,
                        type: "number",
                        value: 0
                    },
                    {
                        name: "nominalWidthX",
                        op: 21,
                        type: "number",
                        value: 0
                    }
                ];
                function Se(e, t) {
                    return ve(me(e, 0, e.byteLength), be, t);
                }
                function Ue(e, t, n, s) {
                    return ve(me(e, t, n), xe, s);
                }
                function Te(e, t, n, s) {
                    const o = [];
                    for(let r = 0; r < n.length; r += 1){
                        const a = Se(new DataView(new Uint8Array(n[r]).buffer), s);
                        a._subrs = [], a._subrsBias = 0;
                        const i = a.private[0], l = a.private[1];
                        if (0 !== i && 0 !== l) {
                            const n = Ue(e, l + t, i, s);
                            if (a._defaultWidthX = n.defaultWidthX, a._nominalWidthX = n.nominalWidthX, 0 !== n.subrs) {
                                const s = de(e, l + n.subrs + t);
                                a._subrs = s.objects, a._subrsBias = he(a._subrs);
                            }
                            a._privateDict = n;
                        }
                        o.push(a);
                    }
                    return o;
                }
                function Ee(e, t, n) {
                    let s, o, r, a;
                    const i = new u, l = [];
                    let c, p, f, h, d = 0, g = !1, m = !1, y = 0, v = 0;
                    if (e.isCIDFont) {
                        const n = e.tables.cff.topDict._fdSelect[t.index], s = e.tables.cff.topDict._fdArray[n];
                        c = s._subrs, p = s._subrsBias, f = s._defaultWidthX, h = s._nominalWidthX;
                    } else c = e.tables.cff.topDict._subrs, p = e.tables.cff.topDict._subrsBias, f = e.tables.cff.topDict._defaultWidthX, h = e.tables.cff.topDict._nominalWidthX;
                    let b = f;
                    function x(e, t) {
                        m && i.closePath(), i.moveTo(e, t), m = !0;
                    }
                    function S() {
                        let e;
                        e = l.length % 2 != 0, e && !g && (b = l.shift() + h), d += l.length >> 1, l.length = 0, g = !0;
                    }
                    return function n(u) {
                        let f, U, T, E, k, w, O, I, R, L, B, C, D = 0;
                        for(; D < u.length;){
                            let M = u[D];
                            switch(D += 1, M){
                                case 1:
                                case 3:
                                case 18:
                                case 23:
                                    S();
                                    break;
                                case 4:
                                    l.length > 1 && !g && (b = l.shift() + h, g = !0), v += l.pop(), x(y, v);
                                    break;
                                case 5:
                                    for(; l.length > 0;)y += l.shift(), v += l.shift(), i.lineTo(y, v);
                                    break;
                                case 6:
                                    for(; l.length > 0 && (y += l.shift(), i.lineTo(y, v), 0 !== l.length);)v += l.shift(), i.lineTo(y, v);
                                    break;
                                case 7:
                                    for(; l.length > 0 && (v += l.shift(), i.lineTo(y, v), 0 !== l.length);)y += l.shift(), i.lineTo(y, v);
                                    break;
                                case 8:
                                    for(; l.length > 0;)s = y + l.shift(), o = v + l.shift(), r = s + l.shift(), a = o + l.shift(), y = r + l.shift(), v = a + l.shift(), i.curveTo(s, o, r, a, y, v);
                                    break;
                                case 10:
                                    k = l.pop() + p, w = c[k], w && n(w);
                                    break;
                                case 11:
                                    return;
                                case 12:
                                    switch(M = u[D], D += 1, M){
                                        case 35:
                                            s = y + l.shift(), o = v + l.shift(), r = s + l.shift(), a = o + l.shift(), O = r + l.shift(), I = a + l.shift(), R = O + l.shift(), L = I + l.shift(), B = R + l.shift(), C = L + l.shift(), y = B + l.shift(), v = C + l.shift(), l.shift(), i.curveTo(s, o, r, a, O, I), i.curveTo(R, L, B, C, y, v);
                                            break;
                                        case 34:
                                            s = y + l.shift(), o = v, r = s + l.shift(), a = o + l.shift(), O = r + l.shift(), I = a, R = O + l.shift(), L = a, B = R + l.shift(), C = v, y = B + l.shift(), i.curveTo(s, o, r, a, O, I), i.curveTo(R, L, B, C, y, v);
                                            break;
                                        case 36:
                                            s = y + l.shift(), o = v + l.shift(), r = s + l.shift(), a = o + l.shift(), O = r + l.shift(), I = a, R = O + l.shift(), L = a, B = R + l.shift(), C = L + l.shift(), y = B + l.shift(), i.curveTo(s, o, r, a, O, I), i.curveTo(R, L, B, C, y, v);
                                            break;
                                        case 37:
                                            s = y + l.shift(), o = v + l.shift(), r = s + l.shift(), a = o + l.shift(), O = r + l.shift(), I = a + l.shift(), R = O + l.shift(), L = I + l.shift(), B = R + l.shift(), C = L + l.shift(), Math.abs(B - y) > Math.abs(C - v) ? y = B + l.shift() : v = C + l.shift(), i.curveTo(s, o, r, a, O, I), i.curveTo(R, L, B, C, y, v);
                                            break;
                                        default:
                                            console.log("Glyph " + t.index + ": unknown operator 1200" + M), l.length = 0;
                                    }
                                    break;
                                case 14:
                                    l.length > 0 && !g && (b = l.shift() + h, g = !0), m && (i.closePath(), m = !1);
                                    break;
                                case 19:
                                case 20:
                                    S(), D += d + 7 >> 3;
                                    break;
                                case 21:
                                    l.length > 2 && !g && (b = l.shift() + h, g = !0), v += l.pop(), y += l.pop(), x(y, v);
                                    break;
                                case 22:
                                    l.length > 1 && !g && (b = l.shift() + h, g = !0), y += l.pop(), x(y, v);
                                    break;
                                case 24:
                                    for(; l.length > 2;)s = y + l.shift(), o = v + l.shift(), r = s + l.shift(), a = o + l.shift(), y = r + l.shift(), v = a + l.shift(), i.curveTo(s, o, r, a, y, v);
                                    y += l.shift(), v += l.shift(), i.lineTo(y, v);
                                    break;
                                case 25:
                                    for(; l.length > 6;)y += l.shift(), v += l.shift(), i.lineTo(y, v);
                                    s = y + l.shift(), o = v + l.shift(), r = s + l.shift(), a = o + l.shift(), y = r + l.shift(), v = a + l.shift(), i.curveTo(s, o, r, a, y, v);
                                    break;
                                case 26:
                                    for(l.length % 2 && (y += l.shift()); l.length > 0;)s = y, o = v + l.shift(), r = s + l.shift(), a = o + l.shift(), y = r, v = a + l.shift(), i.curveTo(s, o, r, a, y, v);
                                    break;
                                case 27:
                                    for(l.length % 2 && (v += l.shift()); l.length > 0;)s = y + l.shift(), o = v, r = s + l.shift(), a = o + l.shift(), y = r + l.shift(), v = a, i.curveTo(s, o, r, a, y, v);
                                    break;
                                case 28:
                                    f = u[D], U = u[D + 1], l.push((f << 24 | U << 16) >> 16), D += 2;
                                    break;
                                case 29:
                                    k = l.pop() + e.gsubrsBias, w = e.gsubrs[k], w && n(w);
                                    break;
                                case 30:
                                    for(; l.length > 0 && (s = y, o = v + l.shift(), r = s + l.shift(), a = o + l.shift(), y = r + l.shift(), v = a + (1 === l.length ? l.shift() : 0), i.curveTo(s, o, r, a, y, v), 0 !== l.length);)s = y + l.shift(), o = v, r = s + l.shift(), a = o + l.shift(), v = a + l.shift(), y = r + (1 === l.length ? l.shift() : 0), i.curveTo(s, o, r, a, y, v);
                                    break;
                                case 31:
                                    for(; l.length > 0 && (s = y + l.shift(), o = v, r = s + l.shift(), a = o + l.shift(), v = a + l.shift(), y = r + (1 === l.length ? l.shift() : 0), i.curveTo(s, o, r, a, y, v), 0 !== l.length);)s = y, o = v + l.shift(), r = s + l.shift(), a = o + l.shift(), y = r + l.shift(), v = a + (1 === l.length ? l.shift() : 0), i.curveTo(s, o, r, a, y, v);
                                    break;
                                default:
                                    M < 32 ? console.log("Glyph " + t.index + ": unknown operator " + M) : M < 247 ? l.push(M - 139) : M < 251 ? (f = u[D], D += 1, l.push(256 * (M - 247) + f + 108)) : M < 255 ? (f = u[D], D += 1, l.push(256 * -(M - 251) - f - 108)) : (f = u[D], U = u[D + 1], T = u[D + 2], E = u[D + 3], D += 4, l.push((f << 24 | U << 16 | T << 8 | E) / 65536));
                            }
                        }
                    }(n), t.advanceWidth = b, i;
                }
                function ke(e, t) {
                    let n, s = X.indexOf(e);
                    return s >= 0 && (n = s), s = t.indexOf(e), s >= 0 ? n = s + X.length : (n = X.length + t.length, t.push(e)), n;
                }
                function we(e, t, n) {
                    const s = {};
                    for(let o = 0; o < e.length; o += 1){
                        const r = e[o];
                        let a = t[r.name];
                        void 0 === a || fe(a, r.value) || ("SID" === r.type && (a = ke(a, n)), s[r.op] = {
                            name: r.name,
                            type: r.type,
                            value: a
                        });
                    }
                    return s;
                }
                function Oe(e, t) {
                    const n = new M.Record("Top DICT", [
                        {
                            name: "dict",
                            type: "DICT",
                            value: {}
                        }
                    ]);
                    return n.dict = we(be, e, t), n;
                }
                function Ie(e) {
                    const t = new M.Record("Top DICT INDEX", [
                        {
                            name: "topDicts",
                            type: "INDEX",
                            value: []
                        }
                    ]);
                    return t.topDicts = [
                        {
                            name: "topDict_0",
                            type: "TABLE",
                            value: e
                        }
                    ], t;
                }
                function Re(e) {
                    const t = [], n = e.path;
                    t.push({
                        name: "width",
                        type: "NUMBER",
                        value: e.advanceWidth
                    });
                    let s = 0, o = 0;
                    for(let e = 0; e < n.commands.length; e += 1){
                        let r, a, i = n.commands[e];
                        if ("Q" === i.type) {
                            const e = 1 / 3, t = 2 / 3;
                            i = {
                                type: "C",
                                x: i.x,
                                y: i.y,
                                x1: e * s + t * i.x1,
                                y1: e * o + t * i.y1,
                                x2: e * i.x + t * i.x1,
                                y2: e * i.y + t * i.y1
                            };
                        }
                        if ("M" === i.type) r = Math.round(i.x - s), a = Math.round(i.y - o), t.push({
                            name: "dx",
                            type: "NUMBER",
                            value: r
                        }), t.push({
                            name: "dy",
                            type: "NUMBER",
                            value: a
                        }), t.push({
                            name: "rmoveto",
                            type: "OP",
                            value: 21
                        }), s = Math.round(i.x), o = Math.round(i.y);
                        else if ("L" === i.type) r = Math.round(i.x - s), a = Math.round(i.y - o), t.push({
                            name: "dx",
                            type: "NUMBER",
                            value: r
                        }), t.push({
                            name: "dy",
                            type: "NUMBER",
                            value: a
                        }), t.push({
                            name: "rlineto",
                            type: "OP",
                            value: 5
                        }), s = Math.round(i.x), o = Math.round(i.y);
                        else if ("C" === i.type) {
                            const e = Math.round(i.x1 - s), n = Math.round(i.y1 - o), l = Math.round(i.x2 - i.x1), u = Math.round(i.y2 - i.y1);
                            r = Math.round(i.x - i.x2), a = Math.round(i.y - i.y2), t.push({
                                name: "dx1",
                                type: "NUMBER",
                                value: e
                            }), t.push({
                                name: "dy1",
                                type: "NUMBER",
                                value: n
                            }), t.push({
                                name: "dx2",
                                type: "NUMBER",
                                value: l
                            }), t.push({
                                name: "dy2",
                                type: "NUMBER",
                                value: u
                            }), t.push({
                                name: "dx",
                                type: "NUMBER",
                                value: r
                            }), t.push({
                                name: "dy",
                                type: "NUMBER",
                                value: a
                            }), t.push({
                                name: "rrcurveto",
                                type: "OP",
                                value: 8
                            }), s = Math.round(i.x), o = Math.round(i.y);
                        }
                    }
                    return t.push({
                        name: "endchar",
                        type: "OP",
                        value: 14
                    }), t;
                }
                const Le = function(e, t, n) {
                    n.tables.cff = {};
                    const s = function(e, t) {
                        const n = {};
                        return n.formatMajor = z.getCard8(e, t), n.formatMinor = z.getCard8(e, t + 1), n.size = z.getCard8(e, t + 2), n.offsetSize = z.getCard8(e, t + 3), n.startOffset = t, n.endOffset = t + 4, n;
                    }(e, t), o = de(e, s.endOffset, z.bytesToString), r = de(e, o.endOffset), a = de(e, r.endOffset, z.bytesToString), i = de(e, a.endOffset);
                    n.gsubrs = i.objects, n.gsubrsBias = he(n.gsubrs);
                    const l = Te(e, t, r.objects, a.objects);
                    if (1 !== l.length) throw new Error("CFF table has too many fonts in 'FontSet' - count of fonts NameIndex.length = " + l.length);
                    const u = l[0];
                    if (n.tables.cff.topDict = u, u._privateDict && (n.defaultWidthX = u._privateDict.defaultWidthX, n.nominalWidthX = u._privateDict.nominalWidthX), void 0 !== u.ros[0] && void 0 !== u.ros[1] && (n.isCIDFont = !0), n.isCIDFont) {
                        let s = u.fdArray, o = u.fdSelect;
                        if (0 === s || 0 === o) throw new Error("Font is marked as a CID font, but FDArray and/or FDSelect information is missing");
                        s += t;
                        const r = Te(e, t, de(e, s).objects, a.objects);
                        u._fdArray = r, o += t, u._fdSelect = function(e, t, n, s) {
                            const o = [];
                            let r;
                            const a = new z.Parser(e, t), i = a.parseCard8();
                            if (0 === i) for(let e = 0; e < n; e++){
                                if (r = a.parseCard8(), r >= s) throw new Error("CFF table CID Font FDSelect has bad FD index value " + r + " (FD count " + s + ")");
                                o.push(r);
                            }
                            else {
                                if (3 !== i) throw new Error("CFF Table CID Font FDSelect table has unsupported format " + i);
                                {
                                    const e = a.parseCard16();
                                    let t, i = a.parseCard16();
                                    if (0 !== i) throw new Error("CFF Table CID Font FDSelect format 3 range has bad initial GID " + i);
                                    for(let l = 0; l < e; l++){
                                        if (r = a.parseCard8(), t = a.parseCard16(), r >= s) throw new Error("CFF table CID Font FDSelect has bad FD index value " + r + " (FD count " + s + ")");
                                        if (t > n) throw new Error("CFF Table CID Font FDSelect format 3 range has bad GID " + t);
                                        for(; i < t; i++)o.push(r);
                                        i = t;
                                    }
                                    if (t !== n) throw new Error("CFF Table CID Font FDSelect format 3 range has bad final GID " + t);
                                }
                            }
                            return o;
                        }(e, o, n.numGlyphs, r.length);
                    }
                    const c = t + u.private[1], p = Ue(e, c, u.private[0], a.objects);
                    if (n.defaultWidthX = p.defaultWidthX, n.nominalWidthX = p.nominalWidthX, 0 !== p.subrs) {
                        const t = de(e, c + p.subrs);
                        n.subrs = t.objects, n.subrsBias = he(n.subrs);
                    } else n.subrs = [], n.subrsBias = 0;
                    const f = de(e, t + u.charStrings);
                    n.nGlyphs = f.objects.length;
                    const h = function(e, t, n, s) {
                        let o, r;
                        const a = new z.Parser(e, t);
                        n -= 1;
                        const i = [
                            ".notdef"
                        ], l = a.parseCard8();
                        if (0 === l) for(let e = 0; e < n; e += 1)o = a.parseSID(), i.push(ye(s, o));
                        else if (1 === l) for(; i.length <= n;){
                            o = a.parseSID(), r = a.parseCard8();
                            for(let e = 0; e <= r; e += 1)i.push(ye(s, o)), o += 1;
                        }
                        else {
                            if (2 !== l) throw new Error("Unknown charset format " + l);
                            for(; i.length <= n;){
                                o = a.parseSID(), r = a.parseCard16();
                                for(let e = 0; e <= r; e += 1)i.push(ye(s, o)), o += 1;
                            }
                        }
                        return i;
                    }(e, t + u.charset, n.nGlyphs, a.objects);
                    0 === u.encoding ? n.cffEncoding = new K(Y, h) : 1 === u.encoding ? n.cffEncoding = new K(V, h) : n.cffEncoding = function(e, t, n) {
                        let s;
                        const o = {}, r = new z.Parser(e, t), a = r.parseCard8();
                        if (0 === a) {
                            const e = r.parseCard8();
                            for(let t = 0; t < e; t += 1)s = r.parseCard8(), o[s] = t;
                        } else {
                            if (1 !== a) throw new Error("Unknown encoding format " + a);
                            {
                                const e = r.parseCard8();
                                s = 1;
                                for(let t = 0; t < e; t += 1){
                                    const e = r.parseCard8(), t = r.parseCard8();
                                    for(let n = e; n <= e + t; n += 1)o[n] = s, s += 1;
                                }
                            }
                        }
                        return new K(o, n);
                    }(e, t + u.encoding, h), n.encoding = n.encoding || n.cffEncoding, n.glyphs = new pe.GlyphSet(n);
                    for(let e = 0; e < n.nGlyphs; e += 1){
                        const t = f.objects[e];
                        n.glyphs.push(e, pe.cffGlyphLoader(n, e, Ee, t));
                    }
                }, Be = function(e, t) {
                    const n = new M.Table("CFF ", [
                        {
                            name: "header",
                            type: "RECORD"
                        },
                        {
                            name: "nameIndex",
                            type: "RECORD"
                        },
                        {
                            name: "topDictIndex",
                            type: "RECORD"
                        },
                        {
                            name: "stringIndex",
                            type: "RECORD"
                        },
                        {
                            name: "globalSubrIndex",
                            type: "RECORD"
                        },
                        {
                            name: "charsets",
                            type: "RECORD"
                        },
                        {
                            name: "charStringsIndex",
                            type: "RECORD"
                        },
                        {
                            name: "privateDict",
                            type: "RECORD"
                        }
                    ]), s = 1 / t.unitsPerEm, o = {
                        version: t.version,
                        fullName: t.fullName,
                        familyName: t.familyName,
                        weight: t.weightName,
                        fontBBox: t.fontBBox || [
                            0,
                            0,
                            0,
                            0
                        ],
                        fontMatrix: [
                            s,
                            0,
                            0,
                            s,
                            0,
                            0
                        ],
                        charset: 999,
                        encoding: 0,
                        charStrings: 999,
                        private: [
                            0,
                            999
                        ]
                    }, r = [];
                    let a;
                    for(let t = 1; t < e.length; t += 1)a = e.get(t), r.push(a.name);
                    const i = [];
                    n.header = new M.Record("Header", [
                        {
                            name: "major",
                            type: "Card8",
                            value: 1
                        },
                        {
                            name: "minor",
                            type: "Card8",
                            value: 0
                        },
                        {
                            name: "hdrSize",
                            type: "Card8",
                            value: 4
                        },
                        {
                            name: "major",
                            type: "Card8",
                            value: 1
                        }
                    ]), n.nameIndex = function(e) {
                        const t = new M.Record("Name INDEX", [
                            {
                                name: "names",
                                type: "INDEX",
                                value: []
                            }
                        ]);
                        t.names = [];
                        for(let n = 0; n < e.length; n += 1)t.names.push({
                            name: "name_" + n,
                            type: "NAME",
                            value: e[n]
                        });
                        return t;
                    }([
                        t.postScriptName
                    ]);
                    let l = Oe(o, i);
                    n.topDictIndex = Ie(l), n.globalSubrIndex = new M.Record("Global Subr INDEX", [
                        {
                            name: "subrs",
                            type: "INDEX",
                            value: []
                        }
                    ]), n.charsets = function(e, t) {
                        const n = new M.Record("Charsets", [
                            {
                                name: "format",
                                type: "Card8",
                                value: 0
                            }
                        ]);
                        for(let s = 0; s < e.length; s += 1){
                            const o = ke(e[s], t);
                            n.fields.push({
                                name: "glyph_" + s,
                                type: "SID",
                                value: o
                            });
                        }
                        return n;
                    }(r, i), n.charStringsIndex = function(e) {
                        const t = new M.Record("CharStrings INDEX", [
                            {
                                name: "charStrings",
                                type: "INDEX",
                                value: []
                            }
                        ]);
                        for(let n = 0; n < e.length; n += 1){
                            const s = e.get(n), o = Re(s);
                            t.charStrings.push({
                                name: s.name,
                                type: "CHARSTRING",
                                value: o
                            });
                        }
                        return t;
                    }(e), n.privateDict = function(e, t) {
                        const n = new M.Record("Private DICT", [
                            {
                                name: "dict",
                                type: "DICT",
                                value: {}
                            }
                        ]);
                        return n.dict = we(xe, {}, t), n;
                    }(0, i), n.stringIndex = function(e) {
                        const t = new M.Record("String INDEX", [
                            {
                                name: "strings",
                                type: "INDEX",
                                value: []
                            }
                        ]);
                        t.strings = [];
                        for(let n = 0; n < e.length; n += 1)t.strings.push({
                            name: "string_" + n,
                            type: "STRING",
                            value: e[n]
                        });
                        return t;
                    }(i);
                    const u = n.header.sizeOf() + n.nameIndex.sizeOf() + n.topDictIndex.sizeOf() + n.stringIndex.sizeOf() + n.globalSubrIndex.sizeOf();
                    return o.charset = u, o.encoding = 0, o.charStrings = o.charset + n.charsets.sizeOf(), o.private[1] = o.charStrings + n.charStringsIndex.sizeOf(), l = Oe(o, i), n.topDictIndex = Ie(l), n;
                }, Ce = function(e, t) {
                    const n = {}, s = new z.Parser(e, t);
                    return n.version = s.parseVersion(), n.fontRevision = Math.round(1e3 * s.parseFixed()) / 1e3, n.checkSumAdjustment = s.parseULong(), n.magicNumber = s.parseULong(), f.argument(1594834165 === n.magicNumber, "Font header has wrong magic number."), n.flags = s.parseUShort(), n.unitsPerEm = s.parseUShort(), n.created = s.parseLongDateTime(), n.modified = s.parseLongDateTime(), n.xMin = s.parseShort(), n.yMin = s.parseShort(), n.xMax = s.parseShort(), n.yMax = s.parseShort(), n.macStyle = s.parseUShort(), n.lowestRecPPEM = s.parseUShort(), n.fontDirectionHint = s.parseShort(), n.indexToLocFormat = s.parseShort(), n.glyphDataFormat = s.parseShort(), n;
                }, De = function(e) {
                    const t = Math.round((new Date).getTime() / 1e3) + 2082844800;
                    let n = t;
                    return e.createdTimestamp && (n = e.createdTimestamp + 2082844800), new M.Table("head", [
                        {
                            name: "version",
                            type: "FIXED",
                            value: 65536
                        },
                        {
                            name: "fontRevision",
                            type: "FIXED",
                            value: 65536
                        },
                        {
                            name: "checkSumAdjustment",
                            type: "ULONG",
                            value: 0
                        },
                        {
                            name: "magicNumber",
                            type: "ULONG",
                            value: 1594834165
                        },
                        {
                            name: "flags",
                            type: "USHORT",
                            value: 0
                        },
                        {
                            name: "unitsPerEm",
                            type: "USHORT",
                            value: 1e3
                        },
                        {
                            name: "created",
                            type: "LONGDATETIME",
                            value: n
                        },
                        {
                            name: "modified",
                            type: "LONGDATETIME",
                            value: t
                        },
                        {
                            name: "xMin",
                            type: "SHORT",
                            value: 0
                        },
                        {
                            name: "yMin",
                            type: "SHORT",
                            value: 0
                        },
                        {
                            name: "xMax",
                            type: "SHORT",
                            value: 0
                        },
                        {
                            name: "yMax",
                            type: "SHORT",
                            value: 0
                        },
                        {
                            name: "macStyle",
                            type: "USHORT",
                            value: 0
                        },
                        {
                            name: "lowestRecPPEM",
                            type: "USHORT",
                            value: 0
                        },
                        {
                            name: "fontDirectionHint",
                            type: "SHORT",
                            value: 2
                        },
                        {
                            name: "indexToLocFormat",
                            type: "SHORT",
                            value: 0
                        },
                        {
                            name: "glyphDataFormat",
                            type: "SHORT",
                            value: 0
                        }
                    ], e);
                }, Me = function(e, t) {
                    const n = {}, s = new z.Parser(e, t);
                    return n.version = s.parseVersion(), n.ascender = s.parseShort(), n.descender = s.parseShort(), n.lineGap = s.parseShort(), n.advanceWidthMax = s.parseUShort(), n.minLeftSideBearing = s.parseShort(), n.minRightSideBearing = s.parseShort(), n.xMaxExtent = s.parseShort(), n.caretSlopeRise = s.parseShort(), n.caretSlopeRun = s.parseShort(), n.caretOffset = s.parseShort(), s.relativeOffset += 8, n.metricDataFormat = s.parseShort(), n.numberOfHMetrics = s.parseUShort(), n;
                }, Pe = function(e) {
                    return new M.Table("hhea", [
                        {
                            name: "version",
                            type: "FIXED",
                            value: 65536
                        },
                        {
                            name: "ascender",
                            type: "FWORD",
                            value: 0
                        },
                        {
                            name: "descender",
                            type: "FWORD",
                            value: 0
                        },
                        {
                            name: "lineGap",
                            type: "FWORD",
                            value: 0
                        },
                        {
                            name: "advanceWidthMax",
                            type: "UFWORD",
                            value: 0
                        },
                        {
                            name: "minLeftSideBearing",
                            type: "FWORD",
                            value: 0
                        },
                        {
                            name: "minRightSideBearing",
                            type: "FWORD",
                            value: 0
                        },
                        {
                            name: "xMaxExtent",
                            type: "FWORD",
                            value: 0
                        },
                        {
                            name: "caretSlopeRise",
                            type: "SHORT",
                            value: 1
                        },
                        {
                            name: "caretSlopeRun",
                            type: "SHORT",
                            value: 0
                        },
                        {
                            name: "caretOffset",
                            type: "SHORT",
                            value: 0
                        },
                        {
                            name: "reserved1",
                            type: "SHORT",
                            value: 0
                        },
                        {
                            name: "reserved2",
                            type: "SHORT",
                            value: 0
                        },
                        {
                            name: "reserved3",
                            type: "SHORT",
                            value: 0
                        },
                        {
                            name: "reserved4",
                            type: "SHORT",
                            value: 0
                        },
                        {
                            name: "metricDataFormat",
                            type: "SHORT",
                            value: 0
                        },
                        {
                            name: "numberOfHMetrics",
                            type: "USHORT",
                            value: 0
                        }
                    ], e);
                }, Ae = function(e, t, n, s, o) {
                    let r, a;
                    const i = new z.Parser(e, t);
                    for(let e = 0; e < s; e += 1){
                        e < n && (r = i.parseUShort(), a = i.parseShort());
                        const t = o.get(e);
                        t.advanceWidth = r, t.leftSideBearing = a;
                    }
                }, Ge = function(e) {
                    const t = new M.Table("hmtx", []);
                    for(let n = 0; n < e.length; n += 1){
                        const s = e.get(n), o = s.advanceWidth || 0, r = s.leftSideBearing || 0;
                        t.fields.push({
                            name: "advanceWidth_" + n,
                            type: "USHORT",
                            value: o
                        }), t.fields.push({
                            name: "leftSideBearing_" + n,
                            type: "SHORT",
                            value: r
                        });
                    }
                    return t;
                }, Ne = function(e) {
                    const t = new M.Table("ltag", [
                        {
                            name: "version",
                            type: "ULONG",
                            value: 1
                        },
                        {
                            name: "flags",
                            type: "ULONG",
                            value: 0
                        },
                        {
                            name: "numTags",
                            type: "ULONG",
                            value: e.length
                        }
                    ]);
                    let n = "";
                    const s = 12 + 4 * e.length;
                    for(let o = 0; o < e.length; ++o){
                        let r = n.indexOf(e[o]);
                        r < 0 && (r = n.length, n += e[o]), t.fields.push({
                            name: "offset " + o,
                            type: "USHORT",
                            value: s + r
                        }), t.fields.push({
                            name: "length " + o,
                            type: "USHORT",
                            value: e[o].length
                        });
                    }
                    return t.fields.push({
                        name: "stringPool",
                        type: "CHARARRAY",
                        value: n
                    }), t;
                }, Fe = function(e, t) {
                    const n = new z.Parser(e, t), s = n.parseULong();
                    f.argument(1 === s, "Unsupported ltag table version."), n.skip("uLong", 1);
                    const o = n.parseULong(), r = [];
                    for(let s = 0; s < o; s++){
                        let s = "";
                        const o = t + n.parseUShort(), a = n.parseUShort();
                        for(let t = o; t < o + a; ++t)s += String.fromCharCode(e.getInt8(t));
                        r.push(s);
                    }
                    return r;
                }, _e = function(e, t) {
                    const n = {}, s = new z.Parser(e, t);
                    return n.version = s.parseVersion(), n.numGlyphs = s.parseUShort(), 1 === n.version && (n.maxPoints = s.parseUShort(), n.maxContours = s.parseUShort(), n.maxCompositePoints = s.parseUShort(), n.maxCompositeContours = s.parseUShort(), n.maxZones = s.parseUShort(), n.maxTwilightPoints = s.parseUShort(), n.maxStorage = s.parseUShort(), n.maxFunctionDefs = s.parseUShort(), n.maxInstructionDefs = s.parseUShort(), n.maxStackElements = s.parseUShort(), n.maxSizeOfInstructions = s.parseUShort(), n.maxComponentElements = s.parseUShort(), n.maxComponentDepth = s.parseUShort()), n;
                }, He = function(e) {
                    return new M.Table("maxp", [
                        {
                            name: "version",
                            type: "FIXED",
                            value: 20480
                        },
                        {
                            name: "numGlyphs",
                            type: "USHORT",
                            value: e
                        }
                    ]);
                }, ze = [
                    "copyright",
                    "fontFamily",
                    "fontSubfamily",
                    "uniqueID",
                    "fullName",
                    "version",
                    "postScriptName",
                    "trademark",
                    "manufacturer",
                    "designer",
                    "description",
                    "manufacturerURL",
                    "designerURL",
                    "license",
                    "licenseURL",
                    "reserved",
                    "preferredFamily",
                    "preferredSubfamily",
                    "compatibleFullName",
                    "sampleText",
                    "postScriptFindFontName",
                    "wwsFamily",
                    "wwsSubfamily"
                ], We = {
                    0: "en",
                    1: "fr",
                    2: "de",
                    3: "it",
                    4: "nl",
                    5: "sv",
                    6: "es",
                    7: "da",
                    8: "pt",
                    9: "no",
                    10: "he",
                    11: "ja",
                    12: "ar",
                    13: "fi",
                    14: "el",
                    15: "is",
                    16: "mt",
                    17: "tr",
                    18: "hr",
                    19: "zh-Hant",
                    20: "ur",
                    21: "hi",
                    22: "th",
                    23: "ko",
                    24: "lt",
                    25: "pl",
                    26: "hu",
                    27: "es",
                    28: "lv",
                    29: "se",
                    30: "fo",
                    31: "fa",
                    32: "ru",
                    33: "zh",
                    34: "nl-BE",
                    35: "ga",
                    36: "sq",
                    37: "ro",
                    38: "cz",
                    39: "sk",
                    40: "si",
                    41: "yi",
                    42: "sr",
                    43: "mk",
                    44: "bg",
                    45: "uk",
                    46: "be",
                    47: "uz",
                    48: "kk",
                    49: "az-Cyrl",
                    50: "az-Arab",
                    51: "hy",
                    52: "ka",
                    53: "mo",
                    54: "ky",
                    55: "tg",
                    56: "tk",
                    57: "mn-CN",
                    58: "mn",
                    59: "ps",
                    60: "ks",
                    61: "ku",
                    62: "sd",
                    63: "bo",
                    64: "ne",
                    65: "sa",
                    66: "mr",
                    67: "bn",
                    68: "as",
                    69: "gu",
                    70: "pa",
                    71: "or",
                    72: "ml",
                    73: "kn",
                    74: "ta",
                    75: "te",
                    76: "si",
                    77: "my",
                    78: "km",
                    79: "lo",
                    80: "vi",
                    81: "id",
                    82: "tl",
                    83: "ms",
                    84: "ms-Arab",
                    85: "am",
                    86: "ti",
                    87: "om",
                    88: "so",
                    89: "sw",
                    90: "rw",
                    91: "rn",
                    92: "ny",
                    93: "mg",
                    94: "eo",
                    128: "cy",
                    129: "eu",
                    130: "ca",
                    131: "la",
                    132: "qu",
                    133: "gn",
                    134: "ay",
                    135: "tt",
                    136: "ug",
                    137: "dz",
                    138: "jv",
                    139: "su",
                    140: "gl",
                    141: "af",
                    142: "br",
                    143: "iu",
                    144: "gd",
                    145: "gv",
                    146: "ga",
                    147: "to",
                    148: "el-polyton",
                    149: "kl",
                    150: "az",
                    151: "nn"
                }, qe = {
                    0: 0,
                    1: 0,
                    2: 0,
                    3: 0,
                    4: 0,
                    5: 0,
                    6: 0,
                    7: 0,
                    8: 0,
                    9: 0,
                    10: 5,
                    11: 1,
                    12: 4,
                    13: 0,
                    14: 6,
                    15: 0,
                    16: 0,
                    17: 0,
                    18: 0,
                    19: 2,
                    20: 4,
                    21: 9,
                    22: 21,
                    23: 3,
                    24: 29,
                    25: 29,
                    26: 29,
                    27: 29,
                    28: 29,
                    29: 0,
                    30: 0,
                    31: 4,
                    32: 7,
                    33: 25,
                    34: 0,
                    35: 0,
                    36: 0,
                    37: 0,
                    38: 29,
                    39: 29,
                    40: 0,
                    41: 5,
                    42: 7,
                    43: 7,
                    44: 7,
                    45: 7,
                    46: 7,
                    47: 7,
                    48: 7,
                    49: 7,
                    50: 4,
                    51: 24,
                    52: 23,
                    53: 7,
                    54: 7,
                    55: 7,
                    56: 7,
                    57: 27,
                    58: 7,
                    59: 4,
                    60: 4,
                    61: 4,
                    62: 4,
                    63: 26,
                    64: 9,
                    65: 9,
                    66: 9,
                    67: 13,
                    68: 13,
                    69: 11,
                    70: 10,
                    71: 12,
                    72: 17,
                    73: 16,
                    74: 14,
                    75: 15,
                    76: 18,
                    77: 19,
                    78: 20,
                    79: 22,
                    80: 30,
                    81: 0,
                    82: 0,
                    83: 0,
                    84: 4,
                    85: 28,
                    86: 28,
                    87: 28,
                    88: 0,
                    89: 0,
                    90: 0,
                    91: 0,
                    92: 0,
                    93: 0,
                    94: 0,
                    128: 0,
                    129: 0,
                    130: 0,
                    131: 0,
                    132: 0,
                    133: 0,
                    134: 0,
                    135: 7,
                    136: 4,
                    137: 26,
                    138: 0,
                    139: 0,
                    140: 0,
                    141: 0,
                    142: 0,
                    143: 28,
                    144: 0,
                    145: 0,
                    146: 0,
                    147: 0,
                    148: 6,
                    149: 0,
                    150: 0,
                    151: 0
                }, je = {
                    1078: "af",
                    1052: "sq",
                    1156: "gsw",
                    1118: "am",
                    5121: "ar-DZ",
                    15361: "ar-BH",
                    3073: "ar",
                    2049: "ar-IQ",
                    11265: "ar-JO",
                    13313: "ar-KW",
                    12289: "ar-LB",
                    4097: "ar-LY",
                    6145: "ary",
                    8193: "ar-OM",
                    16385: "ar-QA",
                    1025: "ar-SA",
                    10241: "ar-SY",
                    7169: "aeb",
                    14337: "ar-AE",
                    9217: "ar-YE",
                    1067: "hy",
                    1101: "as",
                    2092: "az-Cyrl",
                    1068: "az",
                    1133: "ba",
                    1069: "eu",
                    1059: "be",
                    2117: "bn",
                    1093: "bn-IN",
                    8218: "bs-Cyrl",
                    5146: "bs",
                    1150: "br",
                    1026: "bg",
                    1027: "ca",
                    3076: "zh-HK",
                    5124: "zh-MO",
                    2052: "zh",
                    4100: "zh-SG",
                    1028: "zh-TW",
                    1155: "co",
                    1050: "hr",
                    4122: "hr-BA",
                    1029: "cs",
                    1030: "da",
                    1164: "prs",
                    1125: "dv",
                    2067: "nl-BE",
                    1043: "nl",
                    3081: "en-AU",
                    10249: "en-BZ",
                    4105: "en-CA",
                    9225: "en-029",
                    16393: "en-IN",
                    6153: "en-IE",
                    8201: "en-JM",
                    17417: "en-MY",
                    5129: "en-NZ",
                    13321: "en-PH",
                    18441: "en-SG",
                    7177: "en-ZA",
                    11273: "en-TT",
                    2057: "en-GB",
                    1033: "en",
                    12297: "en-ZW",
                    1061: "et",
                    1080: "fo",
                    1124: "fil",
                    1035: "fi",
                    2060: "fr-BE",
                    3084: "fr-CA",
                    1036: "fr",
                    5132: "fr-LU",
                    6156: "fr-MC",
                    4108: "fr-CH",
                    1122: "fy",
                    1110: "gl",
                    1079: "ka",
                    3079: "de-AT",
                    1031: "de",
                    5127: "de-LI",
                    4103: "de-LU",
                    2055: "de-CH",
                    1032: "el",
                    1135: "kl",
                    1095: "gu",
                    1128: "ha",
                    1037: "he",
                    1081: "hi",
                    1038: "hu",
                    1039: "is",
                    1136: "ig",
                    1057: "id",
                    1117: "iu",
                    2141: "iu-Latn",
                    2108: "ga",
                    1076: "xh",
                    1077: "zu",
                    1040: "it",
                    2064: "it-CH",
                    1041: "ja",
                    1099: "kn",
                    1087: "kk",
                    1107: "km",
                    1158: "quc",
                    1159: "rw",
                    1089: "sw",
                    1111: "kok",
                    1042: "ko",
                    1088: "ky",
                    1108: "lo",
                    1062: "lv",
                    1063: "lt",
                    2094: "dsb",
                    1134: "lb",
                    1071: "mk",
                    2110: "ms-BN",
                    1086: "ms",
                    1100: "ml",
                    1082: "mt",
                    1153: "mi",
                    1146: "arn",
                    1102: "mr",
                    1148: "moh",
                    1104: "mn",
                    2128: "mn-CN",
                    1121: "ne",
                    1044: "nb",
                    2068: "nn",
                    1154: "oc",
                    1096: "or",
                    1123: "ps",
                    1045: "pl",
                    1046: "pt",
                    2070: "pt-PT",
                    1094: "pa",
                    1131: "qu-BO",
                    2155: "qu-EC",
                    3179: "qu",
                    1048: "ro",
                    1047: "rm",
                    1049: "ru",
                    9275: "smn",
                    4155: "smj-NO",
                    5179: "smj",
                    3131: "se-FI",
                    1083: "se",
                    2107: "se-SE",
                    8251: "sms",
                    6203: "sma-NO",
                    7227: "sms",
                    1103: "sa",
                    7194: "sr-Cyrl-BA",
                    3098: "sr",
                    6170: "sr-Latn-BA",
                    2074: "sr-Latn",
                    1132: "nso",
                    1074: "tn",
                    1115: "si",
                    1051: "sk",
                    1060: "sl",
                    11274: "es-AR",
                    16394: "es-BO",
                    13322: "es-CL",
                    9226: "es-CO",
                    5130: "es-CR",
                    7178: "es-DO",
                    12298: "es-EC",
                    17418: "es-SV",
                    4106: "es-GT",
                    18442: "es-HN",
                    2058: "es-MX",
                    19466: "es-NI",
                    6154: "es-PA",
                    15370: "es-PY",
                    10250: "es-PE",
                    20490: "es-PR",
                    3082: "es",
                    1034: "es",
                    21514: "es-US",
                    14346: "es-UY",
                    8202: "es-VE",
                    2077: "sv-FI",
                    1053: "sv",
                    1114: "syr",
                    1064: "tg",
                    2143: "tzm",
                    1097: "ta",
                    1092: "tt",
                    1098: "te",
                    1054: "th",
                    1105: "bo",
                    1055: "tr",
                    1090: "tk",
                    1152: "ug",
                    1058: "uk",
                    1070: "hsb",
                    1056: "ur",
                    2115: "uz-Cyrl",
                    1091: "uz",
                    1066: "vi",
                    1106: "cy",
                    1160: "wo",
                    1157: "sah",
                    1144: "ii",
                    1130: "yo"
                };
                function Xe(e, t, n) {
                    switch(e){
                        case 0:
                            if (65535 === t) return "und";
                            if (n) return n[t];
                            break;
                        case 1:
                            return We[t];
                        case 3:
                            return je[t];
                    }
                }
                const Ye = "utf-16", Ve = {
                    0: "macintosh",
                    1: "x-mac-japanese",
                    2: "x-mac-chinesetrad",
                    3: "x-mac-korean",
                    6: "x-mac-greek",
                    7: "x-mac-cyrillic",
                    9: "x-mac-devanagai",
                    10: "x-mac-gurmukhi",
                    11: "x-mac-gujarati",
                    12: "x-mac-oriya",
                    13: "x-mac-bengali",
                    14: "x-mac-tamil",
                    15: "x-mac-telugu",
                    16: "x-mac-kannada",
                    17: "x-mac-malayalam",
                    18: "x-mac-sinhalese",
                    19: "x-mac-burmese",
                    20: "x-mac-khmer",
                    21: "x-mac-thai",
                    22: "x-mac-lao",
                    23: "x-mac-georgian",
                    24: "x-mac-armenian",
                    25: "x-mac-chinesesimp",
                    26: "x-mac-tibetan",
                    27: "x-mac-mongolian",
                    28: "x-mac-ethiopic",
                    29: "x-mac-ce",
                    30: "x-mac-vietnamese",
                    31: "x-mac-extarabic"
                }, Ze = {
                    15: "x-mac-icelandic",
                    17: "x-mac-turkish",
                    18: "x-mac-croatian",
                    24: "x-mac-ce",
                    25: "x-mac-ce",
                    26: "x-mac-ce",
                    27: "x-mac-ce",
                    28: "x-mac-ce",
                    30: "x-mac-icelandic",
                    37: "x-mac-romanian",
                    38: "x-mac-ce",
                    39: "x-mac-ce",
                    40: "x-mac-ce",
                    143: "x-mac-inuit",
                    146: "x-mac-gaelic"
                };
                function Qe(e, t, n) {
                    switch(e){
                        case 0:
                            return Ye;
                        case 1:
                            return Ze[n] || Ve[t];
                        case 3:
                            if (1 === t || 10 === t) return Ye;
                    }
                }
                function Je(e) {
                    const t = {};
                    for(let n in e)t[e[n]] = parseInt(n);
                    return t;
                }
                function Ke(e, t, n, s, o, r) {
                    return new M.Record("NameRecord", [
                        {
                            name: "platformID",
                            type: "USHORT",
                            value: e
                        },
                        {
                            name: "encodingID",
                            type: "USHORT",
                            value: t
                        },
                        {
                            name: "languageID",
                            type: "USHORT",
                            value: n
                        },
                        {
                            name: "nameID",
                            type: "USHORT",
                            value: s
                        },
                        {
                            name: "length",
                            type: "USHORT",
                            value: o
                        },
                        {
                            name: "offset",
                            type: "USHORT",
                            value: r
                        }
                    ]);
                }
                function $e(e, t) {
                    let n = function(e, t) {
                        const n = e.length, s = t.length - n + 1;
                        e: for(let o = 0; o < s; o++)for(; o < s; o++){
                            for(let s = 0; s < n; s++)if (t[o + s] !== e[s]) continue e;
                            return o;
                        }
                        return -1;
                    }(e, t);
                    if (n < 0) {
                        n = t.length;
                        let s = 0;
                        const o = e.length;
                        for(; s < o; ++s)t.push(e[s]);
                    }
                    return n;
                }
                const et = function(e, t, n) {
                    const s = {}, o = new z.Parser(e, t), r = o.parseUShort(), a = o.parseUShort(), i = o.offset + o.parseUShort();
                    for(let t = 0; t < a; t++){
                        const t = o.parseUShort(), r = o.parseUShort(), a = o.parseUShort(), l = o.parseUShort(), u = ze[l] || l, c = o.parseUShort(), p = o.parseUShort(), f = Xe(t, a, n), h = Qe(t, r, a);
                        if (void 0 !== h && void 0 !== f) {
                            let t;
                            if (t = h === Ye ? d.UTF16(e, i + p, c) : d.MACSTRING(e, i + p, c, h), t) {
                                let e = s[u];
                                void 0 === e && (e = s[u] = {}), e[f] = t;
                            }
                        }
                    }
                    let l = 0;
                    return 1 === r && o.parseUShort(), s;
                }, tt = function(e, t) {
                    let n;
                    const s = [], o = {}, r = Je(ze);
                    for(let t in e){
                        let a = r[t];
                        if (void 0 === a && (a = t), n = parseInt(a), isNaN(n)) throw new Error('Name table entry "' + t + '" does not exist, see nameTableNames for complete list.');
                        o[n] = e[t], s.push(n);
                    }
                    const a = Je(We), i = Je(je), l = [], u = [];
                    for(let e = 0; e < s.length; e++){
                        n = s[e];
                        const r = o[n];
                        for(let e in r){
                            const s = r[e];
                            let o = 1, c = a[e], p = qe[c];
                            const f = Qe(o, p, c);
                            let h = g.MACSTRING(s, f);
                            void 0 === h && (o = 0, c = t.indexOf(e), c < 0 && (c = t.length, t.push(e)), p = 4, h = g.UTF16(s));
                            const d = $e(h, u);
                            l.push(Ke(o, p, c, n, h.length, d));
                            const m = i[e];
                            if (void 0 !== m) {
                                const e = g.UTF16(s), t = $e(e, u);
                                l.push(Ke(3, 1, m, n, e.length, t));
                            }
                        }
                    }
                    l.sort(function(e, t) {
                        return e.platformID - t.platformID || e.encodingID - t.encodingID || e.languageID - t.languageID || e.nameID - t.nameID;
                    });
                    const c = new M.Table("name", [
                        {
                            name: "format",
                            type: "USHORT",
                            value: 0
                        },
                        {
                            name: "count",
                            type: "USHORT",
                            value: l.length
                        },
                        {
                            name: "stringOffset",
                            type: "USHORT",
                            value: 6 + 12 * l.length
                        }
                    ]);
                    for(let e = 0; e < l.length; e++)c.fields.push({
                        name: "record_" + e,
                        type: "RECORD",
                        value: l[e]
                    });
                    return c.fields.push({
                        name: "strings",
                        type: "LITERAL",
                        value: u
                    }), c;
                }, nt = [
                    {
                        begin: 0,
                        end: 127
                    },
                    {
                        begin: 128,
                        end: 255
                    },
                    {
                        begin: 256,
                        end: 383
                    },
                    {
                        begin: 384,
                        end: 591
                    },
                    {
                        begin: 592,
                        end: 687
                    },
                    {
                        begin: 688,
                        end: 767
                    },
                    {
                        begin: 768,
                        end: 879
                    },
                    {
                        begin: 880,
                        end: 1023
                    },
                    {
                        begin: 11392,
                        end: 11519
                    },
                    {
                        begin: 1024,
                        end: 1279
                    },
                    {
                        begin: 1328,
                        end: 1423
                    },
                    {
                        begin: 1424,
                        end: 1535
                    },
                    {
                        begin: 42240,
                        end: 42559
                    },
                    {
                        begin: 1536,
                        end: 1791
                    },
                    {
                        begin: 1984,
                        end: 2047
                    },
                    {
                        begin: 2304,
                        end: 2431
                    },
                    {
                        begin: 2432,
                        end: 2559
                    },
                    {
                        begin: 2560,
                        end: 2687
                    },
                    {
                        begin: 2688,
                        end: 2815
                    },
                    {
                        begin: 2816,
                        end: 2943
                    },
                    {
                        begin: 2944,
                        end: 3071
                    },
                    {
                        begin: 3072,
                        end: 3199
                    },
                    {
                        begin: 3200,
                        end: 3327
                    },
                    {
                        begin: 3328,
                        end: 3455
                    },
                    {
                        begin: 3584,
                        end: 3711
                    },
                    {
                        begin: 3712,
                        end: 3839
                    },
                    {
                        begin: 4256,
                        end: 4351
                    },
                    {
                        begin: 6912,
                        end: 7039
                    },
                    {
                        begin: 4352,
                        end: 4607
                    },
                    {
                        begin: 7680,
                        end: 7935
                    },
                    {
                        begin: 7936,
                        end: 8191
                    },
                    {
                        begin: 8192,
                        end: 8303
                    },
                    {
                        begin: 8304,
                        end: 8351
                    },
                    {
                        begin: 8352,
                        end: 8399
                    },
                    {
                        begin: 8400,
                        end: 8447
                    },
                    {
                        begin: 8448,
                        end: 8527
                    },
                    {
                        begin: 8528,
                        end: 8591
                    },
                    {
                        begin: 8592,
                        end: 8703
                    },
                    {
                        begin: 8704,
                        end: 8959
                    },
                    {
                        begin: 8960,
                        end: 9215
                    },
                    {
                        begin: 9216,
                        end: 9279
                    },
                    {
                        begin: 9280,
                        end: 9311
                    },
                    {
                        begin: 9312,
                        end: 9471
                    },
                    {
                        begin: 9472,
                        end: 9599
                    },
                    {
                        begin: 9600,
                        end: 9631
                    },
                    {
                        begin: 9632,
                        end: 9727
                    },
                    {
                        begin: 9728,
                        end: 9983
                    },
                    {
                        begin: 9984,
                        end: 10175
                    },
                    {
                        begin: 12288,
                        end: 12351
                    },
                    {
                        begin: 12352,
                        end: 12447
                    },
                    {
                        begin: 12448,
                        end: 12543
                    },
                    {
                        begin: 12544,
                        end: 12591
                    },
                    {
                        begin: 12592,
                        end: 12687
                    },
                    {
                        begin: 43072,
                        end: 43135
                    },
                    {
                        begin: 12800,
                        end: 13055
                    },
                    {
                        begin: 13056,
                        end: 13311
                    },
                    {
                        begin: 44032,
                        end: 55215
                    },
                    {
                        begin: 55296,
                        end: 57343
                    },
                    {
                        begin: 67840,
                        end: 67871
                    },
                    {
                        begin: 19968,
                        end: 40959
                    },
                    {
                        begin: 57344,
                        end: 63743
                    },
                    {
                        begin: 12736,
                        end: 12783
                    },
                    {
                        begin: 64256,
                        end: 64335
                    },
                    {
                        begin: 64336,
                        end: 65023
                    },
                    {
                        begin: 65056,
                        end: 65071
                    },
                    {
                        begin: 65040,
                        end: 65055
                    },
                    {
                        begin: 65104,
                        end: 65135
                    },
                    {
                        begin: 65136,
                        end: 65279
                    },
                    {
                        begin: 65280,
                        end: 65519
                    },
                    {
                        begin: 65520,
                        end: 65535
                    },
                    {
                        begin: 3840,
                        end: 4095
                    },
                    {
                        begin: 1792,
                        end: 1871
                    },
                    {
                        begin: 1920,
                        end: 1983
                    },
                    {
                        begin: 3456,
                        end: 3583
                    },
                    {
                        begin: 4096,
                        end: 4255
                    },
                    {
                        begin: 4608,
                        end: 4991
                    },
                    {
                        begin: 5024,
                        end: 5119
                    },
                    {
                        begin: 5120,
                        end: 5759
                    },
                    {
                        begin: 5760,
                        end: 5791
                    },
                    {
                        begin: 5792,
                        end: 5887
                    },
                    {
                        begin: 6016,
                        end: 6143
                    },
                    {
                        begin: 6144,
                        end: 6319
                    },
                    {
                        begin: 10240,
                        end: 10495
                    },
                    {
                        begin: 40960,
                        end: 42127
                    },
                    {
                        begin: 5888,
                        end: 5919
                    },
                    {
                        begin: 66304,
                        end: 66351
                    },
                    {
                        begin: 66352,
                        end: 66383
                    },
                    {
                        begin: 66560,
                        end: 66639
                    },
                    {
                        begin: 118784,
                        end: 119039
                    },
                    {
                        begin: 119808,
                        end: 120831
                    },
                    {
                        begin: 1044480,
                        end: 1048573
                    },
                    {
                        begin: 65024,
                        end: 65039
                    },
                    {
                        begin: 917504,
                        end: 917631
                    },
                    {
                        begin: 6400,
                        end: 6479
                    },
                    {
                        begin: 6480,
                        end: 6527
                    },
                    {
                        begin: 6528,
                        end: 6623
                    },
                    {
                        begin: 6656,
                        end: 6687
                    },
                    {
                        begin: 11264,
                        end: 11359
                    },
                    {
                        begin: 11568,
                        end: 11647
                    },
                    {
                        begin: 19904,
                        end: 19967
                    },
                    {
                        begin: 43008,
                        end: 43055
                    },
                    {
                        begin: 65536,
                        end: 65663
                    },
                    {
                        begin: 65856,
                        end: 65935
                    },
                    {
                        begin: 66432,
                        end: 66463
                    },
                    {
                        begin: 66464,
                        end: 66527
                    },
                    {
                        begin: 66640,
                        end: 66687
                    },
                    {
                        begin: 66688,
                        end: 66735
                    },
                    {
                        begin: 67584,
                        end: 67647
                    },
                    {
                        begin: 68096,
                        end: 68191
                    },
                    {
                        begin: 119552,
                        end: 119647
                    },
                    {
                        begin: 73728,
                        end: 74751
                    },
                    {
                        begin: 119648,
                        end: 119679
                    },
                    {
                        begin: 7040,
                        end: 7103
                    },
                    {
                        begin: 7168,
                        end: 7247
                    },
                    {
                        begin: 7248,
                        end: 7295
                    },
                    {
                        begin: 43136,
                        end: 43231
                    },
                    {
                        begin: 43264,
                        end: 43311
                    },
                    {
                        begin: 43312,
                        end: 43359
                    },
                    {
                        begin: 43520,
                        end: 43615
                    },
                    {
                        begin: 65936,
                        end: 65999
                    },
                    {
                        begin: 66e3,
                        end: 66047
                    },
                    {
                        begin: 66208,
                        end: 66271
                    },
                    {
                        begin: 127024,
                        end: 127135
                    }
                ], st = function(e, t) {
                    const n = {}, s = new z.Parser(e, t);
                    n.version = s.parseUShort(), n.xAvgCharWidth = s.parseShort(), n.usWeightClass = s.parseUShort(), n.usWidthClass = s.parseUShort(), n.fsType = s.parseUShort(), n.ySubscriptXSize = s.parseShort(), n.ySubscriptYSize = s.parseShort(), n.ySubscriptXOffset = s.parseShort(), n.ySubscriptYOffset = s.parseShort(), n.ySuperscriptXSize = s.parseShort(), n.ySuperscriptYSize = s.parseShort(), n.ySuperscriptXOffset = s.parseShort(), n.ySuperscriptYOffset = s.parseShort(), n.yStrikeoutSize = s.parseShort(), n.yStrikeoutPosition = s.parseShort(), n.sFamilyClass = s.parseShort(), n.panose = [];
                    for(let e = 0; e < 10; e++)n.panose[e] = s.parseByte();
                    return n.ulUnicodeRange1 = s.parseULong(), n.ulUnicodeRange2 = s.parseULong(), n.ulUnicodeRange3 = s.parseULong(), n.ulUnicodeRange4 = s.parseULong(), n.achVendID = String.fromCharCode(s.parseByte(), s.parseByte(), s.parseByte(), s.parseByte()), n.fsSelection = s.parseUShort(), n.usFirstCharIndex = s.parseUShort(), n.usLastCharIndex = s.parseUShort(), n.sTypoAscender = s.parseShort(), n.sTypoDescender = s.parseShort(), n.sTypoLineGap = s.parseShort(), n.usWinAscent = s.parseUShort(), n.usWinDescent = s.parseUShort(), n.version >= 1 && (n.ulCodePageRange1 = s.parseULong(), n.ulCodePageRange2 = s.parseULong()), n.version >= 2 && (n.sxHeight = s.parseShort(), n.sCapHeight = s.parseShort(), n.usDefaultChar = s.parseUShort(), n.usBreakChar = s.parseUShort(), n.usMaxContent = s.parseUShort()), n;
                }, ot = function(e) {
                    return new M.Table("OS/2", [
                        {
                            name: "version",
                            type: "USHORT",
                            value: 3
                        },
                        {
                            name: "xAvgCharWidth",
                            type: "SHORT",
                            value: 0
                        },
                        {
                            name: "usWeightClass",
                            type: "USHORT",
                            value: 0
                        },
                        {
                            name: "usWidthClass",
                            type: "USHORT",
                            value: 0
                        },
                        {
                            name: "fsType",
                            type: "USHORT",
                            value: 0
                        },
                        {
                            name: "ySubscriptXSize",
                            type: "SHORT",
                            value: 650
                        },
                        {
                            name: "ySubscriptYSize",
                            type: "SHORT",
                            value: 699
                        },
                        {
                            name: "ySubscriptXOffset",
                            type: "SHORT",
                            value: 0
                        },
                        {
                            name: "ySubscriptYOffset",
                            type: "SHORT",
                            value: 140
                        },
                        {
                            name: "ySuperscriptXSize",
                            type: "SHORT",
                            value: 650
                        },
                        {
                            name: "ySuperscriptYSize",
                            type: "SHORT",
                            value: 699
                        },
                        {
                            name: "ySuperscriptXOffset",
                            type: "SHORT",
                            value: 0
                        },
                        {
                            name: "ySuperscriptYOffset",
                            type: "SHORT",
                            value: 479
                        },
                        {
                            name: "yStrikeoutSize",
                            type: "SHORT",
                            value: 49
                        },
                        {
                            name: "yStrikeoutPosition",
                            type: "SHORT",
                            value: 258
                        },
                        {
                            name: "sFamilyClass",
                            type: "SHORT",
                            value: 0
                        },
                        {
                            name: "bFamilyType",
                            type: "BYTE",
                            value: 0
                        },
                        {
                            name: "bSerifStyle",
                            type: "BYTE",
                            value: 0
                        },
                        {
                            name: "bWeight",
                            type: "BYTE",
                            value: 0
                        },
                        {
                            name: "bProportion",
                            type: "BYTE",
                            value: 0
                        },
                        {
                            name: "bContrast",
                            type: "BYTE",
                            value: 0
                        },
                        {
                            name: "bStrokeVariation",
                            type: "BYTE",
                            value: 0
                        },
                        {
                            name: "bArmStyle",
                            type: "BYTE",
                            value: 0
                        },
                        {
                            name: "bLetterform",
                            type: "BYTE",
                            value: 0
                        },
                        {
                            name: "bMidline",
                            type: "BYTE",
                            value: 0
                        },
                        {
                            name: "bXHeight",
                            type: "BYTE",
                            value: 0
                        },
                        {
                            name: "ulUnicodeRange1",
                            type: "ULONG",
                            value: 0
                        },
                        {
                            name: "ulUnicodeRange2",
                            type: "ULONG",
                            value: 0
                        },
                        {
                            name: "ulUnicodeRange3",
                            type: "ULONG",
                            value: 0
                        },
                        {
                            name: "ulUnicodeRange4",
                            type: "ULONG",
                            value: 0
                        },
                        {
                            name: "achVendID",
                            type: "CHARARRAY",
                            value: "XXXX"
                        },
                        {
                            name: "fsSelection",
                            type: "USHORT",
                            value: 0
                        },
                        {
                            name: "usFirstCharIndex",
                            type: "USHORT",
                            value: 0
                        },
                        {
                            name: "usLastCharIndex",
                            type: "USHORT",
                            value: 0
                        },
                        {
                            name: "sTypoAscender",
                            type: "SHORT",
                            value: 0
                        },
                        {
                            name: "sTypoDescender",
                            type: "SHORT",
                            value: 0
                        },
                        {
                            name: "sTypoLineGap",
                            type: "SHORT",
                            value: 0
                        },
                        {
                            name: "usWinAscent",
                            type: "USHORT",
                            value: 0
                        },
                        {
                            name: "usWinDescent",
                            type: "USHORT",
                            value: 0
                        },
                        {
                            name: "ulCodePageRange1",
                            type: "ULONG",
                            value: 0
                        },
                        {
                            name: "ulCodePageRange2",
                            type: "ULONG",
                            value: 0
                        },
                        {
                            name: "sxHeight",
                            type: "SHORT",
                            value: 0
                        },
                        {
                            name: "sCapHeight",
                            type: "SHORT",
                            value: 0
                        },
                        {
                            name: "usDefaultChar",
                            type: "USHORT",
                            value: 0
                        },
                        {
                            name: "usBreakChar",
                            type: "USHORT",
                            value: 0
                        },
                        {
                            name: "usMaxContext",
                            type: "USHORT",
                            value: 0
                        }
                    ], e);
                }, rt = function(e) {
                    for(let t = 0; t < nt.length; t += 1){
                        const n = nt[t];
                        if (e >= n.begin && e < n.end) return t;
                    }
                    return -1;
                }, at = function(e, t) {
                    const n = {}, s = new z.Parser(e, t);
                    switch(n.version = s.parseVersion(), n.italicAngle = s.parseFixed(), n.underlinePosition = s.parseShort(), n.underlineThickness = s.parseShort(), n.isFixedPitch = s.parseULong(), n.minMemType42 = s.parseULong(), n.maxMemType42 = s.parseULong(), n.minMemType1 = s.parseULong(), n.maxMemType1 = s.parseULong(), n.version){
                        case 1:
                            n.names = Z.slice();
                            break;
                        case 2:
                            n.numberOfGlyphs = s.parseUShort(), n.glyphNameIndex = new Array(n.numberOfGlyphs);
                            for(let e = 0; e < n.numberOfGlyphs; e++)n.glyphNameIndex[e] = s.parseUShort();
                            n.names = [];
                            for(let e = 0; e < n.numberOfGlyphs; e++)if (n.glyphNameIndex[e] >= Z.length) {
                                const e = s.parseChar();
                                n.names.push(s.parseString(e));
                            }
                            break;
                        case 2.5:
                            n.numberOfGlyphs = s.parseUShort(), n.offset = new Array(n.numberOfGlyphs);
                            for(let e = 0; e < n.numberOfGlyphs; e++)n.offset[e] = s.parseChar();
                    }
                    return n;
                }, it = function() {
                    return new M.Table("post", [
                        {
                            name: "version",
                            type: "FIXED",
                            value: 196608
                        },
                        {
                            name: "italicAngle",
                            type: "FIXED",
                            value: 0
                        },
                        {
                            name: "underlinePosition",
                            type: "FWORD",
                            value: 0
                        },
                        {
                            name: "underlineThickness",
                            type: "FWORD",
                            value: 0
                        },
                        {
                            name: "isFixedPitch",
                            type: "ULONG",
                            value: 0
                        },
                        {
                            name: "minMemType42",
                            type: "ULONG",
                            value: 0
                        },
                        {
                            name: "maxMemType42",
                            type: "ULONG",
                            value: 0
                        },
                        {
                            name: "minMemType1",
                            type: "ULONG",
                            value: 0
                        },
                        {
                            name: "maxMemType1",
                            type: "ULONG",
                            value: 0
                        }
                    ]);
                }, lt = new Array(9);
                lt[1] = function() {
                    const e = this.offset + this.relativeOffset, t = this.parseUShort();
                    return 1 === t ? {
                        substFormat: 1,
                        coverage: this.parsePointer(_.coverage),
                        deltaGlyphId: this.parseUShort()
                    } : 2 === t ? {
                        substFormat: 2,
                        coverage: this.parsePointer(_.coverage),
                        substitute: this.parseOffset16List()
                    } : void f.assert(!1, "0x" + e.toString(16) + ": lookup type 1 format must be 1 or 2.");
                }, lt[2] = function() {
                    const e = this.parseUShort();
                    return f.argument(1 === e, "GSUB Multiple Substitution Subtable identifier-format must be 1"), {
                        substFormat: e,
                        coverage: this.parsePointer(_.coverage),
                        sequences: this.parseListOfLists()
                    };
                }, lt[3] = function() {
                    const e = this.parseUShort();
                    return f.argument(1 === e, "GSUB Alternate Substitution Subtable identifier-format must be 1"), {
                        substFormat: e,
                        coverage: this.parsePointer(_.coverage),
                        alternateSets: this.parseListOfLists()
                    };
                }, lt[4] = function() {
                    const e = this.parseUShort();
                    return f.argument(1 === e, "GSUB ligature table identifier-format must be 1"), {
                        substFormat: e,
                        coverage: this.parsePointer(_.coverage),
                        ligatureSets: this.parseListOfLists(function() {
                            return {
                                ligGlyph: this.parseUShort(),
                                components: this.parseUShortList(this.parseUShort() - 1)
                            };
                        })
                    };
                };
                const ut = {
                    sequenceIndex: _.uShort,
                    lookupListIndex: _.uShort
                };
                lt[5] = function() {
                    const e = this.offset + this.relativeOffset, t = this.parseUShort();
                    if (1 === t) return {
                        substFormat: t,
                        coverage: this.parsePointer(_.coverage),
                        ruleSets: this.parseListOfLists(function() {
                            const e = this.parseUShort(), t = this.parseUShort();
                            return {
                                input: this.parseUShortList(e - 1),
                                lookupRecords: this.parseRecordList(t, ut)
                            };
                        })
                    };
                    if (2 === t) return {
                        substFormat: t,
                        coverage: this.parsePointer(_.coverage),
                        classDef: this.parsePointer(_.classDef),
                        classSets: this.parseListOfLists(function() {
                            const e = this.parseUShort(), t = this.parseUShort();
                            return {
                                classes: this.parseUShortList(e - 1),
                                lookupRecords: this.parseRecordList(t, ut)
                            };
                        })
                    };
                    if (3 === t) {
                        const e = this.parseUShort(), n = this.parseUShort();
                        return {
                            substFormat: t,
                            coverages: this.parseList(e, _.pointer(_.coverage)),
                            lookupRecords: this.parseRecordList(n, ut)
                        };
                    }
                    f.assert(!1, "0x" + e.toString(16) + ": lookup type 5 format must be 1, 2 or 3.");
                }, lt[6] = function() {
                    const e = this.offset + this.relativeOffset, t = this.parseUShort();
                    return 1 === t ? {
                        substFormat: 1,
                        coverage: this.parsePointer(_.coverage),
                        chainRuleSets: this.parseListOfLists(function() {
                            return {
                                backtrack: this.parseUShortList(),
                                input: this.parseUShortList(this.parseShort() - 1),
                                lookahead: this.parseUShortList(),
                                lookupRecords: this.parseRecordList(ut)
                            };
                        })
                    } : 2 === t ? {
                        substFormat: 2,
                        coverage: this.parsePointer(_.coverage),
                        backtrackClassDef: this.parsePointer(_.classDef),
                        inputClassDef: this.parsePointer(_.classDef),
                        lookaheadClassDef: this.parsePointer(_.classDef),
                        chainClassSet: this.parseListOfLists(function() {
                            return {
                                backtrack: this.parseUShortList(),
                                input: this.parseUShortList(this.parseShort() - 1),
                                lookahead: this.parseUShortList(),
                                lookupRecords: this.parseRecordList(ut)
                            };
                        })
                    } : 3 === t ? {
                        substFormat: 3,
                        backtrackCoverage: this.parseList(_.pointer(_.coverage)),
                        inputCoverage: this.parseList(_.pointer(_.coverage)),
                        lookaheadCoverage: this.parseList(_.pointer(_.coverage)),
                        lookupRecords: this.parseRecordList(ut)
                    } : void f.assert(!1, "0x" + e.toString(16) + ": lookup type 6 format must be 1, 2 or 3.");
                }, lt[7] = function() {
                    const e = this.parseUShort();
                    f.argument(1 === e, "GSUB Extension Substitution subtable identifier-format must be 1");
                    const t = this.parseUShort(), n = new _(this.data, this.offset + this.parseULong());
                    return {
                        substFormat: 1,
                        lookupType: t,
                        extension: lt[t].call(n)
                    };
                }, lt[8] = function() {
                    const e = this.parseUShort();
                    return f.argument(1 === e, "GSUB Reverse Chaining Contextual Single Substitution Subtable identifier-format must be 1"), {
                        substFormat: e,
                        coverage: this.parsePointer(_.coverage),
                        backtrackCoverage: this.parseList(_.pointer(_.coverage)),
                        lookaheadCoverage: this.parseList(_.pointer(_.coverage)),
                        substitutes: this.parseUShortList()
                    };
                };
                const ct = new Array(9);
                ct[1] = function(e) {
                    return 1 === e.substFormat ? new M.Table("substitutionTable", [
                        {
                            name: "substFormat",
                            type: "USHORT",
                            value: 1
                        },
                        {
                            name: "coverage",
                            type: "TABLE",
                            value: new M.Coverage(e.coverage)
                        },
                        {
                            name: "deltaGlyphID",
                            type: "USHORT",
                            value: e.deltaGlyphId
                        }
                    ]) : new M.Table("substitutionTable", [
                        {
                            name: "substFormat",
                            type: "USHORT",
                            value: 2
                        },
                        {
                            name: "coverage",
                            type: "TABLE",
                            value: new M.Coverage(e.coverage)
                        }
                    ].concat(M.ushortList("substitute", e.substitute)));
                }, ct[3] = function(e) {
                    return f.assert(1 === e.substFormat, "Lookup type 3 substFormat must be 1."), new M.Table("substitutionTable", [
                        {
                            name: "substFormat",
                            type: "USHORT",
                            value: 1
                        },
                        {
                            name: "coverage",
                            type: "TABLE",
                            value: new M.Coverage(e.coverage)
                        }
                    ].concat(M.tableList("altSet", e.alternateSets, function(e) {
                        return new M.Table("alternateSetTable", M.ushortList("alternate", e));
                    })));
                }, ct[4] = function(e) {
                    return f.assert(1 === e.substFormat, "Lookup type 4 substFormat must be 1."), new M.Table("substitutionTable", [
                        {
                            name: "substFormat",
                            type: "USHORT",
                            value: 1
                        },
                        {
                            name: "coverage",
                            type: "TABLE",
                            value: new M.Coverage(e.coverage)
                        }
                    ].concat(M.tableList("ligSet", e.ligatureSets, function(e) {
                        return new M.Table("ligatureSetTable", M.tableList("ligature", e, function(e) {
                            return new M.Table("ligatureTable", [
                                {
                                    name: "ligGlyph",
                                    type: "USHORT",
                                    value: e.ligGlyph
                                }
                            ].concat(M.ushortList("component", e.components, e.components.length + 1)));
                        }));
                    })));
                };
                const pt = function(e, t) {
                    const n = new _(e, t = t || 0), s = n.parseVersion(1);
                    return f.argument(1 === s || 1.1 === s, "Unsupported GSUB table version."), 1 === s ? {
                        version: s,
                        scripts: n.parseScriptList(),
                        features: n.parseFeatureList(),
                        lookups: n.parseLookupList(lt)
                    } : {
                        version: s,
                        scripts: n.parseScriptList(),
                        features: n.parseFeatureList(),
                        lookups: n.parseLookupList(lt),
                        variations: n.parseFeatureVariationsList()
                    };
                }, ft = function(e) {
                    return new M.Table("GSUB", [
                        {
                            name: "version",
                            type: "ULONG",
                            value: 65536
                        },
                        {
                            name: "scripts",
                            type: "TABLE",
                            value: new M.ScriptList(e.scripts)
                        },
                        {
                            name: "features",
                            type: "TABLE",
                            value: new M.FeatureList(e.features)
                        },
                        {
                            name: "lookups",
                            type: "TABLE",
                            value: new M.LookupList(e.lookups, ct)
                        }
                    ]);
                }, ht = function(e, t) {
                    const n = new z.Parser(e, t), s = n.parseULong();
                    f.argument(1 === s, "Unsupported META table version."), n.parseULong(), n.parseULong();
                    const o = n.parseULong(), r = {};
                    for(let s = 0; s < o; s++){
                        const s = n.parseTag(), o = n.parseULong(), a = n.parseULong(), i = d.UTF8(e, t + o, a);
                        r[s] = i;
                    }
                    return r;
                }, dt = function(e) {
                    const t = Object.keys(e).length;
                    let n = "";
                    const s = 16 + 12 * t, o = new M.Table("meta", [
                        {
                            name: "version",
                            type: "ULONG",
                            value: 1
                        },
                        {
                            name: "flags",
                            type: "ULONG",
                            value: 0
                        },
                        {
                            name: "offset",
                            type: "ULONG",
                            value: s
                        },
                        {
                            name: "numTags",
                            type: "ULONG",
                            value: t
                        }
                    ]);
                    for(let t in e){
                        const r = n.length;
                        n += e[t], o.fields.push({
                            name: "tag " + t,
                            type: "TAG",
                            value: t
                        }), o.fields.push({
                            name: "offset " + t,
                            type: "ULONG",
                            value: s + r
                        }), o.fields.push({
                            name: "length " + t,
                            type: "ULONG",
                            value: e[t].length
                        });
                    }
                    return o.fields.push({
                        name: "stringPool",
                        type: "CHARARRAY",
                        value: n
                    }), o;
                };
                function gt(e) {
                    return Math.log(e) / Math.log(2) | 0;
                }
                function mt(e) {
                    for(; e.length % 4 != 0;)e.push(0);
                    let t = 0;
                    for(let n = 0; n < e.length; n += 4)t += (e[n] << 24) + (e[n + 1] << 16) + (e[n + 2] << 8) + e[n + 3];
                    return t %= Math.pow(2, 32), t;
                }
                function yt(e, t, n, s) {
                    return new M.Record("Table Record", [
                        {
                            name: "tag",
                            type: "TAG",
                            value: void 0 !== e ? e : ""
                        },
                        {
                            name: "checkSum",
                            type: "ULONG",
                            value: void 0 !== t ? t : 0
                        },
                        {
                            name: "offset",
                            type: "ULONG",
                            value: void 0 !== n ? n : 0
                        },
                        {
                            name: "length",
                            type: "ULONG",
                            value: void 0 !== s ? s : 0
                        }
                    ]);
                }
                function vt(e) {
                    const t = new M.Table("sfnt", [
                        {
                            name: "version",
                            type: "TAG",
                            value: "OTTO"
                        },
                        {
                            name: "numTables",
                            type: "USHORT",
                            value: 0
                        },
                        {
                            name: "searchRange",
                            type: "USHORT",
                            value: 0
                        },
                        {
                            name: "entrySelector",
                            type: "USHORT",
                            value: 0
                        },
                        {
                            name: "rangeShift",
                            type: "USHORT",
                            value: 0
                        }
                    ]);
                    t.tables = e, t.numTables = e.length;
                    const n = Math.pow(2, gt(t.numTables));
                    t.searchRange = 16 * n, t.entrySelector = gt(n), t.rangeShift = 16 * t.numTables - t.searchRange;
                    const s = [], o = [];
                    let r = t.sizeOf() + yt().sizeOf() * t.numTables;
                    for(; r % 4 != 0;)r += 1, o.push({
                        name: "padding",
                        type: "BYTE",
                        value: 0
                    });
                    for(let t = 0; t < e.length; t += 1){
                        const n = e[t];
                        f.argument(4 === n.tableName.length, "Table name" + n.tableName + " is invalid.");
                        const a = n.sizeOf(), i = yt(n.tableName, mt(n.encode()), r, a);
                        for(s.push({
                            name: i.tag + " Table Record",
                            type: "RECORD",
                            value: i
                        }), o.push({
                            name: n.tableName + " table",
                            type: "RECORD",
                            value: n
                        }), r += a, f.argument(!isNaN(r), "Something went wrong calculating the offset."); r % 4 != 0;)r += 1, o.push({
                            name: "padding",
                            type: "BYTE",
                            value: 0
                        });
                    }
                    return s.sort(function(e, t) {
                        return e.value.tag > t.value.tag ? 1 : -1;
                    }), t.fields = t.fields.concat(s), t.fields = t.fields.concat(o), t;
                }
                function bt(e, t, n) {
                    for(let n = 0; n < t.length; n += 1){
                        const s = e.charToGlyphIndex(t[n]);
                        if (s > 0) return e.glyphs.get(s).getMetrics();
                    }
                    return n;
                }
                function xt(e) {
                    let t = 0;
                    for(let n = 0; n < e.length; n += 1)t += e[n];
                    return t / e.length;
                }
                const St = function(e) {
                    const t = [], n = [], s = [], o = [], r = [], a = [], i = [];
                    let l, u = 0, c = 0, p = 0, f = 0, h = 0;
                    for(let d = 0; d < e.glyphs.length; d += 1){
                        const g = e.glyphs.get(d), m = 0 | g.unicode;
                        if (isNaN(g.advanceWidth)) throw new Error("Glyph " + g.name + " (" + d + "): advanceWidth is not a number.");
                        (l > m || void 0 === l) && m > 0 && (l = m), u < m && (u = m);
                        const y = rt(m);
                        if (y < 32) c |= 1 << y;
                        else if (y < 64) p |= 1 << y - 32;
                        else if (y < 96) f |= 1 << y - 64;
                        else {
                            if (!(y < 123)) throw new Error("Unicode ranges bits > 123 are reserved for internal usage");
                            h |= 1 << y - 96;
                        }
                        if (".notdef" === g.name) continue;
                        const v = g.getMetrics();
                        t.push(v.xMin), n.push(v.yMin), s.push(v.xMax), o.push(v.yMax), a.push(v.leftSideBearing), i.push(v.rightSideBearing), r.push(g.advanceWidth);
                    }
                    const d = {
                        xMin: Math.min.apply(null, t),
                        yMin: Math.min.apply(null, n),
                        xMax: Math.max.apply(null, s),
                        yMax: Math.max.apply(null, o),
                        advanceWidthMax: Math.max.apply(null, r),
                        advanceWidthAvg: xt(r),
                        minLeftSideBearing: Math.min.apply(null, a),
                        maxLeftSideBearing: Math.max.apply(null, a),
                        minRightSideBearing: Math.min.apply(null, i)
                    };
                    d.ascender = e.ascender, d.descender = e.descender;
                    const g = De({
                        flags: 3,
                        unitsPerEm: e.unitsPerEm,
                        xMin: d.xMin,
                        yMin: d.yMin,
                        xMax: d.xMax,
                        yMax: d.yMax,
                        lowestRecPPEM: 3,
                        createdTimestamp: e.createdTimestamp
                    }), m = Pe({
                        ascender: d.ascender,
                        descender: d.descender,
                        advanceWidthMax: d.advanceWidthMax,
                        minLeftSideBearing: d.minLeftSideBearing,
                        minRightSideBearing: d.minRightSideBearing,
                        xMaxExtent: d.maxLeftSideBearing + (d.xMax - d.xMin),
                        numberOfHMetrics: e.glyphs.length
                    }), y = He(e.glyphs.length), v = ot({
                        xAvgCharWidth: Math.round(d.advanceWidthAvg),
                        usWeightClass: e.tables.os2.usWeightClass,
                        usWidthClass: e.tables.os2.usWidthClass,
                        usFirstCharIndex: l,
                        usLastCharIndex: u,
                        ulUnicodeRange1: c,
                        ulUnicodeRange2: p,
                        ulUnicodeRange3: f,
                        ulUnicodeRange4: h,
                        fsSelection: e.tables.os2.fsSelection,
                        sTypoAscender: d.ascender,
                        sTypoDescender: d.descender,
                        sTypoLineGap: 0,
                        usWinAscent: d.yMax,
                        usWinDescent: Math.abs(d.yMin),
                        ulCodePageRange1: 1,
                        sxHeight: bt(e, "xyvw", {
                            yMax: Math.round(d.ascender / 2)
                        }).yMax,
                        sCapHeight: bt(e, "HIKLEFJMNTZBDPRAGOQSUVWXY", d).yMax,
                        usDefaultChar: e.hasChar(" ") ? 32 : 0,
                        usBreakChar: e.hasChar(" ") ? 32 : 0
                    }), b = Ge(e.glyphs), x = j(e.glyphs), S = e.getEnglishName("fontFamily"), U = e.getEnglishName("fontSubfamily"), T = S + " " + U;
                    let E = e.getEnglishName("postScriptName");
                    E || (E = S.replace(/\s/g, "") + "-" + U);
                    const k = {};
                    for(let t in e.names)k[t] = e.names[t];
                    k.uniqueID || (k.uniqueID = {
                        en: e.getEnglishName("manufacturer") + ":" + T
                    }), k.postScriptName || (k.postScriptName = {
                        en: E
                    }), k.preferredFamily || (k.preferredFamily = e.names.fontFamily), k.preferredSubfamily || (k.preferredSubfamily = e.names.fontSubfamily);
                    const w = [], O = tt(k, w), I = w.length > 0 ? Ne(w) : void 0, R = it(), L = Be(e.glyphs, {
                        version: e.getEnglishName("version"),
                        fullName: T,
                        familyName: S,
                        weightName: U,
                        postScriptName: E,
                        unitsPerEm: e.unitsPerEm,
                        fontBBox: [
                            0,
                            d.yMin,
                            d.ascender,
                            d.advanceWidthMax
                        ]
                    }), B = e.metas && Object.keys(e.metas).length > 0 ? dt(e.metas) : void 0, C = [
                        g,
                        m,
                        y,
                        v,
                        O,
                        x,
                        R,
                        L,
                        b
                    ];
                    I && C.push(I), e.tables.gsub && C.push(ft(e.tables.gsub)), B && C.push(B);
                    const D = vt(C), M = mt(D.encode()), P = D.fields;
                    let A = !1;
                    for(let e = 0; e < P.length; e += 1)if ("head table" === P[e].name) {
                        P[e].value.checkSumAdjustment = 2981146554 - M, A = !0;
                        break;
                    }
                    if (!A) throw new Error("Could not find head table with checkSum to adjust.");
                    return D;
                };
                function Ut(e, t) {
                    let n = 0, s = e.length - 1;
                    for(; n <= s;){
                        const o = n + s >>> 1, r = e[o].tag;
                        if (r === t) return o;
                        r < t ? n = o + 1 : s = o - 1;
                    }
                    return -n - 1;
                }
                function Tt(e, t) {
                    let n = 0, s = e.length - 1;
                    for(; n <= s;){
                        const o = n + s >>> 1, r = e[o];
                        if (r === t) return o;
                        r < t ? n = o + 1 : s = o - 1;
                    }
                    return -n - 1;
                }
                function Et(e, t) {
                    let n, s = 0, o = e.length - 1;
                    for(; s <= o;){
                        const r = s + o >>> 1;
                        n = e[r];
                        const a = n.start;
                        if (a === t) return n;
                        a < t ? s = r + 1 : o = r - 1;
                    }
                    if (s > 0) return n = e[s - 1], t > n.end ? 0 : n;
                }
                function kt(e, t) {
                    this.font = e, this.tableName = t;
                }
                kt.prototype = {
                    searchTag: Ut,
                    binSearch: Tt,
                    getTable: function(e) {
                        let t = this.font.tables[this.tableName];
                        return !t && e && (t = this.font.tables[this.tableName] = this.createDefaultTable()), t;
                    },
                    getScriptNames: function() {
                        let e = this.getTable();
                        return e ? e.scripts.map(function(e) {
                            return e.tag;
                        }) : [];
                    },
                    getDefaultScriptName: function() {
                        let e = this.getTable();
                        if (!e) return;
                        let t = !1;
                        for(let n = 0; n < e.scripts.length; n++){
                            const s = e.scripts[n].tag;
                            if ("DFLT" === s) return s;
                            "latn" === s && (t = !0);
                        }
                        return t ? "latn" : void 0;
                    },
                    getScriptTable: function(e, t) {
                        const n = this.getTable(t);
                        if (n) {
                            e = e || "DFLT";
                            const s = n.scripts, o = Ut(n.scripts, e);
                            if (o >= 0) return s[o].script;
                            if (t) {
                                const t = {
                                    tag: e,
                                    script: {
                                        defaultLangSys: {
                                            reserved: 0,
                                            reqFeatureIndex: 65535,
                                            featureIndexes: []
                                        },
                                        langSysRecords: []
                                    }
                                };
                                return s.splice(-1 - o, 0, t), t.script;
                            }
                        }
                    },
                    getLangSysTable: function(e, t, n) {
                        const s = this.getScriptTable(e, n);
                        if (s) {
                            if (!t || "dflt" === t || "DFLT" === t) return s.defaultLangSys;
                            const e = Ut(s.langSysRecords, t);
                            if (e >= 0) return s.langSysRecords[e].langSys;
                            if (n) {
                                const n = {
                                    tag: t,
                                    langSys: {
                                        reserved: 0,
                                        reqFeatureIndex: 65535,
                                        featureIndexes: []
                                    }
                                };
                                return s.langSysRecords.splice(-1 - e, 0, n), n.langSys;
                            }
                        }
                    },
                    getFeatureTable: function(e, t, n, s) {
                        const o = this.getLangSysTable(e, t, s);
                        if (o) {
                            let e;
                            const t = o.featureIndexes, r = this.font.tables[this.tableName].features;
                            for(let s = 0; s < t.length; s++)if (e = r[t[s]], e.tag === n) return e.feature;
                            if (s) {
                                const s = r.length;
                                return f.assert(0 === s || n >= r[s - 1].tag, "Features must be added in alphabetical order."), e = {
                                    tag: n,
                                    feature: {
                                        params: 0,
                                        lookupListIndexes: []
                                    }
                                }, r.push(e), t.push(s), e.feature;
                            }
                        }
                    },
                    getLookupTables: function(e, t, n, s, o) {
                        const r = this.getFeatureTable(e, t, n, o), a = [];
                        if (r) {
                            let e;
                            const t = r.lookupListIndexes, n = this.font.tables[this.tableName].lookups;
                            for(let o = 0; o < t.length; o++)e = n[t[o]], e.lookupType === s && a.push(e);
                            if (0 === a.length && o) {
                                e = {
                                    lookupType: s,
                                    lookupFlag: 0,
                                    subtables: [],
                                    markFilteringSet: void 0
                                };
                                const o = n.length;
                                return n.push(e), t.push(o), [
                                    e
                                ];
                            }
                        }
                        return a;
                    },
                    getGlyphClass: function(e, t) {
                        switch(e.format){
                            case 1:
                                return e.startGlyph <= t && t < e.startGlyph + e.classes.length ? e.classes[t - e.startGlyph] : 0;
                            case 2:
                                const n = Et(e.ranges, t);
                                return n ? n.classId : 0;
                        }
                    },
                    getCoverageIndex: function(e, t) {
                        switch(e.format){
                            case 1:
                                const n = Tt(e.glyphs, t);
                                return n >= 0 ? n : -1;
                            case 2:
                                const s = Et(e.ranges, t);
                                return s ? s.index + t - s.start : -1;
                        }
                    },
                    expandCoverage: function(e) {
                        if (1 === e.format) return e.glyphs;
                        {
                            const t = [], n = e.ranges;
                            for(let e = 0; e < n.length; e++){
                                const s = n[e], o = s.start, r = s.end;
                                for(let e = o; e <= r; e++)t.push(e);
                            }
                            return t;
                        }
                    }
                };
                const wt = kt;
                function Ot(e) {
                    wt.call(this, e, "gpos");
                }
                Ot.prototype = wt.prototype, Ot.prototype.getKerningValue = function(e, t, n) {
                    for(let s = 0; s < e.length; s++){
                        const o = e[s].subtables;
                        for(let e = 0; e < o.length; e++){
                            const s = o[e], r = this.getCoverageIndex(s.coverage, t);
                            if (!(r < 0)) switch(s.posFormat){
                                case 1:
                                    let e1 = s.pairSets[r];
                                    for(let t = 0; t < e1.length; t++){
                                        let s = e1[t];
                                        if (s.secondGlyph === n) return s.value1 && s.value1.xAdvance || 0;
                                    }
                                    break;
                                case 2:
                                    const o1 = this.getGlyphClass(s.classDef1, t), a = this.getGlyphClass(s.classDef2, n), i = s.classRecords[o1][a];
                                    return i.value1 && i.value1.xAdvance || 0;
                            }
                        }
                    }
                    return 0;
                }, Ot.prototype.getKerningTables = function(e, t) {
                    if (this.font.tables.gpos) return this.getLookupTables(e, t, "kern", 2);
                };
                const It = Ot;
                function Rt(e) {
                    wt.call(this, e, "gsub");
                }
                function Lt(e, t) {
                    const n = e.length;
                    if (n !== t.length) return !1;
                    for(let s = 0; s < n; s++)if (e[s] !== t[s]) return !1;
                    return !0;
                }
                function Bt(e, t, n) {
                    const s = e.subtables;
                    for(let e = 0; e < s.length; e++){
                        const n = s[e];
                        if (n.substFormat === t) return n;
                    }
                    if (n) return s.push(n), n;
                }
                Rt.prototype = wt.prototype, Rt.prototype.createDefaultTable = function() {
                    return {
                        version: 1,
                        scripts: [
                            {
                                tag: "DFLT",
                                script: {
                                    defaultLangSys: {
                                        reserved: 0,
                                        reqFeatureIndex: 65535,
                                        featureIndexes: []
                                    },
                                    langSysRecords: []
                                }
                            }
                        ],
                        features: [],
                        lookups: []
                    };
                }, Rt.prototype.getSingle = function(e, t, n) {
                    const s = [], o = this.getLookupTables(t, n, e, 1);
                    for(let e = 0; e < o.length; e++){
                        const t = o[e].subtables;
                        for(let e = 0; e < t.length; e++){
                            const n = t[e], o = this.expandCoverage(n.coverage);
                            let r;
                            if (1 === n.substFormat) {
                                const e = n.deltaGlyphId;
                                for(r = 0; r < o.length; r++){
                                    const t = o[r];
                                    s.push({
                                        sub: t,
                                        by: t + e
                                    });
                                }
                            } else {
                                const e = n.substitute;
                                for(r = 0; r < o.length; r++)s.push({
                                    sub: o[r],
                                    by: e[r]
                                });
                            }
                        }
                    }
                    return s;
                }, Rt.prototype.getAlternates = function(e, t, n) {
                    const s = [], o = this.getLookupTables(t, n, e, 3);
                    for(let e = 0; e < o.length; e++){
                        const t = o[e].subtables;
                        for(let e = 0; e < t.length; e++){
                            const n = t[e], o = this.expandCoverage(n.coverage), r = n.alternateSets;
                            for(let e = 0; e < o.length; e++)s.push({
                                sub: o[e],
                                by: r[e]
                            });
                        }
                    }
                    return s;
                }, Rt.prototype.getLigatures = function(e, t, n) {
                    const s = [], o = this.getLookupTables(t, n, e, 4);
                    for(let e = 0; e < o.length; e++){
                        const t = o[e].subtables;
                        for(let e = 0; e < t.length; e++){
                            const n = t[e], o = this.expandCoverage(n.coverage), r = n.ligatureSets;
                            for(let e = 0; e < o.length; e++){
                                const t = o[e], n = r[e];
                                for(let e = 0; e < n.length; e++){
                                    const o = n[e];
                                    s.push({
                                        sub: [
                                            t
                                        ].concat(o.components),
                                        by: o.ligGlyph
                                    });
                                }
                            }
                        }
                    }
                    return s;
                }, Rt.prototype.addSingle = function(e, t, n, s) {
                    const o = Bt(this.getLookupTables(n, s, e, 1, !0)[0], 2, {
                        substFormat: 2,
                        coverage: {
                            format: 1,
                            glyphs: []
                        },
                        substitute: []
                    });
                    f.assert(1 === o.coverage.format, "Ligature: unable to modify coverage table format " + o.coverage.format);
                    const r = t.sub;
                    let a = this.binSearch(o.coverage.glyphs, r);
                    a < 0 && (a = -1 - a, o.coverage.glyphs.splice(a, 0, r), o.substitute.splice(a, 0, 0)), o.substitute[a] = t.by;
                }, Rt.prototype.addAlternate = function(e, t, n, s) {
                    const o = Bt(this.getLookupTables(n, s, e, 3, !0)[0], 1, {
                        substFormat: 1,
                        coverage: {
                            format: 1,
                            glyphs: []
                        },
                        alternateSets: []
                    });
                    f.assert(1 === o.coverage.format, "Ligature: unable to modify coverage table format " + o.coverage.format);
                    const r = t.sub;
                    let a = this.binSearch(o.coverage.glyphs, r);
                    a < 0 && (a = -1 - a, o.coverage.glyphs.splice(a, 0, r), o.alternateSets.splice(a, 0, 0)), o.alternateSets[a] = t.by;
                }, Rt.prototype.addLigature = function(e, t, n, s) {
                    const o = this.getLookupTables(n, s, e, 4, !0)[0];
                    let r = o.subtables[0];
                    r || (r = {
                        substFormat: 1,
                        coverage: {
                            format: 1,
                            glyphs: []
                        },
                        ligatureSets: []
                    }, o.subtables[0] = r), f.assert(1 === r.coverage.format, "Ligature: unable to modify coverage table format " + r.coverage.format);
                    const a = t.sub[0], i = t.sub.slice(1), l = {
                        ligGlyph: t.by,
                        components: i
                    };
                    let u = this.binSearch(r.coverage.glyphs, a);
                    if (u >= 0) {
                        const e = r.ligatureSets[u];
                        for(let t = 0; t < e.length; t++)if (Lt(e[t].components, i)) return;
                        e.push(l);
                    } else u = -1 - u, r.coverage.glyphs.splice(u, 0, a), r.ligatureSets.splice(u, 0, [
                        l
                    ]);
                }, Rt.prototype.getFeature = function(e, t, n) {
                    if (/ss\d\d/.test(e)) return this.getSingle(e, t, n);
                    switch(e){
                        case "aalt":
                        case "salt":
                            return this.getSingle(e, t, n).concat(this.getAlternates(e, t, n));
                        case "dlig":
                        case "liga":
                        case "rlig":
                            return this.getLigatures(e, t, n);
                    }
                }, Rt.prototype.add = function(e, t, n, s) {
                    if (/ss\d\d/.test(e)) return this.addSingle(e, t, n, s);
                    switch(e){
                        case "aalt":
                        case "salt":
                            return "number" == typeof t.by ? this.addSingle(e, t, n, s) : this.addAlternate(e, t, n, s);
                        case "dlig":
                        case "liga":
                        case "rlig":
                            return this.addLigature(e, t, n, s);
                    }
                };
                const Ct = Rt;
                function Dt(e) {
                    const t = new ArrayBuffer(e.length), n = new Uint8Array(t);
                    for(let t = 0; t < e.length; ++t)n[t] = e[t];
                    return t;
                }
                function Mt(e, t) {
                    if (!e) throw t;
                }
                let Pt, At, Gt, Nt;
                function Ft(e) {
                    this.font = e, this._fpgmState = this._prepState = void 0, this._errorState = 0;
                }
                function _t(e) {
                    return e;
                }
                function Ht(e) {
                    return Math.sign(e) * Math.round(Math.abs(e));
                }
                function zt(e) {
                    return Math.sign(e) * Math.round(Math.abs(2 * e)) / 2;
                }
                function Wt(e) {
                    return Math.sign(e) * (Math.round(Math.abs(e) + .5) - .5);
                }
                function qt(e) {
                    return Math.sign(e) * Math.ceil(Math.abs(e));
                }
                function jt(e) {
                    return Math.sign(e) * Math.floor(Math.abs(e));
                }
                const Xt = function(e) {
                    const t = this.srPeriod;
                    let n = this.srPhase, s = 1;
                    return e < 0 && (e = -e, s = -1), e += this.srThreshold - n, e = Math.trunc(e / t) * t, (e += n) < 0 ? n * s : e * s;
                }, Yt = {
                    x: 1,
                    y: 0,
                    axis: "x",
                    distance: function(e, t, n, s) {
                        return (n ? e.xo : e.x) - (s ? t.xo : t.x);
                    },
                    interpolate: function(e, t, n, s) {
                        let o, r, a, i, l, u, c;
                        if (!s || s === this) return o = e.xo - t.xo, r = e.xo - n.xo, l = t.x - t.xo, u = n.x - n.xo, a = Math.abs(o), i = Math.abs(r), c = a + i, 0 === c ? void (e.x = e.xo + (l + u) / 2) : void (e.x = e.xo + (l * i + u * a) / c);
                        o = s.distance(e, t, !0, !0), r = s.distance(e, n, !0, !0), l = s.distance(t, t, !1, !0), u = s.distance(n, n, !1, !0), a = Math.abs(o), i = Math.abs(r), c = a + i, 0 !== c ? Yt.setRelative(e, e, (l * i + u * a) / c, s, !0) : Yt.setRelative(e, e, (l + u) / 2, s, !0);
                    },
                    normalSlope: Number.NEGATIVE_INFINITY,
                    setRelative: function(e, t, n, s, o) {
                        if (!s || s === this) return void (e.x = (o ? t.xo : t.x) + n);
                        const r = o ? t.xo : t.x, a = o ? t.yo : t.y, i = r + n * s.x, l = a + n * s.y;
                        e.x = i + (e.y - l) / s.normalSlope;
                    },
                    slope: 0,
                    touch: function(e) {
                        e.xTouched = !0;
                    },
                    touched: function(e) {
                        return e.xTouched;
                    },
                    untouch: function(e) {
                        e.xTouched = !1;
                    }
                }, Vt = {
                    x: 0,
                    y: 1,
                    axis: "y",
                    distance: function(e, t, n, s) {
                        return (n ? e.yo : e.y) - (s ? t.yo : t.y);
                    },
                    interpolate: function(e, t, n, s) {
                        let o, r, a, i, l, u, c;
                        if (!s || s === this) return o = e.yo - t.yo, r = e.yo - n.yo, l = t.y - t.yo, u = n.y - n.yo, a = Math.abs(o), i = Math.abs(r), c = a + i, 0 === c ? void (e.y = e.yo + (l + u) / 2) : void (e.y = e.yo + (l * i + u * a) / c);
                        o = s.distance(e, t, !0, !0), r = s.distance(e, n, !0, !0), l = s.distance(t, t, !1, !0), u = s.distance(n, n, !1, !0), a = Math.abs(o), i = Math.abs(r), c = a + i, 0 !== c ? Vt.setRelative(e, e, (l * i + u * a) / c, s, !0) : Vt.setRelative(e, e, (l + u) / 2, s, !0);
                    },
                    normalSlope: 0,
                    setRelative: function(e, t, n, s, o) {
                        if (!s || s === this) return void (e.y = (o ? t.yo : t.y) + n);
                        const r = o ? t.xo : t.x, a = o ? t.yo : t.y, i = r + n * s.x, l = a + n * s.y;
                        e.y = l + s.normalSlope * (e.x - i);
                    },
                    slope: Number.POSITIVE_INFINITY,
                    touch: function(e) {
                        e.yTouched = !0;
                    },
                    touched: function(e) {
                        return e.yTouched;
                    },
                    untouch: function(e) {
                        e.yTouched = !1;
                    }
                };
                function Zt(e, t) {
                    this.x = e, this.y = t, this.axis = void 0, this.slope = t / e, this.normalSlope = -e / t, Object.freeze(this);
                }
                function Qt(e, t) {
                    const n = Math.sqrt(e * e + t * t);
                    return t /= n, 1 == (e /= n) && 0 === t ? Yt : 0 === e && 1 === t ? Vt : new Zt(e, t);
                }
                function Jt(e, t, n, s) {
                    this.x = this.xo = Math.round(64 * e) / 64, this.y = this.yo = Math.round(64 * t) / 64, this.lastPointOfContour = n, this.onCurve = s, this.prevPointOnContour = void 0, this.nextPointOnContour = void 0, this.xTouched = !1, this.yTouched = !1, Object.preventExtensions(this);
                }
                Object.freeze(Yt), Object.freeze(Vt), Zt.prototype.distance = function(e, t, n, s) {
                    return this.x * Yt.distance(e, t, n, s) + this.y * Vt.distance(e, t, n, s);
                }, Zt.prototype.interpolate = function(e, t, n, s) {
                    let o, r, a, i, l, u, c;
                    a = s.distance(e, t, !0, !0), i = s.distance(e, n, !0, !0), o = s.distance(t, t, !1, !0), r = s.distance(n, n, !1, !0), l = Math.abs(a), u = Math.abs(i), c = l + u, 0 !== c ? this.setRelative(e, e, (o * u + r * l) / c, s, !0) : this.setRelative(e, e, (o + r) / 2, s, !0);
                }, Zt.prototype.setRelative = function(e, t, n, s, o) {
                    s = s || this;
                    const r = o ? t.xo : t.x, a = o ? t.yo : t.y, i = r + n * s.x, l = a + n * s.y, u = s.normalSlope, c = this.slope, p = e.x, f = e.y;
                    e.x = (c * p - u * i + l - f) / (c - u), e.y = c * (e.x - p) + f;
                }, Zt.prototype.touch = function(e) {
                    e.xTouched = !0, e.yTouched = !0;
                }, Jt.prototype.nextTouched = function(e) {
                    let t = this.nextPointOnContour;
                    for(; !e.touched(t) && t !== this;)t = t.nextPointOnContour;
                    return t;
                }, Jt.prototype.prevTouched = function(e) {
                    let t = this.prevPointOnContour;
                    for(; !e.touched(t) && t !== this;)t = t.prevPointOnContour;
                    return t;
                };
                const Kt = Object.freeze(new Jt(0, 0)), $t = {
                    cvCutIn: 17 / 16,
                    deltaBase: 9,
                    deltaShift: .125,
                    loop: 1,
                    minDis: 1,
                    autoFlip: !0
                };
                function en(e, t) {
                    switch(this.env = e, this.stack = [], this.prog = t, e){
                        case "glyf":
                            this.zp0 = this.zp1 = this.zp2 = 1, this.rp0 = this.rp1 = this.rp2 = 0;
                        case "prep":
                            this.fv = this.pv = this.dpv = Yt, this.round = Ht;
                    }
                }
                function tn(e) {
                    const t = e.tZone = new Array(e.gZone.length);
                    for(let e = 0; e < t.length; e++)t[e] = new Jt(0, 0);
                }
                function nn(e, t) {
                    const n = e.prog;
                    let s, o = e.ip, r = 1;
                    do {
                        if (s = n[++o], 88 === s) r++;
                        else if (89 === s) r--;
                        else if (64 === s) o += n[o + 1] + 1;
                        else if (65 === s) o += 2 * n[o + 1] + 1;
                        else if (s >= 176 && s <= 183) o += s - 176 + 1;
                        else if (s >= 184 && s <= 191) o += 2 * (s - 184 + 1);
                        else if (t && 1 === r && 27 === s) break;
                    }while (r > 0);
                    e.ip = o;
                }
                function sn(e, t) {
                    exports.DEBUG && console.log(t.step, "SVTCA[" + e.axis + "]"), t.fv = t.pv = t.dpv = e;
                }
                function on(e, t) {
                    exports.DEBUG && console.log(t.step, "SPVTCA[" + e.axis + "]"), t.pv = t.dpv = e;
                }
                function rn(e, t) {
                    exports.DEBUG && console.log(t.step, "SFVTCA[" + e.axis + "]"), t.fv = e;
                }
                function an(e, t) {
                    const n = t.stack, s = n.pop(), o = n.pop(), r = t.z2[s], a = t.z1[o];
                    let i, l;
                    exports.DEBUG && console.log("SPVTL[" + e + "]", s, o), e ? (i = r.y - a.y, l = a.x - r.x) : (i = a.x - r.x, l = a.y - r.y), t.pv = t.dpv = Qt(i, l);
                }
                function ln(e, t) {
                    const n = t.stack, s = n.pop(), o = n.pop(), r = t.z2[s], a = t.z1[o];
                    let i, l;
                    exports.DEBUG && console.log("SFVTL[" + e + "]", s, o), e ? (i = r.y - a.y, l = a.x - r.x) : (i = a.x - r.x, l = a.y - r.y), t.fv = Qt(i, l);
                }
                function un(e) {
                    exports.DEBUG && console.log(e.step, "POP[]"), e.stack.pop();
                }
                function cn(e, t) {
                    const n = t.stack.pop(), s = t.z0[n], o = t.fv, r = t.pv;
                    exports.DEBUG && console.log(t.step, "MDAP[" + e + "]", n);
                    let a = r.distance(s, Kt);
                    e && (a = t.round(a)), o.setRelative(s, Kt, a, r), o.touch(s), t.rp0 = t.rp1 = n;
                }
                function pn(e, t) {
                    const n = t.z2, s = n.length - 2;
                    let o, r, a;
                    exports.DEBUG && console.log(t.step, "IUP[" + e.axis + "]");
                    for(let t = 0; t < s; t++)o = n[t], e.touched(o) || (r = o.prevTouched(e), r !== o && (a = o.nextTouched(e), r === a && e.setRelative(o, o, e.distance(r, r, !1, !0), e, !0), e.interpolate(o, r, a, e)));
                }
                function fn(e, t) {
                    const n = t.stack, s = e ? t.rp1 : t.rp2, o = (e ? t.z0 : t.z1)[s], r = t.fv, a = t.pv;
                    let i = t.loop;
                    const l = t.z2;
                    for(; i--;){
                        const s = n.pop(), u = l[s], c = a.distance(o, o, !1, !0);
                        r.setRelative(u, u, c, a), r.touch(u), exports.DEBUG && console.log(t.step, (t.loop > 1 ? "loop " + (t.loop - i) + ": " : "") + "SHP[" + (e ? "rp1" : "rp2") + "]", s);
                    }
                    t.loop = 1;
                }
                function hn(e, t) {
                    const n = t.stack, s = e ? t.rp1 : t.rp2, o = (e ? t.z0 : t.z1)[s], r = t.fv, a = t.pv, i = n.pop(), l = t.z2[t.contours[i]];
                    let u = l;
                    exports.DEBUG && console.log(t.step, "SHC[" + e + "]", i);
                    const c = a.distance(o, o, !1, !0);
                    do u !== o && r.setRelative(u, u, c, a), u = u.nextPointOnContour;
                    while (u !== l);
                }
                function dn(e, t) {
                    const n = t.stack, s = e ? t.rp1 : t.rp2, o = (e ? t.z0 : t.z1)[s], r = t.fv, a = t.pv, i = n.pop();
                    let l, u;
                    switch(exports.DEBUG && console.log(t.step, "SHZ[" + e + "]", i), i){
                        case 0:
                            l = t.tZone;
                            break;
                        case 1:
                            l = t.gZone;
                            break;
                        default:
                            throw new Error("Invalid zone");
                    }
                    const c = a.distance(o, o, !1, !0), p = l.length - 2;
                    for(let e = 0; e < p; e++)u = l[e], r.setRelative(u, u, c, a);
                }
                function gn(e, t) {
                    const n = t.stack, s = n.pop() / 64, o = n.pop(), r = t.z1[o], a = t.z0[t.rp0], i = t.fv, l = t.pv;
                    i.setRelative(r, a, s, l), i.touch(r), exports.DEBUG && console.log(t.step, "MSIRP[" + e + "]", s, o), t.rp1 = t.rp0, t.rp2 = o, e && (t.rp0 = o);
                }
                function mn(e, t) {
                    const n = t.stack, s = n.pop(), o = n.pop(), r = t.z0[o], a = t.fv, i = t.pv;
                    let l = t.cvt[s];
                    exports.DEBUG && console.log(t.step, "MIAP[" + e + "]", s, "(", l, ")", o);
                    let u = i.distance(r, Kt);
                    e && (Math.abs(u - l) < t.cvCutIn && (u = l), u = t.round(u)), a.setRelative(r, Kt, u, i), 0 === t.zp0 && (r.xo = r.x, r.yo = r.y), a.touch(r), t.rp0 = t.rp1 = o;
                }
                function yn(e, t) {
                    const n = t.stack, s = n.pop(), o = t.z2[s];
                    exports.DEBUG && console.log(t.step, "GC[" + e + "]", s), n.push(64 * t.dpv.distance(o, Kt, e, !1));
                }
                function vn(e, t) {
                    const n = t.stack, s = n.pop(), o = n.pop(), r = t.z1[s], a = t.z0[o], i = t.dpv.distance(a, r, e, e);
                    exports.DEBUG && console.log(t.step, "MD[" + e + "]", s, o, "->", i), t.stack.push(Math.round(64 * i));
                }
                function bn(e, t) {
                    const n = t.stack, s = n.pop(), o = t.fv, r = t.pv, a = t.ppem, i = t.deltaBase + 16 * (e - 1), l = t.deltaShift, u = t.z0;
                    exports.DEBUG && console.log(t.step, "DELTAP[" + e + "]", s, n);
                    for(let e = 0; e < s; e++){
                        const e = n.pop(), s = n.pop();
                        if (i + ((240 & s) >> 4) !== a) continue;
                        let c = (15 & s) - 8;
                        c >= 0 && c++, exports.DEBUG && console.log(t.step, "DELTAPFIX", e, "by", c * l);
                        const p = u[e];
                        o.setRelative(p, p, c * l, r);
                    }
                }
                function xn(e, t) {
                    const n = t.stack, s = n.pop();
                    exports.DEBUG && console.log(t.step, "ROUND[]"), n.push(64 * t.round(s / 64));
                }
                function Sn(e, t) {
                    const n = t.stack, s = n.pop(), o = t.ppem, r = t.deltaBase + 16 * (e - 1), a = t.deltaShift;
                    exports.DEBUG && console.log(t.step, "DELTAC[" + e + "]", s, n);
                    for(let e = 0; e < s; e++){
                        const e = n.pop(), s = n.pop();
                        if (r + ((240 & s) >> 4) !== o) continue;
                        let i = (15 & s) - 8;
                        i >= 0 && i++;
                        const l = i * a;
                        exports.DEBUG && console.log(t.step, "DELTACFIX", e, "by", l), t.cvt[e] += l;
                    }
                }
                function Un(e, t) {
                    const n = t.stack, s = n.pop(), o = n.pop(), r = t.z2[s], a = t.z1[o];
                    let i, l;
                    exports.DEBUG && console.log(t.step, "SDPVTL[" + e + "]", s, o), e ? (i = r.y - a.y, l = a.x - r.x) : (i = a.x - r.x, l = a.y - r.y), t.dpv = Qt(i, l);
                }
                function Tn(e, t) {
                    const n = t.stack, s = t.prog;
                    let o = t.ip;
                    exports.DEBUG && console.log(t.step, "PUSHB[" + e + "]");
                    for(let t = 0; t < e; t++)n.push(s[++o]);
                    t.ip = o;
                }
                function En(e, t) {
                    let n = t.ip;
                    const s = t.prog, o = t.stack;
                    exports.DEBUG && console.log(t.ip, "PUSHW[" + e + "]");
                    for(let t = 0; t < e; t++){
                        let e = s[++n] << 8 | s[++n];
                        32768 & e && (e = -(1 + (65535 ^ e))), o.push(e);
                    }
                    t.ip = n;
                }
                function kn(e, t, n, s, o, r) {
                    const a = r.stack, i = e && a.pop(), l = a.pop(), u = r.rp0, c = r.z0[u], p = r.z1[l], f = r.minDis, h = r.fv, d = r.dpv;
                    let g, m, y, v;
                    m = g = d.distance(p, c, !0, !0), y = m >= 0 ? 1 : -1, m = Math.abs(m), e && (v = r.cvt[i], s && Math.abs(m - v) < r.cvCutIn && (m = v)), n && m < f && (m = f), s && (m = r.round(m)), h.setRelative(p, c, y * m, d), h.touch(p), exports.DEBUG && console.log(r.step, (e ? "MIRP[" : "MDRP[") + (t ? "M" : "m") + (n ? ">" : "_") + (s ? "R" : "_") + (0 === o ? "Gr" : 1 === o ? "Bl" : 2 === o ? "Wh" : "") + "]", e ? i + "(" + r.cvt[i] + "," + v + ")" : "", l, "(d =", g, "->", y * m, ")"), r.rp1 = r.rp0, r.rp2 = l, t && (r.rp0 = l);
                }
                Ft.prototype.exec = function(e, t) {
                    if ("number" != typeof t) throw new Error("Point size is not a number!");
                    if (this._errorState > 2) return;
                    const n = this.font;
                    let s = this._prepState;
                    if (!s || s.ppem !== t) {
                        let e = this._fpgmState;
                        if (!e) {
                            en.prototype = $t, e = this._fpgmState = new en("fpgm", n.tables.fpgm), e.funcs = [], e.font = n, exports.DEBUG && (console.log("---EXEC FPGM---"), e.step = -1);
                            try {
                                At(e);
                            } catch (e) {
                                return console.log("Hinting error in FPGM:" + e), void (this._errorState = 3);
                            }
                        }
                        en.prototype = e, s = this._prepState = new en("prep", n.tables.prep), s.ppem = t;
                        const o = n.tables.cvt;
                        if (o) {
                            const e = s.cvt = new Array(o.length), r = t / n.unitsPerEm;
                            for(let t = 0; t < o.length; t++)e[t] = o[t] * r;
                        } else s.cvt = [];
                        exports.DEBUG && (console.log("---EXEC PREP---"), s.step = -1);
                        try {
                            At(s);
                        } catch (e) {
                            this._errorState < 2 && console.log("Hinting error in PREP:" + e), this._errorState = 2;
                        }
                    }
                    if (!(this._errorState > 1)) try {
                        return Gt(e, s);
                    } catch (e) {
                        return this._errorState < 1 && (console.log("Hinting error:" + e), console.log("Note: further hinting errors are silenced")), void (this._errorState = 1);
                    }
                }, Gt = function(e, t) {
                    const n = t.ppem / t.font.unitsPerEm, s = n;
                    let o, r, a, i = e.components;
                    if (en.prototype = t, i) {
                        const l = t.font;
                        r = [], o = [];
                        for(let e = 0; e < i.length; e++){
                            const t = i[e], u = l.glyphs.get(t.glyphIndex);
                            a = new en("glyf", u.instructions), exports.DEBUG && (console.log("---EXEC COMP " + e + "---"), a.step = -1), Nt(u, a, n, s);
                            const c = Math.round(t.dx * n), p = Math.round(t.dy * s), f = a.gZone, h = a.contours;
                            for(let e = 0; e < f.length; e++){
                                const t = f[e];
                                t.xTouched = t.yTouched = !1, t.xo = t.x = t.x + c, t.yo = t.y = t.y + p;
                            }
                            const d = r.length;
                            r.push.apply(r, f);
                            for(let e = 0; e < h.length; e++)o.push(h[e] + d);
                        }
                        e.instructions && !a.inhibitGridFit && (a = new en("glyf", e.instructions), a.gZone = a.z0 = a.z1 = a.z2 = r, a.contours = o, r.push(new Jt(0, 0), new Jt(Math.round(e.advanceWidth * n), 0)), exports.DEBUG && (console.log("---EXEC COMPOSITE---"), a.step = -1), At(a), r.length -= 2);
                    } else a = new en("glyf", e.instructions), exports.DEBUG && (console.log("---EXEC GLYPH---"), a.step = -1), Nt(e, a, n, s), r = a.gZone;
                    return r;
                }, Nt = function(e, t, n, s) {
                    const o = e.points || [], r = o.length, a = t.gZone = t.z0 = t.z1 = t.z2 = [], i = t.contours = [];
                    let l, u, c;
                    for(let e = 0; e < r; e++)l = o[e], a[e] = new Jt(l.x * n, l.y * s, l.lastPointOfContour, l.onCurve);
                    for(let e = 0; e < r; e++)l = a[e], u || (u = l, i.push(e)), l.lastPointOfContour ? (l.nextPointOnContour = u, u.prevPointOnContour = l, u = void 0) : (c = a[e + 1], l.nextPointOnContour = c, c.prevPointOnContour = l);
                    if (!t.inhibitGridFit) {
                        if (exports.DEBUG) {
                            console.log("PROCESSING GLYPH", t.stack);
                            for(let e = 0; e < r; e++)console.log(e, a[e].x, a[e].y);
                        }
                        if (a.push(new Jt(0, 0), new Jt(Math.round(e.advanceWidth * n), 0)), At(t), a.length -= 2, exports.DEBUG) {
                            console.log("FINISHED GLYPH", t.stack);
                            for(let e = 0; e < r; e++)console.log(e, a[e].x, a[e].y);
                        }
                    }
                }, At = function(e) {
                    let t = e.prog;
                    if (!t) return;
                    const n = t.length;
                    let s;
                    for(e.ip = 0; e.ip < n; e.ip++){
                        if (exports.DEBUG && e.step++, s = Pt[t[e.ip]], !s) throw new Error("unknown instruction: 0x" + Number(t[e.ip]).toString(16));
                        s(e);
                    }
                }, Pt = [
                    sn.bind(void 0, Vt),
                    sn.bind(void 0, Yt),
                    on.bind(void 0, Vt),
                    on.bind(void 0, Yt),
                    rn.bind(void 0, Vt),
                    rn.bind(void 0, Yt),
                    an.bind(void 0, 0),
                    an.bind(void 0, 1),
                    ln.bind(void 0, 0),
                    ln.bind(void 0, 1),
                    function(e) {
                        const t = e.stack, n = t.pop(), s = t.pop();
                        exports.DEBUG && console.log(e.step, "SPVFS[]", n, s), e.pv = e.dpv = Qt(s, n);
                    },
                    function(e) {
                        const t = e.stack, n = t.pop(), s = t.pop();
                        exports.DEBUG && console.log(e.step, "SPVFS[]", n, s), e.fv = Qt(s, n);
                    },
                    function(e) {
                        const t = e.stack, n = e.pv;
                        exports.DEBUG && console.log(e.step, "GPV[]"), t.push(16384 * n.x), t.push(16384 * n.y);
                    },
                    function(e) {
                        const t = e.stack, n = e.fv;
                        exports.DEBUG && console.log(e.step, "GFV[]"), t.push(16384 * n.x), t.push(16384 * n.y);
                    },
                    function(e) {
                        e.fv = e.pv, exports.DEBUG && console.log(e.step, "SFVTPV[]");
                    },
                    function(e) {
                        const t = e.stack, n = t.pop(), s = t.pop(), o = t.pop(), r = t.pop(), a = t.pop(), i = e.z0, l = e.z1, u = i[n], c = i[s], p = l[o], f = l[r], h = e.z2[a];
                        exports.DEBUG && console.log("ISECT[], ", n, s, o, r, a);
                        const d = u.x, g = u.y, m = c.x, y = c.y, v = p.x, b = p.y, x = f.x, S = f.y, U = (d - m) * (b - S) - (g - y) * (v - x), T = d * y - g * m, E = v * S - b * x;
                        h.x = (T * (v - x) - E * (d - m)) / U, h.y = (T * (b - S) - E * (g - y)) / U;
                    },
                    function(e) {
                        e.rp0 = e.stack.pop(), exports.DEBUG && console.log(e.step, "SRP0[]", e.rp0);
                    },
                    function(e) {
                        e.rp1 = e.stack.pop(), exports.DEBUG && console.log(e.step, "SRP1[]", e.rp1);
                    },
                    function(e) {
                        e.rp2 = e.stack.pop(), exports.DEBUG && console.log(e.step, "SRP2[]", e.rp2);
                    },
                    function(e) {
                        const t = e.stack.pop();
                        switch(exports.DEBUG && console.log(e.step, "SZP0[]", t), e.zp0 = t, t){
                            case 0:
                                e.tZone || tn(e), e.z0 = e.tZone;
                                break;
                            case 1:
                                e.z0 = e.gZone;
                                break;
                            default:
                                throw new Error("Invalid zone pointer");
                        }
                    },
                    function(e) {
                        const t = e.stack.pop();
                        switch(exports.DEBUG && console.log(e.step, "SZP1[]", t), e.zp1 = t, t){
                            case 0:
                                e.tZone || tn(e), e.z1 = e.tZone;
                                break;
                            case 1:
                                e.z1 = e.gZone;
                                break;
                            default:
                                throw new Error("Invalid zone pointer");
                        }
                    },
                    function(e) {
                        const t = e.stack.pop();
                        switch(exports.DEBUG && console.log(e.step, "SZP2[]", t), e.zp2 = t, t){
                            case 0:
                                e.tZone || tn(e), e.z2 = e.tZone;
                                break;
                            case 1:
                                e.z2 = e.gZone;
                                break;
                            default:
                                throw new Error("Invalid zone pointer");
                        }
                    },
                    function(e) {
                        const t = e.stack.pop();
                        switch(exports.DEBUG && console.log(e.step, "SZPS[]", t), e.zp0 = e.zp1 = e.zp2 = t, t){
                            case 0:
                                e.tZone || tn(e), e.z0 = e.z1 = e.z2 = e.tZone;
                                break;
                            case 1:
                                e.z0 = e.z1 = e.z2 = e.gZone;
                                break;
                            default:
                                throw new Error("Invalid zone pointer");
                        }
                    },
                    function(e) {
                        e.loop = e.stack.pop(), exports.DEBUG && console.log(e.step, "SLOOP[]", e.loop);
                    },
                    function(e) {
                        exports.DEBUG && console.log(e.step, "RTG[]"), e.round = Ht;
                    },
                    function(e) {
                        exports.DEBUG && console.log(e.step, "RTHG[]"), e.round = Wt;
                    },
                    function(e) {
                        const t = e.stack.pop();
                        exports.DEBUG && console.log(e.step, "SMD[]", t), e.minDis = t / 64;
                    },
                    function(e) {
                        exports.DEBUG && console.log(e.step, "ELSE[]"), nn(e, !1);
                    },
                    function(e) {
                        const t = e.stack.pop();
                        exports.DEBUG && console.log(e.step, "JMPR[]", t), e.ip += t - 1;
                    },
                    function(e) {
                        const t = e.stack.pop();
                        exports.DEBUG && console.log(e.step, "SCVTCI[]", t), e.cvCutIn = t / 64;
                    },
                    void 0,
                    void 0,
                    function(e) {
                        const t = e.stack;
                        exports.DEBUG && console.log(e.step, "DUP[]"), t.push(t[t.length - 1]);
                    },
                    un,
                    function(e) {
                        exports.DEBUG && console.log(e.step, "CLEAR[]"), e.stack.length = 0;
                    },
                    function(e) {
                        const t = e.stack, n = t.pop(), s = t.pop();
                        exports.DEBUG && console.log(e.step, "SWAP[]"), t.push(n), t.push(s);
                    },
                    function(e) {
                        const t = e.stack;
                        exports.DEBUG && console.log(e.step, "DEPTH[]"), t.push(t.length);
                    },
                    function(e) {
                        const t = e.stack, n = t.pop();
                        exports.DEBUG && console.log(e.step, "CINDEX[]", n), t.push(t[t.length - n]);
                    },
                    function(e) {
                        const t = e.stack, n = t.pop();
                        exports.DEBUG && console.log(e.step, "MINDEX[]", n), t.push(t.splice(t.length - n, 1)[0]);
                    },
                    void 0,
                    void 0,
                    void 0,
                    function(e) {
                        const t = e.stack, n = t.pop(), s = t.pop();
                        exports.DEBUG && console.log(e.step, "LOOPCALL[]", n, s);
                        const o = e.ip, r = e.prog;
                        e.prog = e.funcs[n];
                        for(let t = 0; t < s; t++)At(e), exports.DEBUG && console.log(++e.step, t + 1 < s ? "next loopcall" : "done loopcall", t);
                        e.ip = o, e.prog = r;
                    },
                    function(e) {
                        const t = e.stack.pop();
                        exports.DEBUG && console.log(e.step, "CALL[]", t);
                        const n = e.ip, s = e.prog;
                        e.prog = e.funcs[t], At(e), e.ip = n, e.prog = s, exports.DEBUG && console.log(++e.step, "returning from", t);
                    },
                    function(e) {
                        if ("fpgm" !== e.env) throw new Error("FDEF not allowed here");
                        const t = e.stack, n = e.prog;
                        let s = e.ip;
                        const o = t.pop(), r = s;
                        for(exports.DEBUG && console.log(e.step, "FDEF[]", o); 45 !== n[++s];);
                        e.ip = s, e.funcs[o] = n.slice(r + 1, s);
                    },
                    void 0,
                    cn.bind(void 0, 0),
                    cn.bind(void 0, 1),
                    pn.bind(void 0, Vt),
                    pn.bind(void 0, Yt),
                    fn.bind(void 0, 0),
                    fn.bind(void 0, 1),
                    hn.bind(void 0, 0),
                    hn.bind(void 0, 1),
                    dn.bind(void 0, 0),
                    dn.bind(void 0, 1),
                    function(e) {
                        const t = e.stack;
                        let n = e.loop;
                        const s = e.fv, o = t.pop() / 64, r = e.z2;
                        for(; n--;){
                            const a = t.pop(), i = r[a];
                            exports.DEBUG && console.log(e.step, (e.loop > 1 ? "loop " + (e.loop - n) + ": " : "") + "SHPIX[]", a, o), s.setRelative(i, i, o), s.touch(i);
                        }
                        e.loop = 1;
                    },
                    function(e) {
                        const t = e.stack, n = e.rp1, s = e.rp2;
                        let o = e.loop;
                        const r = e.z0[n], a = e.z1[s], i = e.fv, l = e.dpv, u = e.z2;
                        for(; o--;){
                            const c = t.pop(), p = u[c];
                            exports.DEBUG && console.log(e.step, (e.loop > 1 ? "loop " + (e.loop - o) + ": " : "") + "IP[]", c, n, "<->", s), i.interpolate(p, r, a, l), i.touch(p);
                        }
                        e.loop = 1;
                    },
                    gn.bind(void 0, 0),
                    gn.bind(void 0, 1),
                    function(e) {
                        const t = e.stack, n = e.rp0, s = e.z0[n];
                        let o = e.loop;
                        const r = e.fv, a = e.pv, i = e.z1;
                        for(; o--;){
                            const n = t.pop(), l = i[n];
                            exports.DEBUG && console.log(e.step, (e.loop > 1 ? "loop " + (e.loop - o) + ": " : "") + "ALIGNRP[]", n), r.setRelative(l, s, 0, a), r.touch(l);
                        }
                        e.loop = 1;
                    },
                    function(e) {
                        exports.DEBUG && console.log(e.step, "RTDG[]"), e.round = zt;
                    },
                    mn.bind(void 0, 0),
                    mn.bind(void 0, 1),
                    function(e) {
                        const t = e.prog;
                        let n = e.ip;
                        const s = e.stack, o = t[++n];
                        exports.DEBUG && console.log(e.step, "NPUSHB[]", o);
                        for(let e = 0; e < o; e++)s.push(t[++n]);
                        e.ip = n;
                    },
                    function(e) {
                        let t = e.ip;
                        const n = e.prog, s = e.stack, o = n[++t];
                        exports.DEBUG && console.log(e.step, "NPUSHW[]", o);
                        for(let e = 0; e < o; e++){
                            let e = n[++t] << 8 | n[++t];
                            32768 & e && (e = -(1 + (65535 ^ e))), s.push(e);
                        }
                        e.ip = t;
                    },
                    function(e) {
                        const t = e.stack;
                        let n = e.store;
                        n || (n = e.store = []);
                        const s = t.pop(), o = t.pop();
                        exports.DEBUG && console.log(e.step, "WS", s, o), n[o] = s;
                    },
                    function(e) {
                        const t = e.stack, n = e.store, s = t.pop();
                        exports.DEBUG && console.log(e.step, "RS", s);
                        const o = n && n[s] || 0;
                        t.push(o);
                    },
                    function(e) {
                        const t = e.stack, n = t.pop(), s = t.pop();
                        exports.DEBUG && console.log(e.step, "WCVTP", n, s), e.cvt[s] = n / 64;
                    },
                    function(e) {
                        const t = e.stack, n = t.pop();
                        exports.DEBUG && console.log(e.step, "RCVT", n), t.push(64 * e.cvt[n]);
                    },
                    yn.bind(void 0, 0),
                    yn.bind(void 0, 1),
                    void 0,
                    vn.bind(void 0, 0),
                    vn.bind(void 0, 1),
                    function(e) {
                        exports.DEBUG && console.log(e.step, "MPPEM[]"), e.stack.push(e.ppem);
                    },
                    void 0,
                    function(e) {
                        exports.DEBUG && console.log(e.step, "FLIPON[]"), e.autoFlip = !0;
                    },
                    void 0,
                    void 0,
                    function(e) {
                        const t = e.stack, n = t.pop(), s = t.pop();
                        exports.DEBUG && console.log(e.step, "LT[]", n, s), t.push(s < n ? 1 : 0);
                    },
                    function(e) {
                        const t = e.stack, n = t.pop(), s = t.pop();
                        exports.DEBUG && console.log(e.step, "LTEQ[]", n, s), t.push(s <= n ? 1 : 0);
                    },
                    function(e) {
                        const t = e.stack, n = t.pop(), s = t.pop();
                        exports.DEBUG && console.log(e.step, "GT[]", n, s), t.push(s > n ? 1 : 0);
                    },
                    function(e) {
                        const t = e.stack, n = t.pop(), s = t.pop();
                        exports.DEBUG && console.log(e.step, "GTEQ[]", n, s), t.push(s >= n ? 1 : 0);
                    },
                    function(e) {
                        const t = e.stack, n = t.pop(), s = t.pop();
                        exports.DEBUG && console.log(e.step, "EQ[]", n, s), t.push(n === s ? 1 : 0);
                    },
                    function(e) {
                        const t = e.stack, n = t.pop(), s = t.pop();
                        exports.DEBUG && console.log(e.step, "NEQ[]", n, s), t.push(n !== s ? 1 : 0);
                    },
                    function(e) {
                        const t = e.stack, n = t.pop();
                        exports.DEBUG && console.log(e.step, "ODD[]", n), t.push(Math.trunc(n) % 2 ? 1 : 0);
                    },
                    function(e) {
                        const t = e.stack, n = t.pop();
                        exports.DEBUG && console.log(e.step, "EVEN[]", n), t.push(Math.trunc(n) % 2 ? 0 : 1);
                    },
                    function(e) {
                        let t = e.stack.pop();
                        exports.DEBUG && console.log(e.step, "IF[]", t), t || (nn(e, !0), exports.DEBUG && console.log(e.step, "EIF[]"));
                    },
                    function(e) {
                        exports.DEBUG && console.log(e.step, "EIF[]");
                    },
                    function(e) {
                        const t = e.stack, n = t.pop(), s = t.pop();
                        exports.DEBUG && console.log(e.step, "AND[]", n, s), t.push(n && s ? 1 : 0);
                    },
                    function(e) {
                        const t = e.stack, n = t.pop(), s = t.pop();
                        exports.DEBUG && console.log(e.step, "OR[]", n, s), t.push(n || s ? 1 : 0);
                    },
                    function(e) {
                        const t = e.stack, n = t.pop();
                        exports.DEBUG && console.log(e.step, "NOT[]", n), t.push(n ? 0 : 1);
                    },
                    bn.bind(void 0, 1),
                    function(e) {
                        const t = e.stack.pop();
                        exports.DEBUG && console.log(e.step, "SDB[]", t), e.deltaBase = t;
                    },
                    function(e) {
                        const t = e.stack.pop();
                        exports.DEBUG && console.log(e.step, "SDS[]", t), e.deltaShift = Math.pow(.5, t);
                    },
                    function(e) {
                        const t = e.stack, n = t.pop(), s = t.pop();
                        exports.DEBUG && console.log(e.step, "ADD[]", n, s), t.push(s + n);
                    },
                    function(e) {
                        const t = e.stack, n = t.pop(), s = t.pop();
                        exports.DEBUG && console.log(e.step, "SUB[]", n, s), t.push(s - n);
                    },
                    function(e) {
                        const t = e.stack, n = t.pop(), s = t.pop();
                        exports.DEBUG && console.log(e.step, "DIV[]", n, s), t.push(64 * s / n);
                    },
                    function(e) {
                        const t = e.stack, n = t.pop(), s = t.pop();
                        exports.DEBUG && console.log(e.step, "MUL[]", n, s), t.push(s * n / 64);
                    },
                    function(e) {
                        const t = e.stack, n = t.pop();
                        exports.DEBUG && console.log(e.step, "ABS[]", n), t.push(Math.abs(n));
                    },
                    function(e) {
                        const t = e.stack;
                        let n = t.pop();
                        exports.DEBUG && console.log(e.step, "NEG[]", n), t.push(-n);
                    },
                    function(e) {
                        const t = e.stack, n = t.pop();
                        exports.DEBUG && console.log(e.step, "FLOOR[]", n), t.push(64 * Math.floor(n / 64));
                    },
                    function(e) {
                        const t = e.stack, n = t.pop();
                        exports.DEBUG && console.log(e.step, "CEILING[]", n), t.push(64 * Math.ceil(n / 64));
                    },
                    xn.bind(void 0, 0),
                    xn.bind(void 0, 1),
                    xn.bind(void 0, 2),
                    xn.bind(void 0, 3),
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    function(e) {
                        const t = e.stack, n = t.pop(), s = t.pop();
                        exports.DEBUG && console.log(e.step, "WCVTF[]", n, s), e.cvt[s] = n * e.ppem / e.font.unitsPerEm;
                    },
                    bn.bind(void 0, 2),
                    bn.bind(void 0, 3),
                    Sn.bind(void 0, 1),
                    Sn.bind(void 0, 2),
                    Sn.bind(void 0, 3),
                    function(e) {
                        let t, n = e.stack.pop();
                        switch(exports.DEBUG && console.log(e.step, "SROUND[]", n), e.round = Xt, 192 & n){
                            case 0:
                                t = .5;
                                break;
                            case 64:
                                t = 1;
                                break;
                            case 128:
                                t = 2;
                                break;
                            default:
                                throw new Error("invalid SROUND value");
                        }
                        switch(e.srPeriod = t, 48 & n){
                            case 0:
                                e.srPhase = 0;
                                break;
                            case 16:
                                e.srPhase = .25 * t;
                                break;
                            case 32:
                                e.srPhase = .5 * t;
                                break;
                            case 48:
                                e.srPhase = .75 * t;
                                break;
                            default:
                                throw new Error("invalid SROUND value");
                        }
                        n &= 15, e.srThreshold = 0 === n ? 0 : (n / 8 - .5) * t;
                    },
                    function(e) {
                        let t, n = e.stack.pop();
                        switch(exports.DEBUG && console.log(e.step, "S45ROUND[]", n), e.round = Xt, 192 & n){
                            case 0:
                                t = Math.sqrt(2) / 2;
                                break;
                            case 64:
                                t = Math.sqrt(2);
                                break;
                            case 128:
                                t = 2 * Math.sqrt(2);
                                break;
                            default:
                                throw new Error("invalid S45ROUND value");
                        }
                        switch(e.srPeriod = t, 48 & n){
                            case 0:
                                e.srPhase = 0;
                                break;
                            case 16:
                                e.srPhase = .25 * t;
                                break;
                            case 32:
                                e.srPhase = .5 * t;
                                break;
                            case 48:
                                e.srPhase = .75 * t;
                                break;
                            default:
                                throw new Error("invalid S45ROUND value");
                        }
                        n &= 15, e.srThreshold = 0 === n ? 0 : (n / 8 - .5) * t;
                    },
                    void 0,
                    void 0,
                    function(e) {
                        exports.DEBUG && console.log(e.step, "ROFF[]"), e.round = _t;
                    },
                    void 0,
                    function(e) {
                        exports.DEBUG && console.log(e.step, "RUTG[]"), e.round = qt;
                    },
                    function(e) {
                        exports.DEBUG && console.log(e.step, "RDTG[]"), e.round = jt;
                    },
                    un,
                    un,
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    function(e) {
                        const t = e.stack.pop();
                        exports.DEBUG && console.log(e.step, "SCANCTRL[]", t);
                    },
                    Un.bind(void 0, 0),
                    Un.bind(void 0, 1),
                    function(e) {
                        const t = e.stack, n = t.pop();
                        let s = 0;
                        exports.DEBUG && console.log(e.step, "GETINFO[]", n), 1 & n && (s = 35), 32 & n && (s |= 4096), t.push(s);
                    },
                    void 0,
                    function(e) {
                        const t = e.stack, n = t.pop(), s = t.pop(), o = t.pop();
                        exports.DEBUG && console.log(e.step, "ROLL[]"), t.push(s), t.push(n), t.push(o);
                    },
                    function(e) {
                        const t = e.stack, n = t.pop(), s = t.pop();
                        exports.DEBUG && console.log(e.step, "MAX[]", n, s), t.push(Math.max(s, n));
                    },
                    function(e) {
                        const t = e.stack, n = t.pop(), s = t.pop();
                        exports.DEBUG && console.log(e.step, "MIN[]", n, s), t.push(Math.min(s, n));
                    },
                    function(e) {
                        const t = e.stack.pop();
                        exports.DEBUG && console.log(e.step, "SCANTYPE[]", t);
                    },
                    function(e) {
                        const t = e.stack.pop();
                        let n = e.stack.pop();
                        switch(exports.DEBUG && console.log(e.step, "INSTCTRL[]", t, n), t){
                            case 1:
                                return void (e.inhibitGridFit = !!n);
                            case 2:
                                return void (e.ignoreCvt = !!n);
                            default:
                                throw new Error("invalid INSTCTRL[] selector");
                        }
                    },
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    Tn.bind(void 0, 1),
                    Tn.bind(void 0, 2),
                    Tn.bind(void 0, 3),
                    Tn.bind(void 0, 4),
                    Tn.bind(void 0, 5),
                    Tn.bind(void 0, 6),
                    Tn.bind(void 0, 7),
                    Tn.bind(void 0, 8),
                    En.bind(void 0, 1),
                    En.bind(void 0, 2),
                    En.bind(void 0, 3),
                    En.bind(void 0, 4),
                    En.bind(void 0, 5),
                    En.bind(void 0, 6),
                    En.bind(void 0, 7),
                    En.bind(void 0, 8),
                    kn.bind(void 0, 0, 0, 0, 0, 0),
                    kn.bind(void 0, 0, 0, 0, 0, 1),
                    kn.bind(void 0, 0, 0, 0, 0, 2),
                    kn.bind(void 0, 0, 0, 0, 0, 3),
                    kn.bind(void 0, 0, 0, 0, 1, 0),
                    kn.bind(void 0, 0, 0, 0, 1, 1),
                    kn.bind(void 0, 0, 0, 0, 1, 2),
                    kn.bind(void 0, 0, 0, 0, 1, 3),
                    kn.bind(void 0, 0, 0, 1, 0, 0),
                    kn.bind(void 0, 0, 0, 1, 0, 1),
                    kn.bind(void 0, 0, 0, 1, 0, 2),
                    kn.bind(void 0, 0, 0, 1, 0, 3),
                    kn.bind(void 0, 0, 0, 1, 1, 0),
                    kn.bind(void 0, 0, 0, 1, 1, 1),
                    kn.bind(void 0, 0, 0, 1, 1, 2),
                    kn.bind(void 0, 0, 0, 1, 1, 3),
                    kn.bind(void 0, 0, 1, 0, 0, 0),
                    kn.bind(void 0, 0, 1, 0, 0, 1),
                    kn.bind(void 0, 0, 1, 0, 0, 2),
                    kn.bind(void 0, 0, 1, 0, 0, 3),
                    kn.bind(void 0, 0, 1, 0, 1, 0),
                    kn.bind(void 0, 0, 1, 0, 1, 1),
                    kn.bind(void 0, 0, 1, 0, 1, 2),
                    kn.bind(void 0, 0, 1, 0, 1, 3),
                    kn.bind(void 0, 0, 1, 1, 0, 0),
                    kn.bind(void 0, 0, 1, 1, 0, 1),
                    kn.bind(void 0, 0, 1, 1, 0, 2),
                    kn.bind(void 0, 0, 1, 1, 0, 3),
                    kn.bind(void 0, 0, 1, 1, 1, 0),
                    kn.bind(void 0, 0, 1, 1, 1, 1),
                    kn.bind(void 0, 0, 1, 1, 1, 2),
                    kn.bind(void 0, 0, 1, 1, 1, 3),
                    kn.bind(void 0, 1, 0, 0, 0, 0),
                    kn.bind(void 0, 1, 0, 0, 0, 1),
                    kn.bind(void 0, 1, 0, 0, 0, 2),
                    kn.bind(void 0, 1, 0, 0, 0, 3),
                    kn.bind(void 0, 1, 0, 0, 1, 0),
                    kn.bind(void 0, 1, 0, 0, 1, 1),
                    kn.bind(void 0, 1, 0, 0, 1, 2),
                    kn.bind(void 0, 1, 0, 0, 1, 3),
                    kn.bind(void 0, 1, 0, 1, 0, 0),
                    kn.bind(void 0, 1, 0, 1, 0, 1),
                    kn.bind(void 0, 1, 0, 1, 0, 2),
                    kn.bind(void 0, 1, 0, 1, 0, 3),
                    kn.bind(void 0, 1, 0, 1, 1, 0),
                    kn.bind(void 0, 1, 0, 1, 1, 1),
                    kn.bind(void 0, 1, 0, 1, 1, 2),
                    kn.bind(void 0, 1, 0, 1, 1, 3),
                    kn.bind(void 0, 1, 1, 0, 0, 0),
                    kn.bind(void 0, 1, 1, 0, 0, 1),
                    kn.bind(void 0, 1, 1, 0, 0, 2),
                    kn.bind(void 0, 1, 1, 0, 0, 3),
                    kn.bind(void 0, 1, 1, 0, 1, 0),
                    kn.bind(void 0, 1, 1, 0, 1, 1),
                    kn.bind(void 0, 1, 1, 0, 1, 2),
                    kn.bind(void 0, 1, 1, 0, 1, 3),
                    kn.bind(void 0, 1, 1, 1, 0, 0),
                    kn.bind(void 0, 1, 1, 1, 0, 1),
                    kn.bind(void 0, 1, 1, 1, 0, 2),
                    kn.bind(void 0, 1, 1, 1, 0, 3),
                    kn.bind(void 0, 1, 1, 1, 1, 0),
                    kn.bind(void 0, 1, 1, 1, 1, 1),
                    kn.bind(void 0, 1, 1, 1, 1, 2),
                    kn.bind(void 0, 1, 1, 1, 1, 3)
                ];
                const wn = Ft;
                function On(e) {
                    (e = e || {}).empty || (Mt(e.familyName, "When creating a new Font object, familyName is required."), Mt(e.styleName, "When creating a new Font object, styleName is required."), Mt(e.unitsPerEm, "When creating a new Font object, unitsPerEm is required."), Mt(e.ascender, "When creating a new Font object, ascender is required."), Mt(e.descender, "When creating a new Font object, descender is required."), Mt(e.descender < 0, "Descender should be negative (e.g. -512)."), this.names = {
                        fontFamily: {
                            en: e.familyName || " "
                        },
                        fontSubfamily: {
                            en: e.styleName || " "
                        },
                        fullName: {
                            en: e.fullName || e.familyName + " " + e.styleName
                        },
                        postScriptName: {
                            en: e.postScriptName || e.familyName + e.styleName
                        },
                        designer: {
                            en: e.designer || " "
                        },
                        designerURL: {
                            en: e.designerURL || " "
                        },
                        manufacturer: {
                            en: e.manufacturer || " "
                        },
                        manufacturerURL: {
                            en: e.manufacturerURL || " "
                        },
                        license: {
                            en: e.license || " "
                        },
                        licenseURL: {
                            en: e.licenseURL || " "
                        },
                        version: {
                            en: e.version || "Version 0.1"
                        },
                        description: {
                            en: e.description || " "
                        },
                        copyright: {
                            en: e.copyright || " "
                        },
                        trademark: {
                            en: e.trademark || " "
                        }
                    }, this.unitsPerEm = e.unitsPerEm || 1e3, this.ascender = e.ascender, this.descender = e.descender, this.createdTimestamp = e.createdTimestamp, this.tables = {
                        os2: {
                            usWeightClass: e.weightClass || this.usWeightClasses.MEDIUM,
                            usWidthClass: e.widthClass || this.usWidthClasses.MEDIUM,
                            fsSelection: e.fsSelection || this.fsSelectionValues.REGULAR
                        }
                    }), this.supported = !0, this.glyphs = new pe.GlyphSet(this, e.glyphs || []), this.encoding = new Q(this), this.position = new It(this), this.substitution = new Ct(this), this.tables = this.tables || {}, Object.defineProperty(this, "hinting", {
                        get: function() {
                            return this._hinting ? this._hinting : "truetype" === this.outlinesFormat ? this._hinting = new wn(this) : void 0;
                        }
                    });
                }
                On.prototype.hasChar = function(e) {
                    return null !== this.encoding.charToGlyphIndex(e);
                }, On.prototype.charToGlyphIndex = function(e) {
                    return this.encoding.charToGlyphIndex(e);
                }, On.prototype.charToGlyph = function(e) {
                    const t = this.charToGlyphIndex(e);
                    let n = this.glyphs.get(t);
                    return n || (n = this.glyphs.get(0)), n;
                }, On.prototype.stringToGlyphs = function(e, t) {
                    t = t || this.defaultRenderOptions;
                    const n = [];
                    for(let t = 0; t < e.length; t += 1){
                        const s = e[t];
                        n.push(this.charToGlyphIndex(s));
                    }
                    let s = n.length;
                    if (t.features) {
                        const e = t.script || this.substitution.getDefaultScriptName();
                        let o = [];
                        t.features.liga && (o = o.concat(this.substitution.getFeature("liga", e, t.language))), t.features.rlig && (o = o.concat(this.substitution.getFeature("rlig", e, t.language)));
                        for(let e = 0; e < s; e += 1)for(let t = 0; t < o.length; t++){
                            const r = o[t], a = r.sub, i = a.length;
                            let l = 0;
                            for(; l < i && a[l] === n[e + l];)l++;
                            l === i && (n.splice(e, i, r.by), s = s - i + 1);
                        }
                    }
                    const o = new Array(s), r = this.glyphs.get(0);
                    for(let e = 0; e < s; e += 1)o[e] = this.glyphs.get(n[e]) || r;
                    return o;
                }, On.prototype.nameToGlyphIndex = function(e) {
                    return this.glyphNames.nameToGlyphIndex(e);
                }, On.prototype.nameToGlyph = function(e) {
                    const t = this.nameToGlyphIndex(e);
                    let n = this.glyphs.get(t);
                    return n || (n = this.glyphs.get(0)), n;
                }, On.prototype.glyphIndexToName = function(e) {
                    return this.glyphNames.glyphIndexToName ? this.glyphNames.glyphIndexToName(e) : "";
                }, On.prototype.getKerningValue = function(e, t) {
                    return e = e.index || e, t = t.index || t, this.kerningPairs[e + "," + t] || 0;
                }, On.prototype.defaultRenderOptions = {
                    kerning: !0,
                    features: {
                        liga: !0,
                        rlig: !0
                    }
                }, On.prototype.forEachGlyph = function(e, t, n, s, o, r) {
                    t = void 0 !== t ? t : 0, n = void 0 !== n ? n : 0, s = void 0 !== s ? s : 72, o = o || this.defaultRenderOptions;
                    const a = 1 / this.unitsPerEm * s, i = this.stringToGlyphs(e, o);
                    let l;
                    if (o.kerning) {
                        const e = o.script || this.position.getDefaultScriptName();
                        l = this.position.getKerningTables(e, o.language);
                    }
                    for(let e = 0; e < i.length; e += 1){
                        const u = i[e];
                        r.call(this, u, t, n, s, o), u.advanceWidth && (t += u.advanceWidth * a), o.kerning && e < i.length - 1 && (t += (l ? this.position.getKerningValue(l, u.index, i[e + 1].index) : this.getKerningValue(u, i[e + 1])) * a), o.letterSpacing ? t += o.letterSpacing * s : o.tracking && (t += o.tracking / 1e3 * s);
                    }
                    return t;
                }, On.prototype.getPath = function(e, t, n, s, o) {
                    const r = new u;
                    return this.forEachGlyph(e, t, n, s, o, function(e, t, n, s) {
                        const a = e.getPath(t, n, s, o, this);
                        r.extend(a);
                    }), r;
                }, On.prototype.getPaths = function(e, t, n, s, o) {
                    const r = [];
                    return this.forEachGlyph(e, t, n, s, o, function(e, t, n, s) {
                        const a = e.getPath(t, n, s, o, this);
                        r.push(a);
                    }), r;
                }, On.prototype.getAdvanceWidth = function(e, t, n) {
                    return this.forEachGlyph(e, 0, 0, t, n, function() {});
                }, On.prototype.draw = function(e, t, n, s, o, r) {
                    this.getPath(t, n, s, o, r).draw(e);
                }, On.prototype.drawPoints = function(e, t, n, s, o, r) {
                    this.forEachGlyph(t, n, s, o, r, function(t, n, s, o) {
                        t.drawPoints(e, n, s, o);
                    });
                }, On.prototype.drawMetrics = function(e, t, n, s, o, r) {
                    this.forEachGlyph(t, n, s, o, r, function(t, n, s, o) {
                        t.drawMetrics(e, n, s, o);
                    });
                }, On.prototype.getEnglishName = function(e) {
                    const t = this.names[e];
                    if (t) return t.en;
                }, On.prototype.validate = function() {
                    const e = [], t = this;
                    function n(t, n) {
                        t || e.push(n);
                    }
                    function s(e) {
                        const s = t.getEnglishName(e);
                        n(s && s.trim().length > 0, "No English " + e + " specified.");
                    }
                    s("fontFamily"), s("weightName"), s("manufacturer"), s("copyright"), s("version"), n(this.unitsPerEm > 0, "No unitsPerEm specified.");
                }, On.prototype.toTables = function() {
                    return St(this);
                }, On.prototype.toBuffer = function() {
                    return console.warn("Font.toBuffer is deprecated. Use Font.toArrayBuffer instead."), this.toArrayBuffer();
                }, On.prototype.toArrayBuffer = function() {
                    const e = this.toTables().encode(), t = new ArrayBuffer(e.length), n = new Uint8Array(t);
                    for(let t = 0; t < e.length; t++)n[t] = e[t];
                    return t;
                }, On.prototype.download = function(e) {
                    const t = this.getEnglishName("fontFamily"), s = this.getEnglishName("fontSubfamily");
                    e = e || t.replace(/\s/g, "") + "-" + s + ".otf";
                    const o = this.toArrayBuffer();
                    if ("undefined" != typeof window) window.requestFileSystem = window.requestFileSystem || window.webkitRequestFileSystem, window.requestFileSystem(window.TEMPORARY, o.byteLength, function(t) {
                        t.root.getFile(e, {
                            create: !0
                        }, function(e) {
                            e.createWriter(function(t) {
                                const n = new DataView(o), s = new Blob([
                                    n
                                ], {
                                    type: "font/opentype"
                                });
                                t.write(s), t.addEventListener("writeend", function() {
                                    location.href = e.toURL();
                                }, !1);
                            });
                        });
                    }, function(e) {
                        throw new Error(e.name + ": " + e.message);
                    });
                    else {
                        const t = n(89), s = function(e) {
                            const t = new Buffer(e.byteLength), n = new Uint8Array(e);
                            for(let e = 0; e < t.length; ++e)t[e] = n[e];
                            return t;
                        }(o);
                        t.writeFileSync(e, s);
                    }
                }, On.prototype.fsSelectionValues = {
                    ITALIC: 1,
                    UNDERSCORE: 2,
                    NEGATIVE: 4,
                    OUTLINED: 8,
                    STRIKEOUT: 16,
                    BOLD: 32,
                    REGULAR: 64,
                    USER_TYPO_METRICS: 128,
                    WWS: 256,
                    OBLIQUE: 512
                }, On.prototype.usWidthClasses = {
                    ULTRA_CONDENSED: 1,
                    EXTRA_CONDENSED: 2,
                    CONDENSED: 3,
                    SEMI_CONDENSED: 4,
                    MEDIUM: 5,
                    SEMI_EXPANDED: 6,
                    EXPANDED: 7,
                    EXTRA_EXPANDED: 8,
                    ULTRA_EXPANDED: 9
                }, On.prototype.usWeightClasses = {
                    THIN: 100,
                    EXTRA_LIGHT: 200,
                    LIGHT: 300,
                    NORMAL: 400,
                    MEDIUM: 500,
                    SEMI_BOLD: 600,
                    BOLD: 700,
                    EXTRA_BOLD: 800,
                    BLACK: 900
                };
                const In = On;
                function Rn(e, t, n) {
                    const s = {}, o = new z.Parser(e, t);
                    return s.tag = o.parseTag(), s.minValue = o.parseFixed(), s.defaultValue = o.parseFixed(), s.maxValue = o.parseFixed(), o.skip("uShort", 1), s.name = n[o.parseUShort()] || {}, s;
                }
                function Ln(e, t, n, s) {
                    const o = {}, r = new z.Parser(e, t);
                    o.name = s[r.parseUShort()] || {}, r.skip("uShort", 1), o.coordinates = {};
                    for(let e = 0; e < n.length; ++e)o.coordinates[n[e].tag] = r.parseFixed();
                    return o;
                }
                const Bn = function(e, t, n) {
                    const s = new z.Parser(e, t), o = s.parseULong();
                    f.argument(65536 === o, "Unsupported fvar table version.");
                    const r = s.parseOffset16();
                    s.skip("uShort", 1);
                    const a = s.parseUShort(), i = s.parseUShort(), l = s.parseUShort(), u = s.parseUShort(), c = [];
                    for(let s = 0; s < a; s++)c.push(Rn(e, t + r + s * i, n));
                    const p = [], h = t + r + a * i;
                    for(let t = 0; t < l; t++)p.push(Ln(e, h + t * u, c, n));
                    return {
                        axes: c,
                        instances: p
                    };
                }, Cn = new Array(10);
                Cn[1] = function() {
                    const e = this.offset + this.relativeOffset, t = this.parseUShort();
                    return 1 === t ? {
                        posFormat: 1,
                        coverage: this.parsePointer(_.coverage),
                        value: this.parseValueRecord()
                    } : 2 === t ? {
                        posFormat: 2,
                        coverage: this.parsePointer(_.coverage),
                        values: this.parseValueRecordList()
                    } : void f.assert(!1, "0x" + e.toString(16) + ": GPOS lookup type 1 format must be 1 or 2.");
                }, Cn[2] = function() {
                    const e = this.offset + this.relativeOffset, t = this.parseUShort(), n = this.parsePointer(_.coverage), s = this.parseUShort(), o = this.parseUShort();
                    if (1 === t) return {
                        posFormat: t,
                        coverage: n,
                        valueFormat1: s,
                        valueFormat2: o,
                        pairSets: this.parseList(_.pointer(_.list(function() {
                            return {
                                secondGlyph: this.parseUShort(),
                                value1: this.parseValueRecord(s),
                                value2: this.parseValueRecord(o)
                            };
                        })))
                    };
                    if (2 === t) {
                        const e = this.parsePointer(_.classDef), r = this.parsePointer(_.classDef), a = this.parseUShort(), i = this.parseUShort();
                        return {
                            posFormat: t,
                            coverage: n,
                            valueFormat1: s,
                            valueFormat2: o,
                            classDef1: e,
                            classDef2: r,
                            class1Count: a,
                            class2Count: i,
                            classRecords: this.parseList(a, _.list(i, function() {
                                return {
                                    value1: this.parseValueRecord(s),
                                    value2: this.parseValueRecord(o)
                                };
                            }))
                        };
                    }
                    f.assert(!1, "0x" + e.toString(16) + ": GPOS lookup type 2 format must be 1 or 2.");
                }, Cn[3] = function() {
                    return {
                        error: "GPOS Lookup 3 not supported"
                    };
                }, Cn[4] = function() {
                    return {
                        error: "GPOS Lookup 4 not supported"
                    };
                }, Cn[5] = function() {
                    return {
                        error: "GPOS Lookup 5 not supported"
                    };
                }, Cn[6] = function() {
                    return {
                        error: "GPOS Lookup 6 not supported"
                    };
                }, Cn[7] = function() {
                    return {
                        error: "GPOS Lookup 7 not supported"
                    };
                }, Cn[8] = function() {
                    return {
                        error: "GPOS Lookup 8 not supported"
                    };
                }, Cn[9] = function() {
                    return {
                        error: "GPOS Lookup 9 not supported"
                    };
                };
                new Array(10);
                const Dn = function(e, t) {
                    const n = new _(e, t = t || 0), s = n.parseVersion(1);
                    return f.argument(1 === s || 1.1 === s, "Unsupported GPOS table version " + s), 1 === s ? {
                        version: s,
                        scripts: n.parseScriptList(),
                        features: n.parseFeatureList(),
                        lookups: n.parseLookupList(Cn)
                    } : {
                        version: s,
                        scripts: n.parseScriptList(),
                        features: n.parseFeatureList(),
                        lookups: n.parseLookupList(Cn),
                        variations: n.parseFeatureVariationsList()
                    };
                }, Mn = function(e, t) {
                    const n = new z.Parser(e, t), s = n.parseUShort();
                    if (0 === s) return function(e) {
                        const t = {};
                        e.skip("uShort");
                        const n = e.parseUShort();
                        f.argument(0 === n, "Unsupported kern sub-table version."), e.skip("uShort", 2);
                        const s = e.parseUShort();
                        e.skip("uShort", 3);
                        for(let n = 0; n < s; n += 1){
                            const n = e.parseUShort(), s = e.parseUShort(), o = e.parseShort();
                            t[n + "," + s] = o;
                        }
                        return t;
                    }(n);
                    if (1 === s) return function(e) {
                        const t = {};
                        e.skip("uShort"), e.parseULong() > 1 && console.warn("Only the first kern subtable is supported."), e.skip("uLong");
                        const n = 255 & e.parseUShort();
                        if (e.skip("uShort"), 0 === n) {
                            const n = e.parseUShort();
                            e.skip("uShort", 3);
                            for(let s = 0; s < n; s += 1){
                                const n = e.parseUShort(), s = e.parseUShort(), o = e.parseShort();
                                t[n + "," + s] = o;
                            }
                        }
                        return t;
                    }(n);
                    throw new Error("Unsupported kern table version (" + s + ").");
                }, Pn = function(e, t, n, s) {
                    const o = new z.Parser(e, t), r = s ? o.parseUShort : o.parseULong, a = [];
                    for(let e = 0; e < n + 1; e += 1){
                        let e = r.call(o);
                        s && (e *= 2), a.push(e);
                    }
                    return a;
                };
                function An(e, t) {
                    n(89).readFile(e, function(e, n) {
                        if (e) return t(e.message);
                        t(null, Dt(n));
                    });
                }
                function Gn(e, t) {
                    const n = new XMLHttpRequest;
                    n.open("get", e, !0), n.responseType = "arraybuffer", n.onload = function() {
                        return n.response ? t(null, n.response) : t("Font could not be loaded: " + n.statusText);
                    }, n.onerror = function() {
                        t("Font could not be loaded");
                    }, n.send();
                }
                function Nn(e, t) {
                    const n = [];
                    let s = 12;
                    for(let o = 0; o < t; o += 1){
                        const t = z.getTag(e, s), o = z.getULong(e, s + 4), r = z.getULong(e, s + 8), a = z.getULong(e, s + 12);
                        n.push({
                            tag: t,
                            checksum: o,
                            offset: r,
                            length: a,
                            compression: !1
                        }), s += 16;
                    }
                    return n;
                }
                function Fn(e, t) {
                    if ("WOFF" === t.compression) {
                        const n = new Uint8Array(e.buffer, t.offset + 2, t.compressedLength - 2), s = new Uint8Array(t.length);
                        if (o()(n, s), s.byteLength !== t.length) throw new Error("Decompression error: " + t.tag + " decompressed length doesn't match recorded length");
                        return {
                            data: new DataView(s.buffer, 0),
                            offset: 0
                        };
                    }
                    return {
                        data: e,
                        offset: t.offset
                    };
                }
                function _n(e) {
                    let t, n;
                    const s = new In({
                        empty: !0
                    }), o = new DataView(e, 0);
                    let r, a = [];
                    const i = z.getTag(o, 0);
                    if (i === String.fromCharCode(0, 1, 0, 0) || "true" === i || "typ1" === i) s.outlinesFormat = "truetype", r = z.getUShort(o, 4), a = Nn(o, r);
                    else if ("OTTO" === i) s.outlinesFormat = "cff", r = z.getUShort(o, 4), a = Nn(o, r);
                    else {
                        if ("wOFF" !== i) throw new Error("Unsupported OpenType signature " + i);
                        {
                            const e = z.getTag(o, 4);
                            if (e === String.fromCharCode(0, 1, 0, 0)) s.outlinesFormat = "truetype";
                            else {
                                if ("OTTO" !== e) throw new Error("Unsupported OpenType flavor " + i);
                                s.outlinesFormat = "cff";
                            }
                            r = z.getUShort(o, 12), a = function(e, t) {
                                const n = [];
                                let s = 44;
                                for(let o = 0; o < t; o += 1){
                                    const t = z.getTag(e, s), o = z.getULong(e, s + 4), r = z.getULong(e, s + 8), a = z.getULong(e, s + 12);
                                    let i;
                                    i = r < a && "WOFF", n.push({
                                        tag: t,
                                        offset: o,
                                        compression: i,
                                        compressedLength: r,
                                        length: a
                                    }), s += 20;
                                }
                                return n;
                            }(o, r);
                        }
                    }
                    let l, u, c, p, f, h, d, g, m, y, v;
                    for(let e = 0; e < r; e += 1){
                        const r = a[e];
                        let i;
                        switch(r.tag){
                            case "cmap":
                                i = Fn(o, r), s.tables.cmap = q(i.data, i.offset), s.encoding = new J(s.tables.cmap);
                                break;
                            case "cvt ":
                                i = Fn(o, r), v = new z.Parser(i.data, i.offset), s.tables.cvt = v.parseShortList(r.length / 2);
                                break;
                            case "fvar":
                                u = r;
                                break;
                            case "fpgm":
                                i = Fn(o, r), v = new z.Parser(i.data, i.offset), s.tables.fpgm = v.parseByteList(r.length);
                                break;
                            case "head":
                                i = Fn(o, r), s.tables.head = Ce(i.data, i.offset), s.unitsPerEm = s.tables.head.unitsPerEm, t = s.tables.head.indexToLocFormat;
                                break;
                            case "hhea":
                                i = Fn(o, r), s.tables.hhea = Me(i.data, i.offset), s.ascender = s.tables.hhea.ascender, s.descender = s.tables.hhea.descender, s.numberOfHMetrics = s.tables.hhea.numberOfHMetrics;
                                break;
                            case "hmtx":
                                h = r;
                                break;
                            case "ltag":
                                i = Fn(o, r), n = Fe(i.data, i.offset);
                                break;
                            case "maxp":
                                i = Fn(o, r), s.tables.maxp = _e(i.data, i.offset), s.numGlyphs = s.tables.maxp.numGlyphs;
                                break;
                            case "name":
                                m = r;
                                break;
                            case "OS/2":
                                i = Fn(o, r), s.tables.os2 = st(i.data, i.offset);
                                break;
                            case "post":
                                i = Fn(o, r), s.tables.post = at(i.data, i.offset), s.glyphNames = new $(s.tables.post);
                                break;
                            case "prep":
                                i = Fn(o, r), v = new z.Parser(i.data, i.offset), s.tables.prep = v.parseByteList(r.length);
                                break;
                            case "glyf":
                                c = r;
                                break;
                            case "loca":
                                g = r;
                                break;
                            case "CFF ":
                                l = r;
                                break;
                            case "kern":
                                d = r;
                                break;
                            case "GPOS":
                                p = r;
                                break;
                            case "GSUB":
                                f = r;
                                break;
                            case "meta":
                                y = r;
                        }
                    }
                    const b = Fn(o, m);
                    if (s.tables.name = et(b.data, b.offset, n), s.names = s.tables.name, c && g) {
                        const e = 0 === t, n = Fn(o, g), r = Pn(n.data, n.offset, s.numGlyphs, e), a = Fn(o, c);
                        s.glyphs = ae.parse(a.data, a.offset, r, s);
                    } else {
                        if (!l) throw new Error("Font doesn't contain TrueType or CFF outlines.");
                        {
                            const e = Fn(o, l);
                            Le(e.data, e.offset, s);
                        }
                    }
                    const x = Fn(o, h);
                    if (Ae(x.data, x.offset, s.numberOfHMetrics, s.numGlyphs, s.glyphs), function(e) {
                        let t;
                        const n = e.tables.cmap.glyphIndexMap, s = Object.keys(n);
                        for(let o = 0; o < s.length; o += 1){
                            const r = s[o], a = n[r];
                            t = e.glyphs.get(a), t.addUnicode(parseInt(r));
                        }
                        for(let n = 0; n < e.glyphs.length; n += 1)t = e.glyphs.get(n), e.cffEncoding ? e.isCIDFont ? t.name = "gid" + n : t.name = e.cffEncoding.charset[n] : e.glyphNames.names && (t.name = e.glyphNames.glyphIndexToName(n));
                    }(s), d) {
                        const e = Fn(o, d);
                        s.kerningPairs = Mn(e.data, e.offset);
                    } else s.kerningPairs = {};
                    if (p) {
                        const e = Fn(o, p);
                        s.tables.gpos = Dn(e.data, e.offset);
                    }
                    if (f) {
                        const e = Fn(o, f);
                        s.tables.gsub = pt(e.data, e.offset);
                    }
                    if (u) {
                        const e = Fn(o, u);
                        s.tables.fvar = Bn(e.data, e.offset, s.names);
                    }
                    if (y) {
                        const e = Fn(o, y);
                        s.tables.meta = ht(e.data, e.offset), s.metas = s.tables.meta;
                    }
                    return s;
                }
                function Hn(e, t) {
                    ("undefined" == typeof window ? An : Gn)(e, function(e, n) {
                        if (e) return t(e);
                        let s;
                        try {
                            s = _n(n);
                        } catch (e) {
                            return t(e, null);
                        }
                        return t(null, s);
                    });
                }
                function zn(e) {
                    return _n(Dt(n(89).readFileSync(e)));
                }
            },
            896: (e, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                const s = n(978);
                class o extends s.Writable {
                    constructor(){
                        super(...arguments), this.offset = 0, this._waiters = [], this._closed = !1;
                    }
                    _write(e, t, n) {
                        let s = 0;
                        const o = ()=>{
                            for(; this._waiters.length > 0;){
                                const t = this._waiters[0];
                                if (this._buffer) {
                                    const o = this._buffer.size - this._buffer.offset;
                                    if (!(o + e.length >= t.size)) {
                                        if (!t.skip) {
                                            const t = Buffer.alloc(o + e.length);
                                            this._buffer.buf.copy(t, 0, this._buffer.offset, this._buffer.size), e.copy(t, o, 0, e.length), this._buffer.buf = t;
                                        }
                                        this._buffer.offset = 0, this._buffer.size = o + e.length, n();
                                        break;
                                    }
                                    if (t.skip) this._buffer = void 0, t.resolve();
                                    else {
                                        const n = Math.min(o, t.size), s = Buffer.alloc(t.size);
                                        this._buffer.buf.copy(s, 0, this._buffer.offset, this._buffer.offset + n), e.copy(s, n, 0, t.size - n), t.resolve(s);
                                    }
                                    if (this.offset += t.size, this._waiters.shift(), this._buffer = void 0, o + e.length === t.size) {
                                        n();
                                        break;
                                    }
                                    s += t.size - o;
                                } else {
                                    if (!(e.length - s >= t.size)) {
                                        this._buffer = {
                                            buf: t.skip ? void 0 : e.slice(s),
                                            offset: 0,
                                            size: e.length - s
                                        }, s = e.length, n();
                                        break;
                                    }
                                    if (t.skip ? t.resolve() : t.resolve(e.slice(s, s + t.size)), this.offset += t.size, this._waiters.shift(), s += t.size, e.length === s) {
                                        n();
                                        break;
                                    }
                                }
                            }
                            this._processTrigger = e.length - s > 0 ? o : void 0;
                        };
                        o();
                    }
                    _destroy(e, t) {
                        this._processTrigger = void 0;
                        for (const t of this._waiters)t.reject(e || new Error("stream destroyed"));
                        this._waiters = [], this._closed = !0;
                    }
                    _final(e) {
                        this._processTrigger = void 0;
                        for (const e of this._waiters)e.reject(new Error("not enough data in stream"));
                        this._waiters = [], this._closed = !0;
                    }
                    read(e) {
                        return new Promise((t, n)=>{
                            this._closed && n(new Error("stream is closed")), this._waiters.push({
                                resolve: t,
                                reject: n,
                                size: e,
                                skip: !1
                            }), this._processTrigger && this._processTrigger();
                        });
                    }
                    skip(e) {
                        return new Promise((t, n)=>{
                            this._closed && n(new Error("stream is closed")), this._waiters.push({
                                resolve: t,
                                reject: n,
                                size: e,
                                skip: !0
                            }), this._processTrigger && this._processTrigger();
                        });
                    }
                }
                function r() {
                    return new o;
                }
                e.exports = Object.assign(r, {
                    default: r
                }), t.default = r;
            },
            311: (e)=>{
                function t() {
                    this.table = new Uint16Array(16), this.trans = new Uint16Array(288);
                }
                function n(e, n) {
                    this.source = e, this.sourceIndex = 0, this.tag = 0, this.bitcount = 0, this.dest = n, this.destLen = 0, this.ltree = new t, this.dtree = new t;
                }
                var s = new t, o = new t, r = new Uint8Array(30), a = new Uint16Array(30), i = new Uint8Array(30), l = new Uint16Array(30), u = new Uint8Array([
                    16,
                    17,
                    18,
                    0,
                    8,
                    7,
                    9,
                    6,
                    10,
                    5,
                    11,
                    4,
                    12,
                    3,
                    13,
                    2,
                    14,
                    1,
                    15
                ]), c = new t, p = new Uint8Array(320);
                function f(e, t, n, s) {
                    var o, r;
                    for(o = 0; o < n; ++o)e[o] = 0;
                    for(o = 0; o < 30 - n; ++o)e[o + n] = o / n | 0;
                    for(r = s, o = 0; o < 30; ++o)t[o] = r, r += 1 << e[o];
                }
                var h = new Uint16Array(16);
                function d(e, t, n, s) {
                    var o, r;
                    for(o = 0; o < 16; ++o)e.table[o] = 0;
                    for(o = 0; o < s; ++o)e.table[t[n + o]]++;
                    for(e.table[0] = 0, r = 0, o = 0; o < 16; ++o)h[o] = r, r += e.table[o];
                    for(o = 0; o < s; ++o)t[n + o] && (e.trans[h[t[n + o]]++] = o);
                }
                function g(e) {
                    e.bitcount-- || (e.tag = e.source[e.sourceIndex++], e.bitcount = 7);
                    var t = 1 & e.tag;
                    return e.tag >>>= 1, t;
                }
                function m(e, t, n) {
                    if (!t) return n;
                    for(; e.bitcount < 24;)e.tag |= e.source[e.sourceIndex++] << e.bitcount, e.bitcount += 8;
                    var s = e.tag & 65535 >>> 16 - t;
                    return e.tag >>>= t, e.bitcount -= t, s + n;
                }
                function y(e, t) {
                    for(; e.bitcount < 24;)e.tag |= e.source[e.sourceIndex++] << e.bitcount, e.bitcount += 8;
                    var n = 0, s = 0, o = 0, r = e.tag;
                    do s = 2 * s + (1 & r), r >>>= 1, ++o, n += t.table[o], s -= t.table[o];
                    while (s >= 0);
                    return e.tag = r, e.bitcount -= o, t.trans[n + s];
                }
                function v(e, t, n) {
                    var s, o, r, a, i, l;
                    for(s = m(e, 5, 257), o = m(e, 5, 1), r = m(e, 4, 4), a = 0; a < 19; ++a)p[a] = 0;
                    for(a = 0; a < r; ++a){
                        var f = m(e, 3, 0);
                        p[u[a]] = f;
                    }
                    for(d(c, p, 0, 19), i = 0; i < s + o;){
                        var h = y(e, c);
                        switch(h){
                            case 16:
                                var g = p[i - 1];
                                for(l = m(e, 2, 3); l; --l)p[i++] = g;
                                break;
                            case 17:
                                for(l = m(e, 3, 3); l; --l)p[i++] = 0;
                                break;
                            case 18:
                                for(l = m(e, 7, 11); l; --l)p[i++] = 0;
                                break;
                            default:
                                p[i++] = h;
                        }
                    }
                    d(t, p, 0, s), d(n, p, s, o);
                }
                function b(e, t, n) {
                    for(;;){
                        var s, o, u, c, p = y(e, t);
                        if (256 === p) return 0;
                        if (p < 256) e.dest[e.destLen++] = p;
                        else for(s = m(e, r[p -= 257], a[p]), o = y(e, n), c = u = e.destLen - m(e, i[o], l[o]); c < u + s; ++c)e.dest[e.destLen++] = e.dest[c];
                    }
                }
                function x(e) {
                    for(var t, n; e.bitcount > 8;)e.sourceIndex--, e.bitcount -= 8;
                    if ((t = 256 * (t = e.source[e.sourceIndex + 1]) + e.source[e.sourceIndex]) !== (65535 & ~(256 * e.source[e.sourceIndex + 3] + e.source[e.sourceIndex + 2]))) return -3;
                    for(e.sourceIndex += 4, n = t; n; --n)e.dest[e.destLen++] = e.source[e.sourceIndex++];
                    return e.bitcount = 0, 0;
                }
                !function(e, t) {
                    var n;
                    for(n = 0; n < 7; ++n)e.table[n] = 0;
                    for(e.table[7] = 24, e.table[8] = 152, e.table[9] = 112, n = 0; n < 24; ++n)e.trans[n] = 256 + n;
                    for(n = 0; n < 144; ++n)e.trans[24 + n] = n;
                    for(n = 0; n < 8; ++n)e.trans[168 + n] = 280 + n;
                    for(n = 0; n < 112; ++n)e.trans[176 + n] = 144 + n;
                    for(n = 0; n < 5; ++n)t.table[n] = 0;
                    for(t.table[5] = 32, n = 0; n < 32; ++n)t.trans[n] = n;
                }(s, o), f(r, a, 4, 3), f(i, l, 2, 1), r[28] = 0, a[28] = 258, e.exports = function(e, t) {
                    var r, a, i = new n(e, t);
                    do {
                        switch(r = g(i), m(i, 2, 0)){
                            case 0:
                                a = x(i);
                                break;
                            case 1:
                                a = b(i, s, o);
                                break;
                            case 2:
                                v(i, i.ltree, i.dtree), a = b(i, i.ltree, i.dtree);
                                break;
                            default:
                                a = -3;
                        }
                        if (0 !== a) throw new Error("Data error");
                    }while (!r);
                    return i.destLen < i.dest.length ? "function" == typeof i.dest.slice ? i.dest.slice(0, i.destLen) : i.dest.subarray(0, i.destLen) : i.dest;
                };
            },
            371: (e)=>{
                "use strict";
                e.exports = function(e) {
                    e.prototype[Symbol.iterator] = function*() {
                        for(let e = this.head; e; e = e.next)yield e.value;
                    };
                };
            },
            411: (e, t, n)=>{
                "use strict";
                function s(e) {
                    var t = this;
                    if (t instanceof s || (t = new s), t.tail = null, t.head = null, t.length = 0, e && "function" == typeof e.forEach) e.forEach(function(e) {
                        t.push(e);
                    });
                    else if (arguments.length > 0) for(var n = 0, o = arguments.length; n < o; n++)t.push(arguments[n]);
                    return t;
                }
                function o(e, t, n) {
                    var s = t === e.head ? new i(n, null, t, e) : new i(n, t, t.next, e);
                    return null === s.next && (e.tail = s), null === s.prev && (e.head = s), e.length++, s;
                }
                function r(e, t) {
                    e.tail = new i(t, e.tail, null, e), e.head || (e.head = e.tail), e.length++;
                }
                function a(e, t) {
                    e.head = new i(t, null, e.head, e), e.tail || (e.tail = e.head), e.length++;
                }
                function i(e, t, n, s) {
                    if (!(this instanceof i)) return new i(e, t, n, s);
                    this.list = s, this.value = e, t ? (t.next = this, this.prev = t) : this.prev = null, n ? (n.prev = this, this.next = n) : this.next = null;
                }
                e.exports = s, s.Node = i, s.create = s, s.prototype.removeNode = function(e) {
                    if (e.list !== this) throw new Error("removing node which does not belong to this list");
                    var t = e.next, n = e.prev;
                    return t && (t.prev = n), n && (n.next = t), e === this.head && (this.head = t), e === this.tail && (this.tail = n), e.list.length--, e.next = null, e.prev = null, e.list = null, t;
                }, s.prototype.unshiftNode = function(e) {
                    if (e !== this.head) {
                        e.list && e.list.removeNode(e);
                        var t = this.head;
                        e.list = this, e.next = t, t && (t.prev = e), this.head = e, this.tail || (this.tail = e), this.length++;
                    }
                }, s.prototype.pushNode = function(e) {
                    if (e !== this.tail) {
                        e.list && e.list.removeNode(e);
                        var t = this.tail;
                        e.list = this, e.prev = t, t && (t.next = e), this.tail = e, this.head || (this.head = e), this.length++;
                    }
                }, s.prototype.push = function() {
                    for(var e = 0, t = arguments.length; e < t; e++)r(this, arguments[e]);
                    return this.length;
                }, s.prototype.unshift = function() {
                    for(var e = 0, t = arguments.length; e < t; e++)a(this, arguments[e]);
                    return this.length;
                }, s.prototype.pop = function() {
                    if (this.tail) {
                        var e = this.tail.value;
                        return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, e;
                    }
                }, s.prototype.shift = function() {
                    if (this.head) {
                        var e = this.head.value;
                        return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, e;
                    }
                }, s.prototype.forEach = function(e, t) {
                    t = t || this;
                    for(var n = this.head, s = 0; null !== n; s++)e.call(t, n.value, s, this), n = n.next;
                }, s.prototype.forEachReverse = function(e, t) {
                    t = t || this;
                    for(var n = this.tail, s = this.length - 1; null !== n; s--)e.call(t, n.value, s, this), n = n.prev;
                }, s.prototype.get = function(e) {
                    for(var t = 0, n = this.head; null !== n && t < e; t++)n = n.next;
                    if (t === e && null !== n) return n.value;
                }, s.prototype.getReverse = function(e) {
                    for(var t = 0, n = this.tail; null !== n && t < e; t++)n = n.prev;
                    if (t === e && null !== n) return n.value;
                }, s.prototype.map = function(e, t) {
                    t = t || this;
                    for(var n = new s, o = this.head; null !== o;)n.push(e.call(t, o.value, this)), o = o.next;
                    return n;
                }, s.prototype.mapReverse = function(e, t) {
                    t = t || this;
                    for(var n = new s, o = this.tail; null !== o;)n.push(e.call(t, o.value, this)), o = o.prev;
                    return n;
                }, s.prototype.reduce = function(e, t) {
                    var n, s = this.head;
                    if (arguments.length > 1) n = t;
                    else {
                        if (!this.head) throw new TypeError("Reduce of empty list with no initial value");
                        s = this.head.next, n = this.head.value;
                    }
                    for(var o = 0; null !== s; o++)n = e(n, s.value, o), s = s.next;
                    return n;
                }, s.prototype.reduceReverse = function(e, t) {
                    var n, s = this.tail;
                    if (arguments.length > 1) n = t;
                    else {
                        if (!this.tail) throw new TypeError("Reduce of empty list with no initial value");
                        s = this.tail.prev, n = this.tail.value;
                    }
                    for(var o = this.length - 1; null !== s; o--)n = e(n, s.value, o), s = s.prev;
                    return n;
                }, s.prototype.toArray = function() {
                    for(var e = new Array(this.length), t = 0, n = this.head; null !== n; t++)e[t] = n.value, n = n.next;
                    return e;
                }, s.prototype.toArrayReverse = function() {
                    for(var e = new Array(this.length), t = 0, n = this.tail; null !== n; t++)e[t] = n.value, n = n.prev;
                    return e;
                }, s.prototype.slice = function(e, t) {
                    (t = t || this.length) < 0 && (t += this.length), (e = e || 0) < 0 && (e += this.length);
                    var n = new s;
                    if (t < e || t < 0) return n;
                    e < 0 && (e = 0), t > this.length && (t = this.length);
                    for(var o = 0, r = this.head; null !== r && o < e; o++)r = r.next;
                    for(; null !== r && o < t; o++, r = r.next)n.push(r.value);
                    return n;
                }, s.prototype.sliceReverse = function(e, t) {
                    (t = t || this.length) < 0 && (t += this.length), (e = e || 0) < 0 && (e += this.length);
                    var n = new s;
                    if (t < e || t < 0) return n;
                    e < 0 && (e = 0), t > this.length && (t = this.length);
                    for(var o = this.length, r = this.tail; null !== r && o > t; o--)r = r.prev;
                    for(; null !== r && o > e; o--, r = r.prev)n.push(r.value);
                    return n;
                }, s.prototype.splice = function(e, t, ...n) {
                    e > this.length && (e = this.length - 1), e < 0 && (e = this.length + e);
                    for(var s = 0, r = this.head; null !== r && s < e; s++)r = r.next;
                    var a = [];
                    for(s = 0; r && s < t; s++)a.push(r.value), r = this.removeNode(r);
                    for(null === r && (r = this.tail), r !== this.head && r !== this.tail && (r = r.prev), s = 0; s < n.length; s++)r = o(this, r, n[s]);
                    return a;
                }, s.prototype.reverse = function() {
                    for(var e = this.head, t = this.tail, n = e; null !== n; n = n.prev){
                        var s = n.prev;
                        n.prev = n.next, n.next = s;
                    }
                    return this.head = t, this.tail = e, this;
                };
                try {
                    n(371)(s);
                } catch (e) {}
            },
            109: (e, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                const s = n(98), o = n(104);
                let r;
                t.default = async function(e, t) {
                    var n, i;
                    if (!r) {
                        if ("undefined" != typeof navigator && "fonts" in navigator) {
                            try {
                                const e = await (null === (i = (n = navigator.permissions).request) || void 0 === i ? void 0 : i.call(n, {
                                    name: "local-fonts"
                                }));
                                if (e && "granted" !== e.state) throw new Error("Permission to access local fonts not granted.");
                            } catch (e) {
                                if ("TypeError" !== e.name) throw e;
                            }
                            const e = {};
                            try {
                                const t = await navigator.fonts.query();
                                for (const n of t)e.hasOwnProperty(n.family) || (e[n.family] = []), e[n.family].push(n);
                                r = Promise.resolve(e);
                            } catch (e) {
                                console.error(e.name, e.message);
                            }
                        } else if ("object" != typeof process && "queryLocalFonts" in window) {
                            const e = {};
                            try {
                                const t = await window.queryLocalFonts();
                                for (const n of t)e.hasOwnProperty(n.family) || (e[n.family] = []), e[n.family].push(n);
                                r = Promise.resolve(e);
                            } catch (e) {
                                console.error(e.name, e.message);
                            }
                        }
                        r || (r = Promise.resolve({}));
                    }
                    const l = await r;
                    for (const n of (0, o.default)(e)){
                        if (a.includes(n)) return;
                        if (l.hasOwnProperty(n) && l[n].length > 0) {
                            const e = l[n][0];
                            if ("blob" in e) {
                                const n = await e.blob(), o = await n.arrayBuffer();
                                return (0, s.loadBuffer)(o, {
                                    cacheSize: t
                                });
                            }
                            return;
                        }
                    }
                };
                const a = [
                    "serif",
                    "sans-serif",
                    "cursive",
                    "fantasy",
                    "monospace",
                    "system-ui",
                    "emoji",
                    "math",
                    "fangsong"
                ];
            },
            833: (e, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.enableLigatures = void 0;
                const s = n(109);
                t.enableLigatures = function(e, t = []) {
                    let n, o, r, a = 0;
                    return e.registerCharacterJoiner((i)=>{
                        const l = e.options.fontFamily;
                        if (l && (0 === a || n !== l)) {
                            o = void 0, a = 1, n = l;
                            const t = n;
                            (0, s.default)(t, 1e5).then((n)=>{
                                t === e.options.fontFamily && (a = 2, o = n, n && e.refresh(0, e.rows - 1));
                            }).catch((n)=>{
                                t === e.options.fontFamily && (a = 3, "debug" === e.options.logLevel && console.debug(r, new Error("Failure while loading font")), o = void 0, r = n);
                            });
                        }
                        return o && 2 === a ? o.findLigatureRanges(i).map((e)=>[
                                e[0],
                                e[1]
                            ]) : function(e, t) {
                            const n = [];
                            for(let s = 0; s < e.length; s++)for(let o = 0; o < t.length; o++)if (e.startsWith(t[o], s)) {
                                n.push([
                                    s,
                                    s + t[o].length
                                ]), s += t[o].length - 1;
                                break;
                            }
                            return n;
                        }(i, t);
                    });
                };
            },
            104: (e, t)=>{
                "use strict";
                function n(e, t) {
                    let n = "", s = !1;
                    for(; e.offset < e.input.length;){
                        const r = e.input[e.offset++];
                        if (s) /[\dA-Fa-f]/.test(r) ? (e.offset--, n += o(e)) : "\n" !== r && (n += r), s = !1;
                        else switch(r){
                            case t:
                                return n;
                            case "\\":
                                s = !0;
                                break;
                            default:
                                n += r;
                        }
                    }
                    throw new Error("Unterminated string");
                }
                function s(e) {
                    let t = "", n = !1;
                    for(; e.offset < e.input.length;){
                        const s = e.input[e.offset++];
                        if (n) /[\dA-Fa-f]/.test(s) ? (e.offset--, t += o(e)) : t += s, n = !1;
                        else switch(s){
                            case "\\":
                                n = !0;
                                break;
                            case ",":
                                return t;
                            default:
                                /\s/.test(s) ? t.endsWith(" ") || (t += " ") : t += s;
                        }
                    }
                    return t;
                }
                function o(e) {
                    let t = "";
                    for(; e.offset < e.input.length;){
                        const n = e.input[e.offset++];
                        if (/\s/.test(n)) return r(t);
                        if (t.length >= 6 || !/[\dA-Fa-f]/.test(n)) return e.offset--, r(t);
                        t += n;
                    }
                    return r(t);
                }
                function r(e) {
                    return String.fromCodePoint(parseInt(e, 16));
                }
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e) {
                    if ("string" != typeof e) throw new Error("Font family must be a string");
                    const t = {
                        input: e,
                        offset: 0
                    }, o = [];
                    let r = "";
                    for(; t.offset < t.input.length;){
                        const e = t.input[t.offset++];
                        switch(e){
                            case "'":
                            case '"':
                                r += n(t, e);
                                break;
                            case ",":
                                o.push(r), r = "";
                                break;
                            default:
                                /\s/.test(e) || (t.offset--, r += s(t), o.push(r), r = "");
                        }
                    }
                    return o;
                };
            },
            89: (t)=>{
                "use strict";
                t.exports = e;
            },
            56: (e)=>{
                "use strict";
                e.exports = t;
            },
            978: (e)=>{
                "use strict";
                e.exports = s;
            },
            269: (e)=>{
                "use strict";
                e.exports = n;
            },
            82: ()=>{},
            456: ()=>{}
        }, r = {};
        function a(e) {
            var t = r[e];
            if (void 0 !== t) return t.exports;
            var n = r[e] = {
                exports: {}
            };
            return o[e].call(n.exports, n, n.exports, a), n.exports;
        }
        a.n = (e)=>{
            var t = e && e.__esModule ? ()=>e.default : ()=>e;
            return a.d(t, {
                a: t
            }), t;
        }, a.d = (e, t)=>{
            for(var n in t)a.o(t, n) && !a.o(e, n) && Object.defineProperty(e, n, {
                enumerable: !0,
                get: t[n]
            });
        }, a.o = (e, t)=>Object.prototype.hasOwnProperty.call(e, t), a.r = (e)=>{
            "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
                value: "Module"
            }), Object.defineProperty(e, "__esModule", {
                value: !0
            });
        };
        var i = {};
        return (()=>{
            "use strict";
            var e = i;
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.LigaturesAddon = void 0;
            const t = a(833);
            e.LigaturesAddon = class {
                constructor(e){
                    this._fallbackLigatures = ((null == e ? void 0 : e.fallbackLigatures) || [
                        "<--",
                        "<---",
                        "<<-",
                        "<-",
                        "->",
                        "->>",
                        "-->",
                        "--->",
                        "<==",
                        "<===",
                        "<<=",
                        "<=",
                        "=>",
                        "=>>",
                        "==>",
                        "===>",
                        ">=",
                        ">>=",
                        "<->",
                        "<-->",
                        "<--->",
                        "<---->",
                        "<=>",
                        "<==>",
                        "<===>",
                        "<====>",
                        "-------->",
                        "<~~",
                        "<~",
                        "~>",
                        "~~>",
                        "::",
                        ":::",
                        "==",
                        "!=",
                        "===",
                        "!==",
                        ":=",
                        ":-",
                        ":+",
                        "<*",
                        "<*>",
                        "*>",
                        "<|",
                        "<|>",
                        "|>",
                        "+:",
                        "-:",
                        "=:",
                        ":>",
                        "++",
                        "+++",
                        "<!--",
                        "<!---",
                        "<***>"
                    ]).sort((e, t)=>t.length - e.length);
                }
                activate(e) {
                    this._terminal = e, this._characterJoinerId = (0, t.enableLigatures)(e, this._fallbackLigatures);
                }
                dispose() {
                    var e;
                    void 0 !== this._characterJoinerId && (null === (e = this._terminal) || void 0 === e || e.deregisterCharacterJoiner(this._characterJoinerId), this._characterJoinerId = void 0);
                }
            };
        })(), i;
    })();
});

},{"a4c943ac8d0ae08e":"fCgem","d50bdfad8e7bc7fb":"d5jf4","62aeebf80b25c1cc":"jhUEF","fc9f6822e334ea8e":"loE3o","74a0c9acd25cd8f1":"cxohQ","5c75180993035de":"j77ns"}],"fCgem":[function(require,module,exports) {
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ /* eslint-disable no-proto */ "use strict";
const base64 = require("9c62938f1dccc73c");
const ieee754 = require("aceacb6a4531a9d2");
const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" // eslint-disable-line dot-notation
 ? Symbol["for"]("nodejs.util.inspect.custom") // eslint-disable-line dot-notation
 : null;
exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
const K_MAX_LENGTH = 0x7fffffff;
exports.kMaxLength = K_MAX_LENGTH;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */ Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
function typedArraySupport() {
    // Can typed array instances can be augmented?
    try {
        const arr = new Uint8Array(1);
        const proto = {
            foo: function() {
                return 42;
            }
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
    } catch (e) {
        return false;
    }
}
Object.defineProperty(Buffer.prototype, "parent", {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.buffer;
    }
});
Object.defineProperty(Buffer.prototype, "offset", {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.byteOffset;
    }
});
function createBuffer(length) {
    if (length > K_MAX_LENGTH) throw new RangeError('The value "' + length + '" is invalid for option "size"');
    // Return an augmented `Uint8Array` instance
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */ function Buffer(arg, encodingOrOffset, length) {
    // Common case.
    if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") throw new TypeError('The "string" argument must be of type string. Received type number');
        return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
}
Buffer.poolSize = 8192 // not used by this implementation
;
function from(value, encodingOrOffset, length) {
    if (typeof value === "string") return fromString(value, encodingOrOffset);
    if (ArrayBuffer.isView(value)) return fromArrayView(value);
    if (value == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof value === "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) return Buffer.from(valueOf, encodingOrOffset, length);
    const b = fromObject(value);
    if (b) return b;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") return Buffer.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/ Buffer.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
};
// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer, Uint8Array);
function assertSize(size) {
    if (typeof size !== "number") throw new TypeError('"size" argument must be of type number');
    else if (size < 0) throw new RangeError('The value "' + size + '" is invalid for option "size"');
}
function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) return createBuffer(size);
    if (fill !== undefined) // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    return createBuffer(size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/ Buffer.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
};
function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */ Buffer.allocUnsafe = function(size) {
    return allocUnsafe(size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */ Buffer.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
};
function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") encoding = "utf8";
    if (!Buffer.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
    const length = byteLength(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual);
    return buf;
}
function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for(let i = 0; i < length; i += 1)buf[i] = array[i] & 255;
    return buf;
}
function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
}
function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) throw new RangeError('"offset" is outside of buffer bounds');
    if (array.byteLength < byteOffset + (length || 0)) throw new RangeError('"length" is outside of buffer bounds');
    let buf;
    if (byteOffset === undefined && length === undefined) buf = new Uint8Array(array);
    else if (length === undefined) buf = new Uint8Array(array, byteOffset);
    else buf = new Uint8Array(array, byteOffset, length);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
function fromObject(obj) {
    if (Buffer.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) return buf;
        obj.copy(buf, 0, 0, len);
        return buf;
    }
    if (obj.length !== undefined) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) return createBuffer(0);
        return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) return fromArrayLike(obj.data);
}
function checked(length) {
    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= K_MAX_LENGTH) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    return length | 0;
}
function SlowBuffer(length) {
    if (+length != length) length = 0;
    return Buffer.alloc(+length);
}
Buffer.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
    ;
};
Buffer.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
    if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (a === b) return 0;
    let x = a.length;
    let y = b.length;
    for(let i = 0, len = Math.min(x, y); i < len; ++i)if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
Buffer.isEncoding = function isEncoding(encoding) {
    switch(String(encoding).toLowerCase()){
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return true;
        default:
            return false;
    }
};
Buffer.concat = function concat(list, length) {
    if (!Array.isArray(list)) throw new TypeError('"list" argument must be an Array of Buffers');
    if (list.length === 0) return Buffer.alloc(0);
    let i;
    if (length === undefined) {
        length = 0;
        for(i = 0; i < list.length; ++i)length += list[i].length;
    }
    const buffer = Buffer.allocUnsafe(length);
    let pos = 0;
    for(i = 0; i < list.length; ++i){
        let buf = list[i];
        if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) {
                if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
                buf.copy(buffer, pos);
            } else Uint8Array.prototype.set.call(buffer, buf, pos);
        } else if (!Buffer.isBuffer(buf)) throw new TypeError('"list" argument must be an Array of Buffers');
        else buf.copy(buffer, pos);
        pos += buf.length;
    }
    return buffer;
};
function byteLength(string, encoding) {
    if (Buffer.isBuffer(string)) return string.length;
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) return string.byteLength;
    if (typeof string !== "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    // Use a for loop to avoid recursion
    let loweredCase = false;
    for(;;)switch(encoding){
        case "ascii":
        case "latin1":
        case "binary":
            return len;
        case "utf8":
        case "utf-8":
            return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return len * 2;
        case "hex":
            return len >>> 1;
        case "base64":
            return base64ToBytes(string).length;
        default:
            if (loweredCase) return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
            ;
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
    }
}
Buffer.byteLength = byteLength;
function slowToString(encoding, start, end) {
    let loweredCase = false;
    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.
    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) start = 0;
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) return "";
    if (end === undefined || end > this.length) end = this.length;
    if (end <= 0) return "";
    // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;
    if (end <= start) return "";
    if (!encoding) encoding = "utf8";
    while(true)switch(encoding){
        case "hex":
            return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
            return utf8Slice(this, start, end);
        case "ascii":
            return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
            return latin1Slice(this, start, end);
        case "base64":
            return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return utf16leSlice(this, start, end);
        default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
    }
}
// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true;
function swap(b, n, m) {
    const i = b[n];
    b[n] = b[m];
    b[m] = i;
}
Buffer.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
    for(let i = 0; i < len; i += 2)swap(this, i, i + 1);
    return this;
};
Buffer.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
    for(let i = 0; i < len; i += 4){
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
    }
    return this;
};
Buffer.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
    for(let i = 0; i < len; i += 8){
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
    }
    return this;
};
Buffer.prototype.toString = function toString() {
    const length = this.length;
    if (length === 0) return "";
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
};
Buffer.prototype.toLocaleString = Buffer.prototype.toString;
Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
    if (this === b) return true;
    return Buffer.compare(this, b) === 0;
};
Buffer.prototype.inspect = function inspect() {
    let str = "";
    const max = exports.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max) str += " ... ";
    return "<Buffer " + str + ">";
};
if (customInspectSymbol) Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) target = Buffer.from(target, target.offset, target.byteLength);
    if (!Buffer.isBuffer(target)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    if (start === undefined) start = 0;
    if (end === undefined) end = target ? target.length : 0;
    if (thisStart === undefined) thisStart = 0;
    if (thisEnd === undefined) thisEnd = this.length;
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) throw new RangeError("out of range index");
    if (thisStart >= thisEnd && start >= end) return 0;
    if (thisStart >= thisEnd) return -1;
    if (start >= end) return 1;
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    let x = thisEnd - thisStart;
    let y = end - start;
    const len = Math.min(x, y);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for(let i = 0; i < len; ++i)if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1;
    // Normalize byteOffset
    if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff;
    else if (byteOffset < -2147483648) byteOffset = -2147483648;
    byteOffset = +byteOffset // Coerce to Number.
    ;
    if (numberIsNaN(byteOffset)) // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
    }
    // Normalize val
    if (typeof val === "string") val = Buffer.from(val, encoding);
    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (Buffer.isBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) return -1;
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
        val = val & 0xFF // Search for a byte value [0-255]
        ;
        if (typeof Uint8Array.prototype.indexOf === "function") {
            if (dir) return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            else return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
        }
        return arrayIndexOf(buffer, [
            val
        ], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) return -1;
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
        }
    }
    function read(buf, i) {
        if (indexSize === 1) return buf[i];
        else return buf.readUInt16BE(i * indexSize);
    }
    let i;
    if (dir) {
        let foundIndex = -1;
        for(i = byteOffset; i < arrLength; i++)if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
        }
    } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for(i = byteOffset; i >= 0; i--){
            let found = true;
            for(let j = 0; j < valLength; j++)if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
            }
            if (found) return i;
        }
    }
    return -1;
}
Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length) length = remaining;
    else {
        length = Number(length);
        if (length > remaining) length = remaining;
    }
    const strLen = string.length;
    if (length > strLen / 2) length = strLen / 2;
    let i;
    for(i = 0; i < length; ++i){
        const parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
    }
    return i;
}
function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
Buffer.prototype.write = function write(string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === undefined) encoding = "utf8";
        } else {
            encoding = length;
            length = undefined;
        }
    } else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    const remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) throw new RangeError("Attempt to write outside buffer bounds");
    if (!encoding) encoding = "utf8";
    let loweredCase = false;
    for(;;)switch(encoding){
        case "hex":
            return hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
            return utf8Write(this, string, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
            return asciiWrite(this, string, offset, length);
        case "base64":
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return ucs2Write(this, string, offset, length);
        default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
    }
};
Buffer.prototype.toJSON = function toJSON() {
    return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) return base64.fromByteArray(buf);
    else return base64.fromByteArray(buf.slice(start, end));
}
function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i = start;
    while(i < end){
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;
        if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch(bytesPerSequence){
                case 1:
                    if (firstByte < 0x80) codePoint = firstByte;
                    break;
                case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
                        if (tempCodePoint > 0x7F) codePoint = tempCodePoint;
                    }
                    break;
                case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
                        if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) codePoint = tempCodePoint;
                    }
                    break;
                case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
                        if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) codePoint = tempCodePoint;
                    }
            }
        }
        if (codePoint === null) {
            // we did not generate a valid codePoint so insert a
            // replacement char (U+FFFD) and advance only 1 byte
            codePoint = 0xFFFD;
            bytesPerSequence = 1;
        } else if (codePoint > 0xFFFF) {
            // encode to utf16 (surrogate pair dance)
            codePoint -= 0x10000;
            res.push(codePoint >>> 10 & 0x3FF | 0xD800);
            codePoint = 0xDC00 | codePoint & 0x3FF;
        }
        res.push(codePoint);
        i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
}
// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
const MAX_ARGUMENTS_LENGTH = 0x1000;
function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    ;
    // Decode in chunks to avoid "call stack size exceeded".
    let res = "";
    let i = 0;
    while(i < len)res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    return res;
}
function asciiSlice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for(let i = start; i < end; ++i)ret += String.fromCharCode(buf[i] & 0x7F);
    return ret;
}
function latin1Slice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for(let i = start; i < end; ++i)ret += String.fromCharCode(buf[i]);
    return ret;
}
function hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    let out = "";
    for(let i = start; i < end; ++i)out += hexSliceLookupTable[buf[i]];
    return out;
}
function utf16leSlice(buf, start, end) {
    const bytes = buf.slice(start, end);
    let res = "";
    // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
    for(let i = 0; i < bytes.length - 1; i += 2)res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    return res;
}
Buffer.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;
    if (start < 0) {
        start += len;
        if (start < 0) start = 0;
    } else if (start > len) start = len;
    if (end < 0) {
        end += len;
        if (end < 0) end = 0;
    } else if (end > len) end = len;
    if (end < start) end = start;
    const newBuf = this.subarray(start, end);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(newBuf, Buffer.prototype);
    return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */ function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
    if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
}
Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;
    return val;
};
Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let val = this[offset + --byteLength];
    let mul = 1;
    while(byteLength > 0 && (mul *= 0x100))val += this[offset + --byteLength] * mul;
    return val;
};
Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
};
Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
};
Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
};
Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};
Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const lo = first + this[++offset] * 256 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 256 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
});
Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
});
Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let i = byteLength;
    let mul = 1;
    let val = this[offset + --i];
    while(i > 0 && (mul *= 0x100))val += this[offset + --i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return this[offset];
    return (0xff - this[offset] + 1) * -1;
};
Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const val = this[offset + 4] + this[offset + 5] * 256 + this[offset + 6] * 2 ** 16 + (last << 24 // Overflow
    );
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 256 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
});
Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 + this[++offset] * 256 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + last);
});
Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
};
Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
};
Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
};
Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
};
function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
}
Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    let mul = 1;
    let i = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength;
};
Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    let i = byteLength - 1;
    let mul = 1;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength;
};
Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    this[offset] = value & 0xff;
    return offset + 1;
};
Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
    return offset + 4;
};
Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(0xffffffff));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
}
function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(0xffffffff));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
}
Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    let i = 0;
    let mul = 1;
    let sub = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    let i = byteLength - 1;
    let mul = 1;
    let sub = 0;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -128);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = value & 0xff;
    return offset + 1;
};
Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
};
Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    if (value < 0) value = 0xffffffff + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
    if (offset < 0) throw new RangeError("Index out of range");
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -340282346638528860000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
}
Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
};
Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
};
function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
}
Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
};
Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
};
// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer.isBuffer(target)) throw new TypeError("argument should be a Buffer");
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    // Copy 0 bytes; we're done
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    // Fatal error conditions
    if (targetStart < 0) throw new RangeError("targetStart out of bounds");
    if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
    if (end < 0) throw new RangeError("sourceEnd out of bounds");
    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) end = target.length - targetStart + start;
    const len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end);
    else Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    return len;
};
// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === "string") {
        if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
        } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
        }
        if (encoding !== undefined && typeof encoding !== "string") throw new TypeError("encoding must be a string");
        if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
        if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") // Fast path: If `val` fits into a single byte, use that numeric value.
            val = code;
        }
    } else if (typeof val === "number") val = val & 255;
    else if (typeof val === "boolean") val = Number(val);
    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) throw new RangeError("Out of range index");
    if (end <= start) return this;
    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;
    if (!val) val = 0;
    let i;
    if (typeof val === "number") for(i = start; i < end; ++i)this[i] = val;
    else {
        const bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
        const len = bytes.length;
        if (len === 0) throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        for(i = 0; i < end - start; ++i)this[i + start] = bytes[i % len];
    }
    return this;
};
// CUSTOM ERRORS
// =============
// Simplified versions from Node, changed for Buffer-only usage
const errors = {};
function E(sym, getMessage, Base) {
    errors[sym] = class NodeError extends Base {
        constructor(){
            super();
            Object.defineProperty(this, "message", {
                value: getMessage.apply(this, arguments),
                writable: true,
                configurable: true
            });
            // Add the error code to the name to include it in the stack trace.
            this.name = `${this.name} [${sym}]`;
            // Access the stack to generate the error message including the error code
            // from the name.
            this.stack // eslint-disable-line no-unused-expressions
            ;
            // Reset the name to the actual name.
            delete this.name;
        }
        get code() {
            return sym;
        }
        set code(value) {
            Object.defineProperty(this, "code", {
                configurable: true,
                enumerable: true,
                value,
                writable: true
            });
        }
        toString() {
            return `${this.name} [${sym}]: ${this.message}`;
        }
    };
}
E("ERR_BUFFER_OUT_OF_BOUNDS", function(name) {
    if (name) return `${name} is outside of buffer bounds`;
    return "Attempt to access memory outside buffer bounds";
}, RangeError);
E("ERR_INVALID_ARG_TYPE", function(name, actual) {
    return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
}, TypeError);
E("ERR_OUT_OF_RANGE", function(str, range, input) {
    let msg = `The value of "${str}" is out of range.`;
    let received = input;
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) received = addNumericalSeparator(String(input));
    else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) received = addNumericalSeparator(received);
        received += "n";
    }
    msg += ` It must be ${range}. Received ${received}`;
    return msg;
}, RangeError);
function addNumericalSeparator(val) {
    let res = "";
    let i = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for(; i >= start + 4; i -= 3)res = `_${val.slice(i - 3, i)}${res}`;
    return `${val.slice(0, i)}${res}`;
}
// CHECK FUNCTIONS
// ===============
function checkBounds(buf, offset, byteLength) {
    validateNumber(offset, "offset");
    if (buf[offset] === undefined || buf[offset + byteLength] === undefined) boundsError(offset, buf.length - (byteLength + 1));
}
function checkIntBI(value, min, max, buf, offset, byteLength) {
    if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength > 3) {
            if (min === 0 || min === BigInt(0)) range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;
            else range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` + `${(byteLength + 1) * 8 - 1}${n}`;
        } else range = `>= ${min}${n} and <= ${max}${n}`;
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf, offset, byteLength);
}
function validateNumber(value, name) {
    if (typeof value !== "number") throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
}
function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
    }
    if (length < 0) throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    throw new errors.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value);
}
// HELPER FUNCTIONS
// ================
const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function base64clean(str) {
    // Node takes equal signs as end of the Base64 encoding
    str = str.split("=")[0];
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = str.trim().replace(INVALID_BASE64_RE, "");
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return "";
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while(str.length % 4 !== 0)str = str + "=";
    return str;
}
function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for(let i = 0; i < length; ++i){
        codePoint = string.charCodeAt(i);
        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
            // last char was a lead
            if (!leadSurrogate) {
                // no lead yet
                if (codePoint > 0xDBFF) {
                    // unexpected trail
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                } else if (i + 1 === length) {
                    // unpaired lead
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                }
                // valid lead
                leadSurrogate = codePoint;
                continue;
            }
            // 2 leads in a row
            if (codePoint < 0xDC00) {
                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                leadSurrogate = codePoint;
                continue;
            }
            // valid surrogate pair
            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) // valid bmp char, but last char was a lead
        {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        }
        leadSurrogate = null;
        // encode utf8
        if (codePoint < 0x80) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
        } else if (codePoint < 0x800) {
            if ((units -= 2) < 0) break;
            bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x10000) {
            if ((units -= 3) < 0) break;
            bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x110000) {
            if ((units -= 4) < 0) break;
            bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else throw new Error("Invalid code point");
    }
    return bytes;
}
function asciiToBytes(str) {
    const byteArray = [];
    for(let i = 0; i < str.length; ++i)// Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
    return byteArray;
}
function utf16leToBytes(str, units) {
    let c, hi, lo;
    const byteArray = [];
    for(let i = 0; i < str.length; ++i){
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
    }
    return byteArray;
}
function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
    let i;
    for(i = 0; i < length; ++i){
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
    }
    return i;
}
// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
function numberIsNaN(obj) {
    // For IE11 support
    return obj !== obj // eslint-disable-line no-self-compare
    ;
}
// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
const hexSliceLookupTable = function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for(let i = 0; i < 16; ++i){
        const i16 = i * 16;
        for(let j = 0; j < 16; ++j)table[i16 + j] = alphabet[i] + alphabet[j];
    }
    return table;
}();
// Return not function with Error if BigInt not supported
function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
}
function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
}

},{"9c62938f1dccc73c":"eIiSV","aceacb6a4531a9d2":"cO95r"}],"eIiSV":[function(require,module,exports) {
"use strict";
exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for(var i = 0, len = code.length; i < len; ++i){
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
}
// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
    var len = b64.length;
    if (len % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    // Trim off extra bytes after placeholder bytes are found
    // See: https://github.com/beatgammit/base64-js/issues/42
    var validLen = b64.indexOf("=");
    if (validLen === -1) validLen = len;
    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
    return [
        validLen,
        placeHoldersLen
    ];
}
// base64 is 4/3 + up to two characters of the original data
function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    // if there are placeholders, only get up to the last complete 4 chars
    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i;
    for(i = 0; i < len; i += 4){
        tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
        arr[curByte++] = tmp >> 16 & 0xFF;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    return arr;
}
function tripletToBase64(num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}
function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for(var i = start; i < end; i += 3){
        tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
        output.push(tripletToBase64(tmp));
    }
    return output.join("");
}
function fromByteArray(uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
    ;
    var parts = [];
    var maxChunkLength = 16383 // must be multiple of 3
    ;
    // go through the array every three bytes, we'll deal with trailing stuff later
    for(var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength)parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
        tmp = uint8[len - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + "==");
    } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + uint8[len - 1];
        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + "=");
    }
    return parts.join("");
}

},{}],"cO95r":[function(require,module,exports) {
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ exports.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for(; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for(; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);
    if (e === 0) e = 1 - eBias;
    else if (e === eMax) return m ? NaN : (s ? -1 : 1) * Infinity;
    else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
    } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
        }
        if (e + eBias >= 1) value += rt / c;
        else value += rt * Math.pow(2, 1 - eBias);
        if (value * c >= 2) {
            e++;
            c /= 2;
        }
        if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
        } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
        } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
        }
    }
    for(; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);
    e = e << mLen | m;
    eLen += mLen;
    for(; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);
    buffer[offset + i - d] |= s * 128;
};

},{}],"d5jf4":[function(require,module,exports) {
// shim for using process in browser
var process = module.exports = {};
// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.
var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
    throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
    throw new Error("clearTimeout has not been defined");
}
(function() {
    try {
        if (typeof setTimeout === "function") cachedSetTimeout = setTimeout;
        else cachedSetTimeout = defaultSetTimout;
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === "function") cachedClearTimeout = clearTimeout;
        else cachedClearTimeout = defaultClearTimeout;
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) //normal enviroments in sane situations
    return setTimeout(fun, 0);
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) //normal enviroments in sane situations
    return clearTimeout(marker);
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
    if (!draining || !currentQueue) return;
    draining = false;
    if (currentQueue.length) queue = currentQueue.concat(queue);
    else queueIndex = -1;
    if (queue.length) drainQueue();
}
function drainQueue() {
    if (draining) return;
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while(len){
        currentQueue = queue;
        queue = [];
        while(++queueIndex < len)if (currentQueue) currentQueue[queueIndex].run();
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}
process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) for(var i = 1; i < arguments.length; i++)args[i - 1] = arguments[i];
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) runTimeout(drainQueue);
};
// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function() {
    this.fun.apply(null, this.array);
};
process.title = "browser";
process.browser = true;
process.env = {};
process.argv = [];
process.version = ""; // empty string to avoid regexp issues
process.versions = {};
function noop() {}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function(name) {
    return [];
};
process.binding = function(name) {
    throw new Error("process.binding is not supported");
};
process.cwd = function() {
    return "/";
};
process.chdir = function(dir) {
    throw new Error("process.chdir is not supported");
};
process.umask = function() {
    return 0;
};

},{}],"jhUEF":[function(require,module,exports) {
"use strict";

},{}],"loE3o":[function(require,module,exports) {
// 'path' module extracted from Node.js v8.11.1 (only the posix part)
// transplited with Babel
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
var process = require("c0743715070b1b8a");
"use strict";
function assertPath(path) {
    if (typeof path !== "string") throw new TypeError("Path must be a string. Received " + JSON.stringify(path));
}
// Resolves . and .. elements in a path with directory names
function normalizeStringPosix(path, allowAboveRoot) {
    var res = "";
    var lastSegmentLength = 0;
    var lastSlash = -1;
    var dots = 0;
    var code;
    for(var i = 0; i <= path.length; ++i){
        if (i < path.length) code = path.charCodeAt(i);
        else if (code === 47 /*/*/ ) break;
        else code = 47 /*/*/ ;
        if (code === 47 /*/*/ ) {
            if (lastSlash === i - 1 || dots === 1) ;
            else if (lastSlash !== i - 1 && dots === 2) {
                if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/  || res.charCodeAt(res.length - 2) !== 46 /*.*/ ) {
                    if (res.length > 2) {
                        var lastSlashIndex = res.lastIndexOf("/");
                        if (lastSlashIndex !== res.length - 1) {
                            if (lastSlashIndex === -1) {
                                res = "";
                                lastSegmentLength = 0;
                            } else {
                                res = res.slice(0, lastSlashIndex);
                                lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                            }
                            lastSlash = i;
                            dots = 0;
                            continue;
                        }
                    } else if (res.length === 2 || res.length === 1) {
                        res = "";
                        lastSegmentLength = 0;
                        lastSlash = i;
                        dots = 0;
                        continue;
                    }
                }
                if (allowAboveRoot) {
                    if (res.length > 0) res += "/..";
                    else res = "..";
                    lastSegmentLength = 2;
                }
            } else {
                if (res.length > 0) res += "/" + path.slice(lastSlash + 1, i);
                else res = path.slice(lastSlash + 1, i);
                lastSegmentLength = i - lastSlash - 1;
            }
            lastSlash = i;
            dots = 0;
        } else if (code === 46 /*.*/  && dots !== -1) ++dots;
        else dots = -1;
    }
    return res;
}
function _format(sep, pathObject) {
    var dir = pathObject.dir || pathObject.root;
    var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) return base;
    if (dir === pathObject.root) return dir + base;
    return dir + sep + base;
}
var posix = {
    // path.resolve([from ...], to)
    resolve: function resolve() {
        var resolvedPath = "";
        var resolvedAbsolute = false;
        var cwd;
        for(var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--){
            var path;
            if (i >= 0) path = arguments[i];
            else {
                if (cwd === undefined) cwd = process.cwd();
                path = cwd;
            }
            assertPath(path);
            // Skip empty entries
            if (path.length === 0) continue;
            resolvedPath = path + "/" + resolvedPath;
            resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/ ;
        }
        // At this point the path should be resolved to a full absolute path, but
        // handle relative paths to be safe (might happen when process.cwd() fails)
        // Normalize the path
        resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
        if (resolvedAbsolute) {
            if (resolvedPath.length > 0) return "/" + resolvedPath;
            else return "/";
        } else if (resolvedPath.length > 0) return resolvedPath;
        else return ".";
    },
    normalize: function normalize(path) {
        assertPath(path);
        if (path.length === 0) return ".";
        var isAbsolute = path.charCodeAt(0) === 47 /*/*/ ;
        var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/ ;
        // Normalize the path
        path = normalizeStringPosix(path, !isAbsolute);
        if (path.length === 0 && !isAbsolute) path = ".";
        if (path.length > 0 && trailingSeparator) path += "/";
        if (isAbsolute) return "/" + path;
        return path;
    },
    isAbsolute: function isAbsolute(path) {
        assertPath(path);
        return path.length > 0 && path.charCodeAt(0) === 47 /*/*/ ;
    },
    join: function join() {
        if (arguments.length === 0) return ".";
        var joined;
        for(var i = 0; i < arguments.length; ++i){
            var arg = arguments[i];
            assertPath(arg);
            if (arg.length > 0) {
                if (joined === undefined) joined = arg;
                else joined += "/" + arg;
            }
        }
        if (joined === undefined) return ".";
        return posix.normalize(joined);
    },
    relative: function relative(from, to) {
        assertPath(from);
        assertPath(to);
        if (from === to) return "";
        from = posix.resolve(from);
        to = posix.resolve(to);
        if (from === to) return "";
        // Trim any leading backslashes
        var fromStart = 1;
        for(; fromStart < from.length; ++fromStart){
            if (from.charCodeAt(fromStart) !== 47 /*/*/ ) break;
        }
        var fromEnd = from.length;
        var fromLen = fromEnd - fromStart;
        // Trim any leading backslashes
        var toStart = 1;
        for(; toStart < to.length; ++toStart){
            if (to.charCodeAt(toStart) !== 47 /*/*/ ) break;
        }
        var toEnd = to.length;
        var toLen = toEnd - toStart;
        // Compare paths to find the longest common path from root
        var length = fromLen < toLen ? fromLen : toLen;
        var lastCommonSep = -1;
        var i = 0;
        for(; i <= length; ++i){
            if (i === length) {
                if (toLen > length) {
                    if (to.charCodeAt(toStart + i) === 47 /*/*/ ) // We get here if `from` is the exact base path for `to`.
                    // For example: from='/foo/bar'; to='/foo/bar/baz'
                    return to.slice(toStart + i + 1);
                    else if (i === 0) // We get here if `from` is the root
                    // For example: from='/'; to='/foo'
                    return to.slice(toStart + i);
                } else if (fromLen > length) {
                    if (from.charCodeAt(fromStart + i) === 47 /*/*/ ) // We get here if `to` is the exact base path for `from`.
                    // For example: from='/foo/bar/baz'; to='/foo/bar'
                    lastCommonSep = i;
                    else if (i === 0) // We get here if `to` is the root.
                    // For example: from='/foo'; to='/'
                    lastCommonSep = 0;
                }
                break;
            }
            var fromCode = from.charCodeAt(fromStart + i);
            var toCode = to.charCodeAt(toStart + i);
            if (fromCode !== toCode) break;
            else if (fromCode === 47 /*/*/ ) lastCommonSep = i;
        }
        var out = "";
        // Generate the relative path based on the path difference between `to`
        // and `from`
        for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i)if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/ ) {
            if (out.length === 0) out += "..";
            else out += "/..";
        }
        // Lastly, append the rest of the destination (`to`) path that comes after
        // the common path parts
        if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
        else {
            toStart += lastCommonSep;
            if (to.charCodeAt(toStart) === 47 /*/*/ ) ++toStart;
            return to.slice(toStart);
        }
    },
    _makeLong: function _makeLong(path) {
        return path;
    },
    dirname: function dirname(path) {
        assertPath(path);
        if (path.length === 0) return ".";
        var code = path.charCodeAt(0);
        var hasRoot = code === 47 /*/*/ ;
        var end = -1;
        var matchedSlash = true;
        for(var i = path.length - 1; i >= 1; --i){
            code = path.charCodeAt(i);
            if (code === 47 /*/*/ ) {
                if (!matchedSlash) {
                    end = i;
                    break;
                }
            } else // We saw the first non-path separator
            matchedSlash = false;
        }
        if (end === -1) return hasRoot ? "/" : ".";
        if (hasRoot && end === 1) return "//";
        return path.slice(0, end);
    },
    basename: function basename(path, ext) {
        if (ext !== undefined && typeof ext !== "string") throw new TypeError('"ext" argument must be a string');
        assertPath(path);
        var start = 0;
        var end = -1;
        var matchedSlash = true;
        var i;
        if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
            if (ext.length === path.length && ext === path) return "";
            var extIdx = ext.length - 1;
            var firstNonSlashEnd = -1;
            for(i = path.length - 1; i >= 0; --i){
                var code = path.charCodeAt(i);
                if (code === 47 /*/*/ ) // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                {
                    if (!matchedSlash) {
                        start = i + 1;
                        break;
                    }
                } else {
                    if (firstNonSlashEnd === -1) {
                        // We saw the first non-path separator, remember this index in case
                        // we need it if the extension ends up not matching
                        matchedSlash = false;
                        firstNonSlashEnd = i + 1;
                    }
                    if (extIdx >= 0) {
                        // Try to match the explicit extension
                        if (code === ext.charCodeAt(extIdx)) {
                            if (--extIdx === -1) // We matched the extension, so mark this as the end of our path
                            // component
                            end = i;
                        } else {
                            // Extension does not match, so our result is the entire path
                            // component
                            extIdx = -1;
                            end = firstNonSlashEnd;
                        }
                    }
                }
            }
            if (start === end) end = firstNonSlashEnd;
            else if (end === -1) end = path.length;
            return path.slice(start, end);
        } else {
            for(i = path.length - 1; i >= 0; --i){
                if (path.charCodeAt(i) === 47 /*/*/ ) // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                {
                    if (!matchedSlash) {
                        start = i + 1;
                        break;
                    }
                } else if (end === -1) {
                    // We saw the first non-path separator, mark this as the end of our
                    // path component
                    matchedSlash = false;
                    end = i + 1;
                }
            }
            if (end === -1) return "";
            return path.slice(start, end);
        }
    },
    extname: function extname(path) {
        assertPath(path);
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        // Track the state of characters (if any) we see before our first dot and
        // after any path separator we find
        var preDotState = 0;
        for(var i = path.length - 1; i >= 0; --i){
            var code = path.charCodeAt(i);
            if (code === 47 /*/*/ ) {
                // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                }
                continue;
            }
            if (end === -1) {
                // We saw the first non-path separator, mark this as the end of our
                // extension
                matchedSlash = false;
                end = i + 1;
            }
            if (code === 46 /*.*/ ) {
                // If this is our first dot, mark it as the start of our extension
                if (startDot === -1) startDot = i;
                else if (preDotState !== 1) preDotState = 1;
            } else if (startDot !== -1) // We saw a non-dot and non-path separator before our dot, so we should
            // have a good chance at having a non-empty extension
            preDotState = -1;
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) return "";
        return path.slice(startDot, end);
    },
    format: function format(pathObject) {
        if (pathObject === null || typeof pathObject !== "object") throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
        return _format("/", pathObject);
    },
    parse: function parse(path) {
        assertPath(path);
        var ret = {
            root: "",
            dir: "",
            base: "",
            ext: "",
            name: ""
        };
        if (path.length === 0) return ret;
        var code = path.charCodeAt(0);
        var isAbsolute = code === 47 /*/*/ ;
        var start;
        if (isAbsolute) {
            ret.root = "/";
            start = 1;
        } else start = 0;
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var i = path.length - 1;
        // Track the state of characters (if any) we see before our first dot and
        // after any path separator we find
        var preDotState = 0;
        // Get non-dir info
        for(; i >= start; --i){
            code = path.charCodeAt(i);
            if (code === 47 /*/*/ ) {
                // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                }
                continue;
            }
            if (end === -1) {
                // We saw the first non-path separator, mark this as the end of our
                // extension
                matchedSlash = false;
                end = i + 1;
            }
            if (code === 46 /*.*/ ) {
                // If this is our first dot, mark it as the start of our extension
                if (startDot === -1) startDot = i;
                else if (preDotState !== 1) preDotState = 1;
            } else if (startDot !== -1) // We saw a non-dot and non-path separator before our dot, so we should
            // have a good chance at having a non-empty extension
            preDotState = -1;
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
            if (end !== -1) {
                if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);
                else ret.base = ret.name = path.slice(startPart, end);
            }
        } else {
            if (startPart === 0 && isAbsolute) {
                ret.name = path.slice(1, startDot);
                ret.base = path.slice(1, end);
            } else {
                ret.name = path.slice(startPart, startDot);
                ret.base = path.slice(startPart, end);
            }
            ret.ext = path.slice(startDot, end);
        }
        if (startPart > 0) ret.dir = path.slice(0, startPart - 1);
        else if (isAbsolute) ret.dir = "/";
        return ret;
    },
    sep: "/",
    delimiter: ":",
    win32: null,
    posix: null
};
posix.posix = posix;
module.exports = posix;

},{"c0743715070b1b8a":"d5jf4"}],"cxohQ":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
var process = require("bc23a3ea4a141c0b");
var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(obj) {
    var keys = Object.keys(obj);
    var descriptors = {};
    for(var i = 0; i < keys.length; i++)descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
    return descriptors;
};
var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
    if (!isString(f)) {
        var objects = [];
        for(var i = 0; i < arguments.length; i++)objects.push(inspect(arguments[i]));
        return objects.join(" ");
    }
    var i = 1;
    var args = arguments;
    var len = args.length;
    var str = String(f).replace(formatRegExp, function(x) {
        if (x === "%%") return "%";
        if (i >= len) return x;
        switch(x){
            case "%s":
                return String(args[i++]);
            case "%d":
                return Number(args[i++]);
            case "%j":
                try {
                    return JSON.stringify(args[i++]);
                } catch (_) {
                    return "[Circular]";
                }
            default:
                return x;
        }
    });
    for(var x = args[i]; i < len; x = args[++i])if (isNull(x) || !isObject(x)) str += " " + x;
    else str += " " + inspect(x);
    return str;
};
// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
    if (typeof process !== "undefined" && process.noDeprecation === true) return fn;
    // Allow for deprecating things in the process of starting up.
    if (typeof process === "undefined") return function() {
        return exports.deprecate(fn, msg).apply(this, arguments);
    };
    var warned = false;
    function deprecated() {
        if (!warned) {
            if (process.throwDeprecation) throw new Error(msg);
            else if (process.traceDeprecation) console.trace(msg);
            else console.error(msg);
            warned = true;
        }
        return fn.apply(this, arguments);
    }
    return deprecated;
};
var debugs = {};
var debugEnvRegex = /^$/;
var debugEnv;
exports.debuglog = function(set) {
    set = set.toUpperCase();
    if (!debugs[set]) {
        if (debugEnvRegex.test(set)) {
            var pid = process.pid;
            debugs[set] = function() {
                var msg = exports.format.apply(exports, arguments);
                console.error("%s %d: %s", set, pid, msg);
            };
        } else debugs[set] = function() {};
    }
    return debugs[set];
};
/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */ /* legacy: obj, showHidden, depth, colors*/ function inspect(obj, opts) {
    // default options
    var ctx = {
        seen: [],
        stylize: stylizeNoColor
    };
    // legacy...
    if (arguments.length >= 3) ctx.depth = arguments[2];
    if (arguments.length >= 4) ctx.colors = arguments[3];
    if (isBoolean(opts)) // legacy...
    ctx.showHidden = opts;
    else if (opts) // got an "options" object
    exports._extend(ctx, opts);
    // set default options
    if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
    if (isUndefined(ctx.depth)) ctx.depth = 2;
    if (isUndefined(ctx.colors)) ctx.colors = false;
    if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
    if (ctx.colors) ctx.stylize = stylizeWithColor;
    return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;
// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
    "bold": [
        1,
        22
    ],
    "italic": [
        3,
        23
    ],
    "underline": [
        4,
        24
    ],
    "inverse": [
        7,
        27
    ],
    "white": [
        37,
        39
    ],
    "grey": [
        90,
        39
    ],
    "black": [
        30,
        39
    ],
    "blue": [
        34,
        39
    ],
    "cyan": [
        36,
        39
    ],
    "green": [
        32,
        39
    ],
    "magenta": [
        35,
        39
    ],
    "red": [
        31,
        39
    ],
    "yellow": [
        33,
        39
    ]
};
// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
    "special": "cyan",
    "number": "yellow",
    "boolean": "yellow",
    "undefined": "grey",
    "null": "bold",
    "string": "green",
    "date": "magenta",
    // "name": intentionally not styling
    "regexp": "red"
};
function stylizeWithColor(str, styleType) {
    var style = inspect.styles[styleType];
    if (style) return "\x1b[" + inspect.colors[style][0] + "m" + str + "\x1b[" + inspect.colors[style][1] + "m";
    else return str;
}
function stylizeNoColor(str, styleType) {
    return str;
}
function arrayToHash(array) {
    var hash = {};
    array.forEach(function(val, idx) {
        hash[val] = true;
    });
    return hash;
}
function formatValue(ctx, value, recurseTimes) {
    // Provide a hook for user-specified inspect functions.
    // Check that value is an object with an inspect function on it
    if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
    value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.
    !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);
        if (!isString(ret)) ret = formatValue(ctx, ret, recurseTimes);
        return ret;
    }
    // Primitive types cannot have properties
    var primitive = formatPrimitive(ctx, value);
    if (primitive) return primitive;
    // Look up the keys of the object.
    var keys = Object.keys(value);
    var visibleKeys = arrayToHash(keys);
    if (ctx.showHidden) keys = Object.getOwnPropertyNames(value);
    // IE doesn't make error fields non-enumerable
    // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
    if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) return formatError(value);
    // Some type of object without properties can be shortcutted.
    if (keys.length === 0) {
        if (isFunction(value)) {
            var name = value.name ? ": " + value.name : "";
            return ctx.stylize("[Function" + name + "]", "special");
        }
        if (isRegExp(value)) return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        if (isDate(value)) return ctx.stylize(Date.prototype.toString.call(value), "date");
        if (isError(value)) return formatError(value);
    }
    var base = "", array = false, braces = [
        "{",
        "}"
    ];
    // Make Array say that they are Array
    if (isArray(value)) {
        array = true;
        braces = [
            "[",
            "]"
        ];
    }
    // Make functions say that they are functions
    if (isFunction(value)) {
        var n = value.name ? ": " + value.name : "";
        base = " [Function" + n + "]";
    }
    // Make RegExps say that they are RegExps
    if (isRegExp(value)) base = " " + RegExp.prototype.toString.call(value);
    // Make dates with properties first say the date
    if (isDate(value)) base = " " + Date.prototype.toUTCString.call(value);
    // Make error with message first say the error
    if (isError(value)) base = " " + formatError(value);
    if (keys.length === 0 && (!array || value.length == 0)) return braces[0] + base + braces[1];
    if (recurseTimes < 0) {
        if (isRegExp(value)) return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        else return ctx.stylize("[Object]", "special");
    }
    ctx.seen.push(value);
    var output;
    if (array) output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
    else output = keys.map(function(key) {
        return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
    ctx.seen.pop();
    return reduceToSingleString(output, base, braces);
}
function formatPrimitive(ctx, value) {
    if (isUndefined(value)) return ctx.stylize("undefined", "undefined");
    if (isString(value)) {
        var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return ctx.stylize(simple, "string");
    }
    if (isNumber(value)) return ctx.stylize("" + value, "number");
    if (isBoolean(value)) return ctx.stylize("" + value, "boolean");
    // For some reason typeof null is "object", so special case here.
    if (isNull(value)) return ctx.stylize("null", "null");
}
function formatError(value) {
    return "[" + Error.prototype.toString.call(value) + "]";
}
function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
    var output = [];
    for(var i = 0, l = value.length; i < l; ++i)if (hasOwnProperty(value, String(i))) output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
    else output.push("");
    keys.forEach(function(key) {
        if (!key.match(/^\d+$/)) output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
    });
    return output;
}
function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
    var name, str, desc;
    desc = Object.getOwnPropertyDescriptor(value, key) || {
        value: value[key]
    };
    if (desc.get) {
        if (desc.set) str = ctx.stylize("[Getter/Setter]", "special");
        else str = ctx.stylize("[Getter]", "special");
    } else if (desc.set) str = ctx.stylize("[Setter]", "special");
    if (!hasOwnProperty(visibleKeys, key)) name = "[" + key + "]";
    if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
            if (isNull(recurseTimes)) str = formatValue(ctx, desc.value, null);
            else str = formatValue(ctx, desc.value, recurseTimes - 1);
            if (str.indexOf("\n") > -1) {
                if (array) str = str.split("\n").map(function(line) {
                    return "  " + line;
                }).join("\n").slice(2);
                else str = "\n" + str.split("\n").map(function(line) {
                    return "   " + line;
                }).join("\n");
            }
        } else str = ctx.stylize("[Circular]", "special");
    }
    if (isUndefined(name)) {
        if (array && key.match(/^\d+$/)) return str;
        name = JSON.stringify("" + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
            name = name.slice(1, -1);
            name = ctx.stylize(name, "name");
        } else {
            name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
            name = ctx.stylize(name, "string");
        }
    }
    return name + ": " + str;
}
function reduceToSingleString(output, base, braces) {
    var numLinesEst = 0;
    var length = output.reduce(function(prev, cur) {
        numLinesEst++;
        if (cur.indexOf("\n") >= 0) numLinesEst++;
        return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    if (length > 60) return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
    return braces[0] + base + " " + output.join(", ") + " " + braces[1];
}
// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
exports.types = require("6a1c15bae847a134");
function isArray(ar) {
    return Array.isArray(ar);
}
exports.isArray = isArray;
function isBoolean(arg) {
    return typeof arg === "boolean";
}
exports.isBoolean = isBoolean;
function isNull(arg) {
    return arg === null;
}
exports.isNull = isNull;
function isNullOrUndefined(arg) {
    return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;
function isNumber(arg) {
    return typeof arg === "number";
}
exports.isNumber = isNumber;
function isString(arg) {
    return typeof arg === "string";
}
exports.isString = isString;
function isSymbol(arg) {
    return typeof arg === "symbol";
}
exports.isSymbol = isSymbol;
function isUndefined(arg) {
    return arg === void 0;
}
exports.isUndefined = isUndefined;
function isRegExp(re) {
    return isObject(re) && objectToString(re) === "[object RegExp]";
}
exports.isRegExp = isRegExp;
exports.types.isRegExp = isRegExp;
function isObject(arg) {
    return typeof arg === "object" && arg !== null;
}
exports.isObject = isObject;
function isDate(d) {
    return isObject(d) && objectToString(d) === "[object Date]";
}
exports.isDate = isDate;
exports.types.isDate = isDate;
function isError(e) {
    return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
}
exports.isError = isError;
exports.types.isNativeError = isError;
function isFunction(arg) {
    return typeof arg === "function";
}
exports.isFunction = isFunction;
function isPrimitive(arg) {
    return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
    typeof arg === "undefined";
}
exports.isPrimitive = isPrimitive;
exports.isBuffer = require("a42137cd7fc8700d");
function objectToString(o) {
    return Object.prototype.toString.call(o);
}
function pad(n) {
    return n < 10 ? "0" + n.toString(10) : n.toString(10);
}
var months = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
];
// 26 Feb 16:19:34
function timestamp() {
    var d = new Date();
    var time = [
        pad(d.getHours()),
        pad(d.getMinutes()),
        pad(d.getSeconds())
    ].join(":");
    return [
        d.getDate(),
        months[d.getMonth()],
        time
    ].join(" ");
}
// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
    console.log("%s - %s", timestamp(), exports.format.apply(exports, arguments));
};
/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */ exports.inherits = require("a792e8e3e2aa1973");
exports._extend = function(origin, add) {
    // Don't do anything if add isn't an object
    if (!add || !isObject(add)) return origin;
    var keys = Object.keys(add);
    var i = keys.length;
    while(i--)origin[keys[i]] = add[keys[i]];
    return origin;
};
function hasOwnProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
}
var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : undefined;
exports.promisify = function promisify(original) {
    if (typeof original !== "function") throw new TypeError('The "original" argument must be of type Function');
    if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
        var fn = original[kCustomPromisifiedSymbol];
        if (typeof fn !== "function") throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
            value: fn,
            enumerable: false,
            writable: false,
            configurable: true
        });
        return fn;
    }
    function fn() {
        var promiseResolve, promiseReject;
        var promise = new Promise(function(resolve, reject) {
            promiseResolve = resolve;
            promiseReject = reject;
        });
        var args = [];
        for(var i = 0; i < arguments.length; i++)args.push(arguments[i]);
        args.push(function(err, value) {
            if (err) promiseReject(err);
            else promiseResolve(value);
        });
        try {
            original.apply(this, args);
        } catch (err) {
            promiseReject(err);
        }
        return promise;
    }
    Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
    if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
        value: fn,
        enumerable: false,
        writable: false,
        configurable: true
    });
    return Object.defineProperties(fn, getOwnPropertyDescriptors(original));
};
exports.promisify.custom = kCustomPromisifiedSymbol;
function callbackifyOnRejected(reason, cb) {
    // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
    // Because `null` is a special error value in callbacks which means "no error
    // occurred", we error-wrap so the callback consumer can distinguish between
    // "the promise rejected with null" or "the promise fulfilled with undefined".
    if (!reason) {
        var newReason = new Error("Promise was rejected with a falsy value");
        newReason.reason = reason;
        reason = newReason;
    }
    return cb(reason);
}
function callbackify(original) {
    if (typeof original !== "function") throw new TypeError('The "original" argument must be of type Function');
    // We DO NOT return the promise as it gives the user a false sense that
    // the promise is actually somehow related to the callback's execution
    // and that the callback throwing will reject the promise.
    function callbackified() {
        var args = [];
        for(var i = 0; i < arguments.length; i++)args.push(arguments[i]);
        var maybeCb = args.pop();
        if (typeof maybeCb !== "function") throw new TypeError("The last argument must be of type Function");
        var self = this;
        var cb = function() {
            return maybeCb.apply(self, arguments);
        };
        // In true node style we process the callback on `nextTick` with all the
        // implications (stack, `uncaughtException`, `async_hooks`)
        original.apply(this, args).then(function(ret) {
            process.nextTick(cb.bind(null, null, ret));
        }, function(rej) {
            process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
        });
    }
    Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
    Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
    return callbackified;
}
exports.callbackify = callbackify;

},{"bc23a3ea4a141c0b":"d5jf4","6a1c15bae847a134":"bnQvf","a42137cd7fc8700d":"inNNy","a792e8e3e2aa1973":"bRL3M"}],"bnQvf":[function(require,module,exports) {
// Currently in sync with Node.js lib/internal/util/types.js
// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9
"use strict";
var isArgumentsObject = require("6b5f9ae3e436d527");
var isGeneratorFunction = require("285c2b8081bf4b68");
var whichTypedArray = require("e95b88ccd80e1671");
var isTypedArray = require("7db151546a22c2a8");
function uncurryThis(f) {
    return f.call.bind(f);
}
var BigIntSupported = typeof BigInt !== "undefined";
var SymbolSupported = typeof Symbol !== "undefined";
var ObjectToString = uncurryThis(Object.prototype.toString);
var numberValue = uncurryThis(Number.prototype.valueOf);
var stringValue = uncurryThis(String.prototype.valueOf);
var booleanValue = uncurryThis(Boolean.prototype.valueOf);
if (BigIntSupported) var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
if (SymbolSupported) var symbolValue = uncurryThis(Symbol.prototype.valueOf);
function checkBoxedPrimitive(value, prototypeValueOf) {
    if (typeof value !== "object") return false;
    try {
        prototypeValueOf(value);
        return true;
    } catch (e) {
        return false;
    }
}
exports.isArgumentsObject = isArgumentsObject;
exports.isGeneratorFunction = isGeneratorFunction;
exports.isTypedArray = isTypedArray;
// Taken from here and modified for better browser support
// https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js
function isPromise(input) {
    return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
}
exports.isPromise = isPromise;
function isArrayBufferView(value) {
    if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) return ArrayBuffer.isView(value);
    return isTypedArray(value) || isDataView(value);
}
exports.isArrayBufferView = isArrayBufferView;
function isUint8Array(value) {
    return whichTypedArray(value) === "Uint8Array";
}
exports.isUint8Array = isUint8Array;
function isUint8ClampedArray(value) {
    return whichTypedArray(value) === "Uint8ClampedArray";
}
exports.isUint8ClampedArray = isUint8ClampedArray;
function isUint16Array(value) {
    return whichTypedArray(value) === "Uint16Array";
}
exports.isUint16Array = isUint16Array;
function isUint32Array(value) {
    return whichTypedArray(value) === "Uint32Array";
}
exports.isUint32Array = isUint32Array;
function isInt8Array(value) {
    return whichTypedArray(value) === "Int8Array";
}
exports.isInt8Array = isInt8Array;
function isInt16Array(value) {
    return whichTypedArray(value) === "Int16Array";
}
exports.isInt16Array = isInt16Array;
function isInt32Array(value) {
    return whichTypedArray(value) === "Int32Array";
}
exports.isInt32Array = isInt32Array;
function isFloat32Array(value) {
    return whichTypedArray(value) === "Float32Array";
}
exports.isFloat32Array = isFloat32Array;
function isFloat64Array(value) {
    return whichTypedArray(value) === "Float64Array";
}
exports.isFloat64Array = isFloat64Array;
function isBigInt64Array(value) {
    return whichTypedArray(value) === "BigInt64Array";
}
exports.isBigInt64Array = isBigInt64Array;
function isBigUint64Array(value) {
    return whichTypedArray(value) === "BigUint64Array";
}
exports.isBigUint64Array = isBigUint64Array;
function isMapToString(value) {
    return ObjectToString(value) === "[object Map]";
}
isMapToString.working = typeof Map !== "undefined" && isMapToString(new Map());
function isMap(value) {
    if (typeof Map === "undefined") return false;
    return isMapToString.working ? isMapToString(value) : value instanceof Map;
}
exports.isMap = isMap;
function isSetToString(value) {
    return ObjectToString(value) === "[object Set]";
}
isSetToString.working = typeof Set !== "undefined" && isSetToString(new Set());
function isSet(value) {
    if (typeof Set === "undefined") return false;
    return isSetToString.working ? isSetToString(value) : value instanceof Set;
}
exports.isSet = isSet;
function isWeakMapToString(value) {
    return ObjectToString(value) === "[object WeakMap]";
}
isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(new WeakMap());
function isWeakMap(value) {
    if (typeof WeakMap === "undefined") return false;
    return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
}
exports.isWeakMap = isWeakMap;
function isWeakSetToString(value) {
    return ObjectToString(value) === "[object WeakSet]";
}
isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(new WeakSet());
function isWeakSet(value) {
    return isWeakSetToString(value);
}
exports.isWeakSet = isWeakSet;
function isArrayBufferToString(value) {
    return ObjectToString(value) === "[object ArrayBuffer]";
}
isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
function isArrayBuffer(value) {
    if (typeof ArrayBuffer === "undefined") return false;
    return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
}
exports.isArrayBuffer = isArrayBuffer;
function isDataViewToString(value) {
    return ObjectToString(value) === "[object DataView]";
}
isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
function isDataView(value) {
    if (typeof DataView === "undefined") return false;
    return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
}
exports.isDataView = isDataView;
// Store a copy of SharedArrayBuffer in case it's deleted elsewhere
var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : undefined;
function isSharedArrayBufferToString(value) {
    return ObjectToString(value) === "[object SharedArrayBuffer]";
}
function isSharedArrayBuffer(value) {
    if (typeof SharedArrayBufferCopy === "undefined") return false;
    if (typeof isSharedArrayBufferToString.working === "undefined") isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
    return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
}
exports.isSharedArrayBuffer = isSharedArrayBuffer;
function isAsyncFunction(value) {
    return ObjectToString(value) === "[object AsyncFunction]";
}
exports.isAsyncFunction = isAsyncFunction;
function isMapIterator(value) {
    return ObjectToString(value) === "[object Map Iterator]";
}
exports.isMapIterator = isMapIterator;
function isSetIterator(value) {
    return ObjectToString(value) === "[object Set Iterator]";
}
exports.isSetIterator = isSetIterator;
function isGeneratorObject(value) {
    return ObjectToString(value) === "[object Generator]";
}
exports.isGeneratorObject = isGeneratorObject;
function isWebAssemblyCompiledModule(value) {
    return ObjectToString(value) === "[object WebAssembly.Module]";
}
exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
function isNumberObject(value) {
    return checkBoxedPrimitive(value, numberValue);
}
exports.isNumberObject = isNumberObject;
function isStringObject(value) {
    return checkBoxedPrimitive(value, stringValue);
}
exports.isStringObject = isStringObject;
function isBooleanObject(value) {
    return checkBoxedPrimitive(value, booleanValue);
}
exports.isBooleanObject = isBooleanObject;
function isBigIntObject(value) {
    return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
}
exports.isBigIntObject = isBigIntObject;
function isSymbolObject(value) {
    return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
}
exports.isSymbolObject = isSymbolObject;
function isBoxedPrimitive(value) {
    return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
}
exports.isBoxedPrimitive = isBoxedPrimitive;
function isAnyArrayBuffer(value) {
    return typeof Uint8Array !== "undefined" && (isArrayBuffer(value) || isSharedArrayBuffer(value));
}
exports.isAnyArrayBuffer = isAnyArrayBuffer;
[
    "isProxy",
    "isExternal",
    "isModuleNamespaceObject"
].forEach(function(method) {
    Object.defineProperty(exports, method, {
        enumerable: false,
        value: function() {
            throw new Error(method + " is not supported in userland");
        }
    });
});

},{"6b5f9ae3e436d527":"czr4n","285c2b8081bf4b68":"2XUdn","e95b88ccd80e1671":"lVUO7","7db151546a22c2a8":"1ihkG"}],"czr4n":[function(require,module,exports) {
"use strict";
var hasToStringTag = require("e2b01ce809f132fb")();
var callBound = require("649cbf9949986a39");
var $toString = callBound("Object.prototype.toString");
var isStandardArguments = function isArguments(value) {
    if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) return false;
    return $toString(value) === "[object Arguments]";
};
var isLegacyArguments = function isArguments(value) {
    if (isStandardArguments(value)) return true;
    return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && $toString(value.callee) === "[object Function]";
};
var supportsStandardArguments = function() {
    return isStandardArguments(arguments);
}();
isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests
module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;

},{"e2b01ce809f132fb":"9LdQ9","649cbf9949986a39":"5yYiF"}],"9LdQ9":[function(require,module,exports) {
"use strict";
var hasSymbols = require("2ef89576d4959bff");
module.exports = function hasToStringTagShams() {
    return hasSymbols() && !!Symbol.toStringTag;
};

},{"2ef89576d4959bff":"euYk7"}],"euYk7":[function(require,module,exports) {
"use strict";
/* eslint complexity: [2, 18], max-statements: [2, 33] */ module.exports = function hasSymbols() {
    if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") return false;
    if (typeof Symbol.iterator === "symbol") return true;
    var obj = {};
    var sym = Symbol("test");
    var symObj = Object(sym);
    if (typeof sym === "string") return false;
    if (Object.prototype.toString.call(sym) !== "[object Symbol]") return false;
    if (Object.prototype.toString.call(symObj) !== "[object Symbol]") return false;
    // temp disabled per https://github.com/ljharb/object.assign/issues/17
    // if (sym instanceof Symbol) { return false; }
    // temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
    // if (!(symObj instanceof Symbol)) { return false; }
    // if (typeof Symbol.prototype.toString !== 'function') { return false; }
    // if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }
    var symVal = 42;
    obj[sym] = symVal;
    for(sym in obj)return false;
     // eslint-disable-line no-restricted-syntax, no-unreachable-loop
    if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) return false;
    if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) return false;
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) return false;
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) return false;
    if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) return false;
    }
    return true;
};

},{}],"5yYiF":[function(require,module,exports) {
"use strict";
var GetIntrinsic = require("8b08ecb81cf4de17");
var callBind = require("266fc50410cfc4a");
var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
module.exports = function callBoundIntrinsic(name, allowMissing) {
    var intrinsic = GetIntrinsic(name, !!allowMissing);
    if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) return callBind(intrinsic);
    return intrinsic;
};

},{"8b08ecb81cf4de17":"dZb05","266fc50410cfc4a":"bfo8D"}],"dZb05":[function(require,module,exports) {
"use strict";
var undefined;
var $SyntaxError = SyntaxError;
var $Function = Function;
var $TypeError = TypeError;
// eslint-disable-next-line consistent-return
var getEvalledConstructor = function(expressionSyntax) {
    try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
    } catch (e) {}
};
var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) try {
    $gOPD({}, "");
} catch (e) {
    $gOPD = null; // this is IE 8, which has a broken gOPD
}
var throwTypeError = function() {
    throw new $TypeError();
};
var ThrowTypeError = $gOPD ? function() {
    try {
        // eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
        arguments.callee; // IE 8 does not throw here
        return throwTypeError;
    } catch (calleeThrows) {
        try {
            // IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
            return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
            return throwTypeError;
        }
    }
}() : throwTypeError;
var hasSymbols = require("1f00f712d594ccf")();
var hasProto = require("23730654306aa64c")();
var getProto = Object.getPrototypeOf || (hasProto ? function(x) {
    return x.__proto__;
} // eslint-disable-line no-proto
 : null);
var needsEval = {};
var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined : getProto(Uint8Array);
var INTRINSICS = {
    "%AggregateError%": typeof AggregateError === "undefined" ? undefined : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined : ArrayBuffer,
    "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
    "%AsyncFromSyncIteratorPrototype%": undefined,
    "%AsyncFunction%": needsEval,
    "%AsyncGenerator%": needsEval,
    "%AsyncGeneratorFunction%": needsEval,
    "%AsyncIteratorPrototype%": needsEval,
    "%Atomics%": typeof Atomics === "undefined" ? undefined : Atomics,
    "%BigInt%": typeof BigInt === "undefined" ? undefined : BigInt,
    "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView === "undefined" ? undefined : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": Error,
    "%eval%": eval,
    "%EvalError%": EvalError,
    "%Float32Array%": typeof Float32Array === "undefined" ? undefined : Float32Array,
    "%Float64Array%": typeof Float64Array === "undefined" ? undefined : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined : FinalizationRegistry,
    "%Function%": $Function,
    "%GeneratorFunction%": needsEval,
    "%Int8Array%": typeof Int8Array === "undefined" ? undefined : Int8Array,
    "%Int16Array%": typeof Int16Array === "undefined" ? undefined : Int16Array,
    "%Int32Array%": typeof Int32Array === "undefined" ? undefined : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
    "%JSON%": typeof JSON === "object" ? JSON : undefined,
    "%Map%": typeof Map === "undefined" ? undefined : Map,
    "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": Object,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise === "undefined" ? undefined : Promise,
    "%Proxy%": typeof Proxy === "undefined" ? undefined : Proxy,
    "%RangeError%": RangeError,
    "%ReferenceError%": ReferenceError,
    "%Reflect%": typeof Reflect === "undefined" ? undefined : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set === "undefined" ? undefined : Set,
    "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined,
    "%Symbol%": hasSymbols ? Symbol : undefined,
    "%SyntaxError%": $SyntaxError,
    "%ThrowTypeError%": ThrowTypeError,
    "%TypedArray%": TypedArray,
    "%TypeError%": $TypeError,
    "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined : Uint16Array,
    "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined : Uint32Array,
    "%URIError%": URIError,
    "%WeakMap%": typeof WeakMap === "undefined" ? undefined : WeakMap,
    "%WeakRef%": typeof WeakRef === "undefined" ? undefined : WeakRef,
    "%WeakSet%": typeof WeakSet === "undefined" ? undefined : WeakSet
};
if (getProto) try {
    null.error; // eslint-disable-line no-unused-expressions
} catch (e) {
    // https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
    var errorProto = getProto(getProto(e));
    INTRINSICS["%Error.prototype%"] = errorProto;
}
var doEval = function doEval(name) {
    var value;
    if (name === "%AsyncFunction%") value = getEvalledConstructor("async function () {}");
    else if (name === "%GeneratorFunction%") value = getEvalledConstructor("function* () {}");
    else if (name === "%AsyncGeneratorFunction%") value = getEvalledConstructor("async function* () {}");
    else if (name === "%AsyncGenerator%") {
        var fn = doEval("%AsyncGeneratorFunction%");
        if (fn) value = fn.prototype;
    } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval("%AsyncGenerator%");
        if (gen && getProto) value = getProto(gen.prototype);
    }
    INTRINSICS[name] = value;
    return value;
};
var LEGACY_ALIASES = {
    "%ArrayBufferPrototype%": [
        "ArrayBuffer",
        "prototype"
    ],
    "%ArrayPrototype%": [
        "Array",
        "prototype"
    ],
    "%ArrayProto_entries%": [
        "Array",
        "prototype",
        "entries"
    ],
    "%ArrayProto_forEach%": [
        "Array",
        "prototype",
        "forEach"
    ],
    "%ArrayProto_keys%": [
        "Array",
        "prototype",
        "keys"
    ],
    "%ArrayProto_values%": [
        "Array",
        "prototype",
        "values"
    ],
    "%AsyncFunctionPrototype%": [
        "AsyncFunction",
        "prototype"
    ],
    "%AsyncGenerator%": [
        "AsyncGeneratorFunction",
        "prototype"
    ],
    "%AsyncGeneratorPrototype%": [
        "AsyncGeneratorFunction",
        "prototype",
        "prototype"
    ],
    "%BooleanPrototype%": [
        "Boolean",
        "prototype"
    ],
    "%DataViewPrototype%": [
        "DataView",
        "prototype"
    ],
    "%DatePrototype%": [
        "Date",
        "prototype"
    ],
    "%ErrorPrototype%": [
        "Error",
        "prototype"
    ],
    "%EvalErrorPrototype%": [
        "EvalError",
        "prototype"
    ],
    "%Float32ArrayPrototype%": [
        "Float32Array",
        "prototype"
    ],
    "%Float64ArrayPrototype%": [
        "Float64Array",
        "prototype"
    ],
    "%FunctionPrototype%": [
        "Function",
        "prototype"
    ],
    "%Generator%": [
        "GeneratorFunction",
        "prototype"
    ],
    "%GeneratorPrototype%": [
        "GeneratorFunction",
        "prototype",
        "prototype"
    ],
    "%Int8ArrayPrototype%": [
        "Int8Array",
        "prototype"
    ],
    "%Int16ArrayPrototype%": [
        "Int16Array",
        "prototype"
    ],
    "%Int32ArrayPrototype%": [
        "Int32Array",
        "prototype"
    ],
    "%JSONParse%": [
        "JSON",
        "parse"
    ],
    "%JSONStringify%": [
        "JSON",
        "stringify"
    ],
    "%MapPrototype%": [
        "Map",
        "prototype"
    ],
    "%NumberPrototype%": [
        "Number",
        "prototype"
    ],
    "%ObjectPrototype%": [
        "Object",
        "prototype"
    ],
    "%ObjProto_toString%": [
        "Object",
        "prototype",
        "toString"
    ],
    "%ObjProto_valueOf%": [
        "Object",
        "prototype",
        "valueOf"
    ],
    "%PromisePrototype%": [
        "Promise",
        "prototype"
    ],
    "%PromiseProto_then%": [
        "Promise",
        "prototype",
        "then"
    ],
    "%Promise_all%": [
        "Promise",
        "all"
    ],
    "%Promise_reject%": [
        "Promise",
        "reject"
    ],
    "%Promise_resolve%": [
        "Promise",
        "resolve"
    ],
    "%RangeErrorPrototype%": [
        "RangeError",
        "prototype"
    ],
    "%ReferenceErrorPrototype%": [
        "ReferenceError",
        "prototype"
    ],
    "%RegExpPrototype%": [
        "RegExp",
        "prototype"
    ],
    "%SetPrototype%": [
        "Set",
        "prototype"
    ],
    "%SharedArrayBufferPrototype%": [
        "SharedArrayBuffer",
        "prototype"
    ],
    "%StringPrototype%": [
        "String",
        "prototype"
    ],
    "%SymbolPrototype%": [
        "Symbol",
        "prototype"
    ],
    "%SyntaxErrorPrototype%": [
        "SyntaxError",
        "prototype"
    ],
    "%TypedArrayPrototype%": [
        "TypedArray",
        "prototype"
    ],
    "%TypeErrorPrototype%": [
        "TypeError",
        "prototype"
    ],
    "%Uint8ArrayPrototype%": [
        "Uint8Array",
        "prototype"
    ],
    "%Uint8ClampedArrayPrototype%": [
        "Uint8ClampedArray",
        "prototype"
    ],
    "%Uint16ArrayPrototype%": [
        "Uint16Array",
        "prototype"
    ],
    "%Uint32ArrayPrototype%": [
        "Uint32Array",
        "prototype"
    ],
    "%URIErrorPrototype%": [
        "URIError",
        "prototype"
    ],
    "%WeakMapPrototype%": [
        "WeakMap",
        "prototype"
    ],
    "%WeakSetPrototype%": [
        "WeakSet",
        "prototype"
    ]
};
var bind = require("7c5e688e48cd07b0");
var hasOwn = require("b03d0058935d00bf");
var $concat = bind.call(Function.call, Array.prototype.concat);
var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
var $replace = bind.call(Function.call, String.prototype.replace);
var $strSlice = bind.call(Function.call, String.prototype.slice);
var $exec = bind.call(Function.call, RegExp.prototype.exec);
/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */ var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */ 
var stringToPath = function stringToPath(string) {
    var first = $strSlice(string, 0, 1);
    var last = $strSlice(string, -1);
    if (first === "%" && last !== "%") throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
    else if (last === "%" && first !== "%") throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
    var result = [];
    $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
    });
    return result;
};
/* end adaptation */ var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
    var intrinsicName = name;
    var alias;
    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
    }
    if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) value = doEval(intrinsicName);
        if (typeof value === "undefined" && !allowMissing) throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        return {
            alias: alias,
            name: intrinsicName,
            value: value
        };
    }
    throw new $SyntaxError("intrinsic " + name + " does not exist!");
};
module.exports = function GetIntrinsic(name, allowMissing) {
    if (typeof name !== "string" || name.length === 0) throw new $TypeError("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof allowMissing !== "boolean") throw new $TypeError('"allowMissing" argument must be a boolean');
    if ($exec(/^%?[^%]*%?$/, name) === null) throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var parts = stringToPath(name);
    var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
    var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
    var intrinsicRealName = intrinsic.name;
    var value = intrinsic.value;
    var skipFurtherCaching = false;
    var alias = intrinsic.alias;
    if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([
            0,
            1
        ], alias));
    }
    for(var i = 1, isOwn = true; i < parts.length; i += 1){
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || last === '"' || last === "'" || last === "`") && first !== last) throw new $SyntaxError("property names with quotes must have matching quotes");
        if (part === "constructor" || !isOwn) skipFurtherCaching = true;
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) value = INTRINSICS[intrinsicRealName];
        else if (value != null) {
            if (!(part in value)) {
                if (!allowMissing) throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
                return void 0;
            }
            if ($gOPD && i + 1 >= parts.length) {
                var desc = $gOPD(value, part);
                isOwn = !!desc;
                // By convention, when a data property is converted to an accessor
                // property to emulate a data property that does not suffer from
                // the override mistake, that accessor's getter is marked with
                // an `originalValue` property. Here, when we detect this, we
                // uphold the illusion by pretending to see that original data
                // property, i.e., returning the value rather than the getter
                // itself.
                if (isOwn && "get" in desc && !("originalValue" in desc.get)) value = desc.get;
                else value = value[part];
            } else {
                isOwn = hasOwn(value, part);
                value = value[part];
            }
            if (isOwn && !skipFurtherCaching) INTRINSICS[intrinsicRealName] = value;
        }
    }
    return value;
};

},{"1f00f712d594ccf":"3dK91","23730654306aa64c":"6eZiF","7c5e688e48cd07b0":"6J4ob","b03d0058935d00bf":"ksyoO"}],"3dK91":[function(require,module,exports) {
"use strict";
var origSymbol = typeof Symbol !== "undefined" && Symbol;
var hasSymbolSham = require("3fb25678c62d2fce");
module.exports = function hasNativeSymbols() {
    if (typeof origSymbol !== "function") return false;
    if (typeof Symbol !== "function") return false;
    if (typeof origSymbol("foo") !== "symbol") return false;
    if (typeof Symbol("bar") !== "symbol") return false;
    return hasSymbolSham();
};

},{"3fb25678c62d2fce":"euYk7"}],"6eZiF":[function(require,module,exports) {
"use strict";
var test = {
    foo: {}
};
var $Object = Object;
module.exports = function hasProto() {
    return ({
        __proto__: test
    }).foo === test.foo && !(({
        __proto__: null
    }) instanceof $Object);
};

},{}],"6J4ob":[function(require,module,exports) {
"use strict";
var implementation = require("12e173b4dbaee960");
module.exports = Function.prototype.bind || implementation;

},{"12e173b4dbaee960":"jwaxQ"}],"jwaxQ":[function(require,module,exports) {
"use strict";
/* eslint no-invalid-this: 1 */ var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = "[object Function]";
module.exports = function bind(that) {
    var target = this;
    if (typeof target !== "function" || toStr.call(target) !== funcType) throw new TypeError(ERROR_MESSAGE + target);
    var args = slice.call(arguments, 1);
    var bound;
    var binder = function() {
        if (this instanceof bound) {
            var result = target.apply(this, args.concat(slice.call(arguments)));
            if (Object(result) === result) return result;
            return this;
        } else return target.apply(that, args.concat(slice.call(arguments)));
    };
    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for(var i = 0; i < boundLength; i++)boundArgs.push("$" + i);
    bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }
    return bound;
};

},{}],"ksyoO":[function(require,module,exports) {
"use strict";
var bind = require("ec4f1e1d3f29fa3e");
module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);

},{"ec4f1e1d3f29fa3e":"6J4ob"}],"bfo8D":[function(require,module,exports) {
"use strict";
var bind = require("4f9d84d5de4909bc");
var GetIntrinsic = require("68d2ad3775278f43");
var $apply = GetIntrinsic("%Function.prototype.apply%");
var $call = GetIntrinsic("%Function.prototype.call%");
var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
var $max = GetIntrinsic("%Math.max%");
if ($defineProperty) try {
    $defineProperty({}, "a", {
        value: 1
    });
} catch (e) {
    // IE 8 has a broken defineProperty
    $defineProperty = null;
}
module.exports = function callBind(originalFunction) {
    var func = $reflectApply(bind, $call, arguments);
    if ($gOPD && $defineProperty) {
        var desc = $gOPD(func, "length");
        if (desc.configurable) // original length, plus the receiver, minus any additional arguments (after the receiver)
        $defineProperty(func, "length", {
            value: 1 + $max(0, originalFunction.length - (arguments.length - 1))
        });
    }
    return func;
};
var applyBind = function applyBind() {
    return $reflectApply(bind, $apply, arguments);
};
if ($defineProperty) $defineProperty(module.exports, "apply", {
    value: applyBind
});
else module.exports.apply = applyBind;

},{"4f9d84d5de4909bc":"6J4ob","68d2ad3775278f43":"dZb05"}],"2XUdn":[function(require,module,exports) {
"use strict";
var toStr = Object.prototype.toString;
var fnToStr = Function.prototype.toString;
var isFnRegex = /^\s*(?:function)?\*/;
var hasToStringTag = require("b42ab74c25dbb155")();
var getProto = Object.getPrototypeOf;
var getGeneratorFunc = function() {
    if (!hasToStringTag) return false;
    try {
        return Function("return function*() {}")();
    } catch (e) {}
};
var GeneratorFunction;
module.exports = function isGeneratorFunction(fn) {
    if (typeof fn !== "function") return false;
    if (isFnRegex.test(fnToStr.call(fn))) return true;
    if (!hasToStringTag) {
        var str = toStr.call(fn);
        return str === "[object GeneratorFunction]";
    }
    if (!getProto) return false;
    if (typeof GeneratorFunction === "undefined") {
        var generatorFunc = getGeneratorFunc();
        GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
    }
    return getProto(fn) === GeneratorFunction;
};

},{"b42ab74c25dbb155":"9LdQ9"}],"lVUO7":[function(require,module,exports) {
var global = arguments[3];
"use strict";
var forEach = require("2941d48f36957e3c");
var availableTypedArrays = require("beaf5502a5823cce");
var callBound = require("83f633f9b335db8f");
var gOPD = require("ce6b45c571ba4e3e");
var $toString = callBound("Object.prototype.toString");
var hasToStringTag = require("9e7ef6c88184c56")();
var g = typeof globalThis === "undefined" ? global : globalThis;
var typedArrays = availableTypedArrays();
var $slice = callBound("String.prototype.slice");
var toStrTags = {};
var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
if (hasToStringTag && gOPD && getPrototypeOf) forEach(typedArrays, function(typedArray) {
    if (typeof g[typedArray] === "function") {
        var arr = new g[typedArray]();
        if (Symbol.toStringTag in arr) {
            var proto = getPrototypeOf(arr);
            var descriptor = gOPD(proto, Symbol.toStringTag);
            if (!descriptor) {
                var superProto = getPrototypeOf(proto);
                descriptor = gOPD(superProto, Symbol.toStringTag);
            }
            toStrTags[typedArray] = descriptor.get;
        }
    }
});
var tryTypedArrays = function tryAllTypedArrays(value) {
    var foundName = false;
    forEach(toStrTags, function(getter, typedArray) {
        if (!foundName) try {
            var name = getter.call(value);
            if (name === typedArray) foundName = name;
        } catch (e) {}
    });
    return foundName;
};
var isTypedArray = require("41b5d056a91a2f13");
module.exports = function whichTypedArray(value) {
    if (!isTypedArray(value)) return false;
    if (!hasToStringTag || !(Symbol.toStringTag in value)) return $slice($toString(value), 8, -1);
    return tryTypedArrays(value);
};

},{"2941d48f36957e3c":"1Sol9","beaf5502a5823cce":"kfela","83f633f9b335db8f":"5yYiF","ce6b45c571ba4e3e":"eOTQB","9e7ef6c88184c56":"9LdQ9","41b5d056a91a2f13":"1ihkG"}],"1Sol9":[function(require,module,exports) {
"use strict";
var isCallable = require("e50ebc24bbb25feb");
var toStr = Object.prototype.toString;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var forEachArray = function forEachArray(array, iterator, receiver) {
    for(var i = 0, len = array.length; i < len; i++)if (hasOwnProperty.call(array, i)) {
        if (receiver == null) iterator(array[i], i, array);
        else iterator.call(receiver, array[i], i, array);
    }
};
var forEachString = function forEachString(string, iterator, receiver) {
    for(var i = 0, len = string.length; i < len; i++)// no such thing as a sparse string.
    if (receiver == null) iterator(string.charAt(i), i, string);
    else iterator.call(receiver, string.charAt(i), i, string);
};
var forEachObject = function forEachObject(object, iterator, receiver) {
    for(var k in object)if (hasOwnProperty.call(object, k)) {
        if (receiver == null) iterator(object[k], k, object);
        else iterator.call(receiver, object[k], k, object);
    }
};
var forEach = function forEach(list, iterator, thisArg) {
    if (!isCallable(iterator)) throw new TypeError("iterator must be a function");
    var receiver;
    if (arguments.length >= 3) receiver = thisArg;
    if (toStr.call(list) === "[object Array]") forEachArray(list, iterator, receiver);
    else if (typeof list === "string") forEachString(list, iterator, receiver);
    else forEachObject(list, iterator, receiver);
};
module.exports = forEach;

},{"e50ebc24bbb25feb":"9ocyk"}],"9ocyk":[function(require,module,exports) {
"use strict";
var fnToStr = Function.prototype.toString;
var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
var badArrayLike;
var isCallableMarker;
if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") try {
    badArrayLike = Object.defineProperty({}, "length", {
        get: function() {
            throw isCallableMarker;
        }
    });
    isCallableMarker = {};
    // eslint-disable-next-line no-throw-literal
    reflectApply(function() {
        throw 42;
    }, null, badArrayLike);
} catch (_) {
    if (_ !== isCallableMarker) reflectApply = null;
}
else reflectApply = null;
var constructorRegex = /^\s*class\b/;
var isES6ClassFn = function isES6ClassFunction(value) {
    try {
        var fnStr = fnToStr.call(value);
        return constructorRegex.test(fnStr);
    } catch (e) {
        return false; // not a function
    }
};
var tryFunctionObject = function tryFunctionToStr(value) {
    try {
        if (isES6ClassFn(value)) return false;
        fnToStr.call(value);
        return true;
    } catch (e) {
        return false;
    }
};
var toStr = Object.prototype.toString;
var objectClass = "[object Object]";
var fnClass = "[object Function]";
var genClass = "[object GeneratorFunction]";
var ddaClass = "[object HTMLAllCollection]"; // IE 11
var ddaClass2 = "[object HTML document.all class]";
var ddaClass3 = "[object HTMLCollection]"; // IE 9-10
var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag; // better: use `has-tostringtag`
var isIE68 = !(0 in [
    , 
]); // eslint-disable-line no-sparse-arrays, comma-spacing
var isDDA = function isDocumentDotAll() {
    return false;
};
if (typeof document === "object") {
    // Firefox 3 canonicalizes DDA to undefined when it's not accessed directly
    var all = document.all;
    if (toStr.call(all) === toStr.call(document.all)) isDDA = function isDocumentDotAll(value) {
        /* globals document: false */ // in IE 6-8, typeof document.all is "object" and it's truthy
        if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) try {
            var str = toStr.call(value);
            return (str === ddaClass || str === ddaClass2 || str === ddaClass3 // opera 12.16
             || str === objectClass // IE 6-8
            ) && value("") == null; // eslint-disable-line eqeqeq
        } catch (e) {}
        return false;
    };
}
module.exports = reflectApply ? function isCallable(value) {
    if (isDDA(value)) return true;
    if (!value) return false;
    if (typeof value !== "function" && typeof value !== "object") return false;
    try {
        reflectApply(value, null, badArrayLike);
    } catch (e) {
        if (e !== isCallableMarker) return false;
    }
    return !isES6ClassFn(value) && tryFunctionObject(value);
} : function isCallable(value) {
    if (isDDA(value)) return true;
    if (!value) return false;
    if (typeof value !== "function" && typeof value !== "object") return false;
    if (hasToStringTag) return tryFunctionObject(value);
    if (isES6ClassFn(value)) return false;
    var strClass = toStr.call(value);
    if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) return false;
    return tryFunctionObject(value);
};

},{}],"kfela":[function(require,module,exports) {
var global = arguments[3];
"use strict";
var possibleNames = [
    "BigInt64Array",
    "BigUint64Array",
    "Float32Array",
    "Float64Array",
    "Int16Array",
    "Int32Array",
    "Int8Array",
    "Uint16Array",
    "Uint32Array",
    "Uint8Array",
    "Uint8ClampedArray"
];
var g = typeof globalThis === "undefined" ? global : globalThis;
module.exports = function availableTypedArrays() {
    var out = [];
    for(var i = 0; i < possibleNames.length; i++)if (typeof g[possibleNames[i]] === "function") out[out.length] = possibleNames[i];
    return out;
};

},{}],"eOTQB":[function(require,module,exports) {
"use strict";
var GetIntrinsic = require("693e651525841e04");
var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
if ($gOPD) try {
    $gOPD([], "length");
} catch (e) {
    // IE 8 has a broken gOPD
    $gOPD = null;
}
module.exports = $gOPD;

},{"693e651525841e04":"dZb05"}],"1ihkG":[function(require,module,exports) {
var global = arguments[3];
"use strict";
var forEach = require("68abe9b54a20c572");
var availableTypedArrays = require("aafd98fda33bbd57");
var callBound = require("a32527df8bf8b924");
var $toString = callBound("Object.prototype.toString");
var hasToStringTag = require("b3f7dbb937db3363")();
var gOPD = require("af60b1967ea134c8");
var g = typeof globalThis === "undefined" ? global : globalThis;
var typedArrays = availableTypedArrays();
var $indexOf = callBound("Array.prototype.indexOf", true) || function indexOf(array, value) {
    for(var i = 0; i < array.length; i += 1){
        if (array[i] === value) return i;
    }
    return -1;
};
var $slice = callBound("String.prototype.slice");
var toStrTags = {};
var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
if (hasToStringTag && gOPD && getPrototypeOf) forEach(typedArrays, function(typedArray) {
    var arr = new g[typedArray]();
    if (Symbol.toStringTag in arr) {
        var proto = getPrototypeOf(arr);
        var descriptor = gOPD(proto, Symbol.toStringTag);
        if (!descriptor) {
            var superProto = getPrototypeOf(proto);
            descriptor = gOPD(superProto, Symbol.toStringTag);
        }
        toStrTags[typedArray] = descriptor.get;
    }
});
var tryTypedArrays = function tryAllTypedArrays(value) {
    var anyTrue = false;
    forEach(toStrTags, function(getter, typedArray) {
        if (!anyTrue) try {
            anyTrue = getter.call(value) === typedArray;
        } catch (e) {}
    });
    return anyTrue;
};
module.exports = function isTypedArray(value) {
    if (!value || typeof value !== "object") return false;
    if (!hasToStringTag || !(Symbol.toStringTag in value)) {
        var tag = $slice($toString(value), 8, -1);
        return $indexOf(typedArrays, tag) > -1;
    }
    if (!gOPD) return false;
    return tryTypedArrays(value);
};

},{"68abe9b54a20c572":"1Sol9","aafd98fda33bbd57":"kfela","a32527df8bf8b924":"5yYiF","b3f7dbb937db3363":"9LdQ9","af60b1967ea134c8":"eOTQB"}],"inNNy":[function(require,module,exports) {
module.exports = function isBuffer(arg) {
    return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
};

},{}],"bRL3M":[function(require,module,exports) {
if (typeof Object.create === "function") // implementation from standard node.js 'util' module
module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
    }
};
else // old school shim for old browsers
module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {};
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
    }
};

},{}],"j77ns":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
module.exports = Stream;
var EE = require("96b62835346f84f0").EventEmitter;
var inherits = require("4a6ee9586f51c38d");
inherits(Stream, EE);
Stream.Readable = require("e6206e1f4d20abc7");
Stream.Writable = require("a3f1405f37e1dfb1");
Stream.Duplex = require("6691a72c5fc222fd");
Stream.Transform = require("43a905ce7ec6ac9e");
Stream.PassThrough = require("dd715550d7783885");
Stream.finished = require("d90a3520974ec96e");
Stream.pipeline = require("eb2779cfd287c5c9");
// Backwards-compat with node 0.4.x
Stream.Stream = Stream;
// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.
function Stream() {
    EE.call(this);
}
Stream.prototype.pipe = function(dest, options) {
    var source = this;
    function ondata(chunk) {
        if (dest.writable) {
            if (false === dest.write(chunk) && source.pause) source.pause();
        }
    }
    source.on("data", ondata);
    function ondrain() {
        if (source.readable && source.resume) source.resume();
    }
    dest.on("drain", ondrain);
    // If the 'end' option is not supplied, dest.end() will be called when
    // source gets the 'end' or 'close' events.  Only dest.end() once.
    if (!dest._isStdio && (!options || options.end !== false)) {
        source.on("end", onend);
        source.on("close", onclose);
    }
    var didOnEnd = false;
    function onend() {
        if (didOnEnd) return;
        didOnEnd = true;
        dest.end();
    }
    function onclose() {
        if (didOnEnd) return;
        didOnEnd = true;
        if (typeof dest.destroy === "function") dest.destroy();
    }
    // don't leave dangling pipes when there are errors.
    function onerror(er) {
        cleanup();
        if (EE.listenerCount(this, "error") === 0) throw er; // Unhandled stream error in pipe.
    }
    source.on("error", onerror);
    dest.on("error", onerror);
    // remove all the event listeners that were added.
    function cleanup() {
        source.removeListener("data", ondata);
        dest.removeListener("drain", ondrain);
        source.removeListener("end", onend);
        source.removeListener("close", onclose);
        source.removeListener("error", onerror);
        dest.removeListener("error", onerror);
        source.removeListener("end", cleanup);
        source.removeListener("close", cleanup);
        dest.removeListener("close", cleanup);
    }
    source.on("end", cleanup);
    source.on("close", cleanup);
    dest.on("close", cleanup);
    dest.emit("pipe", source);
    // Allow for unix-like usage: A.pipe(B).pipe(C)
    return dest;
};

},{"96b62835346f84f0":"1VQLm","4a6ee9586f51c38d":"bRL3M","e6206e1f4d20abc7":"6NdbQ","a3f1405f37e1dfb1":"gTkcq","6691a72c5fc222fd":"kKNA3","43a905ce7ec6ac9e":"ba8Mr","dd715550d7783885":"2xP98","d90a3520974ec96e":"aOMy2","eb2779cfd287c5c9":"fyp4t"}],"1VQLm":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
"use strict";
var R = typeof Reflect === "object" ? Reflect : null;
var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;
if (R && typeof R.ownKeys === "function") ReflectOwnKeys = R.ownKeys;
else if (Object.getOwnPropertySymbols) ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
};
else ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
};
function ProcessEmitWarning(warning) {
    if (console && console.warn) console.warn(warning);
}
var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
    return value !== value;
};
function EventEmitter() {
    EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;
// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;
// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;
function checkListener(listener) {
    if (typeof listener !== "function") throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
}
Object.defineProperty(EventEmitter, "defaultMaxListeners", {
    enumerable: true,
    get: function() {
        return defaultMaxListeners;
    },
    set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        defaultMaxListeners = arg;
    }
});
EventEmitter.init = function() {
    if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
        this._events = Object.create(null);
        this._eventsCount = 0;
    }
    this._maxListeners = this._maxListeners || undefined;
};
// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
    if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
    this._maxListeners = n;
    return this;
};
function _getMaxListeners(that) {
    if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
    return that._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
    return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function emit(type) {
    var args = [];
    for(var i = 1; i < arguments.length; i++)args.push(arguments[i]);
    var doError = type === "error";
    var events = this._events;
    if (events !== undefined) doError = doError && events.error === undefined;
    else if (!doError) return false;
    // If there is no 'error' event listener then throw.
    if (doError) {
        var er;
        if (args.length > 0) er = args[0];
        if (er instanceof Error) // Note: The comments on the `throw` lines are intentional, they show
        // up in Node's output if this results in an unhandled exception.
        throw er; // Unhandled 'error' event
        // At least give some kind of context to the user
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err; // Unhandled 'error' event
    }
    var handler = events[type];
    if (handler === undefined) return false;
    if (typeof handler === "function") ReflectApply(handler, this, args);
    else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for(var i = 0; i < len; ++i)ReflectApply(listeners[i], this, args);
    }
    return true;
};
function _addListener(target, type, listener, prepend) {
    var m;
    var events;
    var existing;
    checkListener(listener);
    events = target._events;
    if (events === undefined) {
        events = target._events = Object.create(null);
        target._eventsCount = 0;
    } else {
        // To avoid recursion in the case that type === "newListener"! Before
        // adding it to the listeners, first emit "newListener".
        if (events.newListener !== undefined) {
            target.emit("newListener", type, listener.listener ? listener.listener : listener);
            // Re-assign `events` because a newListener handler could have caused the
            // this._events to be assigned to a new object
            events = target._events;
        }
        existing = events[type];
    }
    if (existing === undefined) {
        // Optimize the case of one listener. Don't need the extra array object.
        existing = events[type] = listener;
        ++target._eventsCount;
    } else {
        if (typeof existing === "function") // Adding the second element, need to change to array.
        existing = events[type] = prepend ? [
            listener,
            existing
        ] : [
            existing,
            listener
        ];
        else if (prepend) existing.unshift(listener);
        else existing.push(listener);
        // Check for listener leak
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
            existing.warned = true;
            // No error code for this since it is a Warning
            // eslint-disable-next-line no-restricted-syntax
            var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners " + "added. Use emitter.setMaxListeners() to " + "increase limit");
            w.name = "MaxListenersExceededWarning";
            w.emitter = target;
            w.type = type;
            w.count = existing.length;
            ProcessEmitWarning(w);
        }
    }
    return target;
}
EventEmitter.prototype.addListener = function addListener(type, listener) {
    return _addListener(this, type, listener, false);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function prependListener(type, listener) {
    return _addListener(this, type, listener, true);
};
function onceWrapper() {
    if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0) return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
    }
}
function _onceWrap(target, type, listener) {
    var state = {
        fired: false,
        wrapFn: undefined,
        target: target,
        type: type,
        listener: listener
    };
    var wrapped = onceWrapper.bind(state);
    wrapped.listener = listener;
    state.wrapFn = wrapped;
    return wrapped;
}
EventEmitter.prototype.once = function once(type, listener) {
    checkListener(listener);
    this.on(type, _onceWrap(this, type, listener));
    return this;
};
EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
    checkListener(listener);
    this.prependListener(type, _onceWrap(this, type, listener));
    return this;
};
// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener = function removeListener(type, listener) {
    var list, events, position, i, originalListener;
    checkListener(listener);
    events = this._events;
    if (events === undefined) return this;
    list = events[type];
    if (list === undefined) return this;
    if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0) this._events = Object.create(null);
        else {
            delete events[type];
            if (events.removeListener) this.emit("removeListener", type, list.listener || listener);
        }
    } else if (typeof list !== "function") {
        position = -1;
        for(i = list.length - 1; i >= 0; i--)if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
        }
        if (position < 0) return this;
        if (position === 0) list.shift();
        else spliceOne(list, position);
        if (list.length === 1) events[type] = list[0];
        if (events.removeListener !== undefined) this.emit("removeListener", type, originalListener || listener);
    }
    return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
    var listeners, events, i;
    events = this._events;
    if (events === undefined) return this;
    // not listening for removeListener, no need to emit
    if (events.removeListener === undefined) {
        if (arguments.length === 0) {
            this._events = Object.create(null);
            this._eventsCount = 0;
        } else if (events[type] !== undefined) {
            if (--this._eventsCount === 0) this._events = Object.create(null);
            else delete events[type];
        }
        return this;
    }
    // emit removeListener for all listeners on all events
    if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for(i = 0; i < keys.length; ++i){
            key = keys[i];
            if (key === "removeListener") continue;
            this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
    }
    listeners = events[type];
    if (typeof listeners === "function") this.removeListener(type, listeners);
    else if (listeners !== undefined) // LIFO order
    for(i = listeners.length - 1; i >= 0; i--)this.removeListener(type, listeners[i]);
    return this;
};
function _listeners(target, type, unwrap) {
    var events = target._events;
    if (events === undefined) return [];
    var evlistener = events[type];
    if (evlistener === undefined) return [];
    if (typeof evlistener === "function") return unwrap ? [
        evlistener.listener || evlistener
    ] : [
        evlistener
    ];
    return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}
EventEmitter.prototype.listeners = function listeners(type) {
    return _listeners(this, type, true);
};
EventEmitter.prototype.rawListeners = function rawListeners(type) {
    return _listeners(this, type, false);
};
EventEmitter.listenerCount = function(emitter, type) {
    if (typeof emitter.listenerCount === "function") return emitter.listenerCount(type);
    else return listenerCount.call(emitter, type);
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
    var events = this._events;
    if (events !== undefined) {
        var evlistener = events[type];
        if (typeof evlistener === "function") return 1;
        else if (evlistener !== undefined) return evlistener.length;
    }
    return 0;
}
EventEmitter.prototype.eventNames = function eventNames() {
    return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(arr, n) {
    var copy = new Array(n);
    for(var i = 0; i < n; ++i)copy[i] = arr[i];
    return copy;
}
function spliceOne(list, index) {
    for(; index + 1 < list.length; index++)list[index] = list[index + 1];
    list.pop();
}
function unwrapListeners(arr) {
    var ret = new Array(arr.length);
    for(var i = 0; i < ret.length; ++i)ret[i] = arr[i].listener || arr[i];
    return ret;
}
function once(emitter, name) {
    return new Promise(function(resolve, reject) {
        function errorListener(err) {
            emitter.removeListener(name, resolver);
            reject(err);
        }
        function resolver() {
            if (typeof emitter.removeListener === "function") emitter.removeListener("error", errorListener);
            resolve([].slice.call(arguments));
        }
        eventTargetAgnosticAddListener(emitter, name, resolver, {
            once: true
        });
        if (name !== "error") addErrorHandlerIfEventEmitter(emitter, errorListener, {
            once: true
        });
    });
}
function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
    if (typeof emitter.on === "function") eventTargetAgnosticAddListener(emitter, "error", handler, flags);
}
function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
    if (typeof emitter.on === "function") {
        if (flags.once) emitter.once(name, listener);
        else emitter.on(name, listener);
    } else if (typeof emitter.addEventListener === "function") // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
        // IE does not have builtin `{ once: true }` support so we
        // have to do it manually.
        if (flags.once) emitter.removeEventListener(name, wrapListener);
        listener(arg);
    });
    else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
}

},{}],"6NdbQ":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
var global = arguments[3];
var process = require("896ff8d56553f7a");
"use strict";
module.exports = Readable;
/*<replacement>*/ var Duplex;
/*</replacement>*/ Readable.ReadableState = ReadableState;
/*<replacement>*/ var EE = require("16782d660ac22e0c").EventEmitter;
var EElistenerCount = function EElistenerCount(emitter, type) {
    return emitter.listeners(type).length;
};
/*</replacement>*/ /*<replacement>*/ var Stream = require("9a34f23fa53f83f7");
/*</replacement>*/ var Buffer = require("fb95ecaa88342eae").Buffer;
var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {};
function _uint8ArrayToBuffer(chunk) {
    return Buffer.from(chunk);
}
function _isUint8Array(obj) {
    return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*<replacement>*/ var debugUtil = require("a4a723b7297c7152");
var debug;
if (debugUtil && debugUtil.debuglog) debug = debugUtil.debuglog("stream");
else debug = function debug() {};
/*</replacement>*/ var BufferList = require("7a14cc1689b8c63e");
var destroyImpl = require("efa8155386cc4283");
var _require = require("994c984d08c7bbf2"), getHighWaterMark = _require.getHighWaterMark;
var _require$codes = require("8de60461b822641b").codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
// Lazy loaded to improve the startup performance.
var StringDecoder;
var createReadableStreamAsyncIterator;
var from;
require("19affa8ce41f090d")(Readable, Stream);
var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = [
    "error",
    "close",
    "destroy",
    "pause",
    "resume"
];
function prependListener(emitter, event, fn) {
    // Sadly this is not cacheable as some libraries bundle their own
    // event emitter implementation with them.
    if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
    // This is a hack to make sure that our error handler is attached before any
    // userland ones.  NEVER DO THIS. This is here only because this code needs
    // to continue to work with older versions of Node.js that do not include
    // the prependListener() method. The goal is to eventually remove this hack.
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);
    else emitter._events[event] = [
        fn,
        emitter._events[event]
    ];
}
function ReadableState(options, stream, isDuplex) {
    Duplex = Duplex || require("f1c95f846e94e4eb");
    options = options || {};
    // Duplex streams are both readable and writable, but share
    // the same options object.
    // However, some cases require setting options to different
    // values for the readable and the writable sides of the duplex stream.
    // These options can be provided separately as readableXXX and writableXXX.
    if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
    // object stream flag. Used to make read(n) ignore n and to
    // make all the buffer merging and length checks go away
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
    // the point at which it stops calling _read() to fill the buffer
    // Note: 0 is a valid value, means "don't call _read preemptively ever"
    this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
    // A linked list is used to store data chunks instead of an array because the
    // linked list can remove elements from the beginning faster than
    // array.shift()
    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    // a flag to be able to tell if the event 'readable'/'data' is emitted
    // immediately, or on a later tick.  We set this to true at first, because
    // any actions that shouldn't happen until "later" should generally also
    // not happen before the first read call.
    this.sync = true;
    // whenever we return null, then we set a flag to say
    // that we're awaiting a 'readable' event emission.
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.paused = true;
    // Should close be emitted on destroy. Defaults to true.
    this.emitClose = options.emitClose !== false;
    // Should .destroy() be called after 'end' (and potentially 'finish')
    this.autoDestroy = !!options.autoDestroy;
    // has it been destroyed
    this.destroyed = false;
    // Crypto is kind of old and crusty.  Historically, its default string
    // encoding is 'binary' so we have to make this configurable.
    // Everything else in the universe uses 'utf8', though.
    this.defaultEncoding = options.defaultEncoding || "utf8";
    // the number of writers that are awaiting a drain event in .pipe()s
    this.awaitDrain = 0;
    // if true, a maybeReadMore has been scheduled
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
        if (!StringDecoder) StringDecoder = require("6392acd10886f115").StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
    }
}
function Readable(options) {
    Duplex = Duplex || require("f1c95f846e94e4eb");
    if (!(this instanceof Readable)) return new Readable(options);
    // Checking for a Stream.Duplex instance is faster here instead of inside
    // the ReadableState constructor, at least with V8 6.5
    var isDuplex = this instanceof Duplex;
    this._readableState = new ReadableState(options, this, isDuplex);
    // legacy
    this.readable = true;
    if (options) {
        if (typeof options.read === "function") this._read = options.read;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
    }
    Stream.call(this);
}
Object.defineProperty(Readable.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        if (this._readableState === undefined) return false;
        return this._readableState.destroyed;
    },
    set: function set(value) {
        // we ignore the value if the stream
        // has not been initialized yet
        if (!this._readableState) return;
        // backward compatibility, the user is explicitly
        // managing destroyed
        this._readableState.destroyed = value;
    }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function(err, cb) {
    cb(err);
};
// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function(chunk, encoding) {
    var state = this._readableState;
    var skipChunkCheck;
    if (!state.objectMode) {
        if (typeof chunk === "string") {
            encoding = encoding || state.defaultEncoding;
            if (encoding !== state.encoding) {
                chunk = Buffer.from(chunk, encoding);
                encoding = "";
            }
            skipChunkCheck = true;
        }
    } else skipChunkCheck = true;
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};
// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
};
function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    debug("readableAddChunk", chunk);
    var state = stream._readableState;
    if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
    } else {
        var er;
        if (!skipChunkCheck) er = chunkInvalid(state, chunk);
        if (er) errorOrDestroy(stream, er);
        else if (state.objectMode || chunk && chunk.length > 0) {
            if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) chunk = _uint8ArrayToBuffer(chunk);
            if (addToFront) {
                if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
                else addChunk(stream, state, chunk, true);
            } else if (state.ended) errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
            else if (state.destroyed) return false;
            else {
                state.reading = false;
                if (state.decoder && !encoding) {
                    chunk = state.decoder.write(chunk);
                    if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);
                    else maybeReadMore(stream, state);
                } else addChunk(stream, state, chunk, false);
            }
        } else if (!addToFront) {
            state.reading = false;
            maybeReadMore(stream, state);
        }
    }
    // We can push more data if we are below the highWaterMark.
    // Also, if we have no data yet, we can stand some more bytes.
    // This is to work around cases where hwm=0, such as the repl.
    return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}
function addChunk(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
    } else {
        // update the buffer info.
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront) state.buffer.unshift(chunk);
        else state.buffer.push(chunk);
        if (state.needReadable) emitReadable(stream);
    }
    maybeReadMore(stream, state);
}
function chunkInvalid(state, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== undefined && !state.objectMode) er = new ERR_INVALID_ARG_TYPE("chunk", [
        "string",
        "Buffer",
        "Uint8Array"
    ], chunk);
    return er;
}
Readable.prototype.isPaused = function() {
    return this._readableState.flowing === false;
};
// backwards compatibility.
Readable.prototype.setEncoding = function(enc) {
    if (!StringDecoder) StringDecoder = require("6392acd10886f115").StringDecoder;
    var decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder;
    // If setEncoding(null), decoder.encoding equals utf8
    this._readableState.encoding = this._readableState.decoder.encoding;
    // Iterate over current buffer to convert already stored Buffers:
    var p = this._readableState.buffer.head;
    var content = "";
    while(p !== null){
        content += decoder.write(p.data);
        p = p.next;
    }
    this._readableState.buffer.clear();
    if (content !== "") this._readableState.buffer.push(content);
    this._readableState.length = content.length;
    return this;
};
// Don't raise the hwm > 1GB
var MAX_HWM = 0x40000000;
function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
    else {
        // Get the next highest power of 2 to prevent increasing hwm excessively in
        // tiny amounts
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
    }
    return n;
}
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended) return 0;
    if (state.objectMode) return 1;
    if (n !== n) {
        // Only flow one buffer at a time
        if (state.flowing && state.length) return state.buffer.head.data.length;
        else return state.length;
    }
    // If we're asking for more than the current hwm, then raise the hwm.
    if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state.length) return n;
    // Don't have enough
    if (!state.ended) {
        state.needReadable = true;
        return 0;
    }
    return state.length;
}
// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function(n) {
    debug("read", n);
    n = parseInt(n, 10);
    var state = this._readableState;
    var nOrig = n;
    if (n !== 0) state.emittedReadable = false;
    // if we're doing read(0) to trigger a readable event, but we
    // already have a bunch of data in the buffer, then just trigger
    // the 'readable' event and move on.
    if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended) endReadable(this);
        else emitReadable(this);
        return null;
    }
    n = howMuchToRead(n, state);
    // if we've ended, and we're now clear, then finish it up.
    if (n === 0 && state.ended) {
        if (state.length === 0) endReadable(this);
        return null;
    }
    // All the actual chunk generation logic needs to be
    // *below* the call to _read.  The reason is that in certain
    // synthetic stream cases, such as passthrough streams, _read
    // may be a completely synchronous operation which may change
    // the state of the read buffer, providing enough data when
    // before there was *not* enough.
    //
    // So, the steps are:
    // 1. Figure out what the state of things will be after we do
    // a read from the buffer.
    //
    // 2. If that resulting state will trigger a _read, then call _read.
    // Note that this may be asynchronous, or synchronous.  Yes, it is
    // deeply ugly to write APIs this way, but that still doesn't mean
    // that the Readable class should behave improperly, as streams are
    // designed to be sync/async agnostic.
    // Take note if the _read call is sync or async (ie, if the read call
    // has returned yet), so that we know whether or not it's safe to emit
    // 'readable' etc.
    //
    // 3. Actually pull the requested chunks out of the buffer and return.
    // if we need a readable event, then we need to do some reading.
    var doRead = state.needReadable;
    debug("need readable", doRead);
    // if we currently have less than the highWaterMark, then also read some
    if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
    }
    // however, if we've ended, then there's no point, and if we're already
    // reading, then it's unnecessary.
    if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
    } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        // if the length is currently zero, then we *need* a readable event.
        if (state.length === 0) state.needReadable = true;
        // call internal read method
        this._read(state.highWaterMark);
        state.sync = false;
        // If _read pushed data synchronously, then `reading` will be false,
        // and we need to re-evaluate how much data we can return to the user.
        if (!state.reading) n = howMuchToRead(nOrig, state);
    }
    var ret;
    if (n > 0) ret = fromList(n, state);
    else ret = null;
    if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
    } else {
        state.length -= n;
        state.awaitDrain = 0;
    }
    if (state.length === 0) {
        // If we have nothing in the buffer, then we want to know
        // as soon as we *do* get something into the buffer.
        if (!state.ended) state.needReadable = true;
        // If we tried to read() past the EOF, then emit end on the next tick.
        if (nOrig !== n && state.ended) endReadable(this);
    }
    if (ret !== null) this.emit("data", ret);
    return ret;
};
function onEofChunk(stream, state) {
    debug("onEofChunk");
    if (state.ended) return;
    if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
        }
    }
    state.ended = true;
    if (state.sync) // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
    else {
        // emit 'readable' now to make sure it gets picked up.
        state.needReadable = false;
        if (!state.emittedReadable) {
            state.emittedReadable = true;
            emitReadable_(stream);
        }
    }
}
// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
    var state = stream._readableState;
    debug("emitReadable", state.needReadable, state.emittedReadable);
    state.needReadable = false;
    if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream);
    }
}
function emitReadable_(stream) {
    var state = stream._readableState;
    debug("emitReadable_", state.destroyed, state.length, state.ended);
    if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
    }
    // The stream needs another readable event if
    // 1. It is not flowing, as the flow mechanism will take
    //    care of it.
    // 2. It is not ended.
    // 3. It is below the highWaterMark, so we can schedule
    //    another readable later.
    state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
    flow(stream);
}
// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
    if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream, state);
    }
}
function maybeReadMore_(stream, state) {
    // Attempt to read more data if we should.
    //
    // The conditions for reading more data are (one of):
    // - Not enough data buffered (state.length < state.highWaterMark). The loop
    //   is responsible for filling the buffer with enough data if such data
    //   is available. If highWaterMark is 0 and we are not in the flowing mode
    //   we should _not_ attempt to buffer any extra data. We'll get more data
    //   when the stream consumer calls read() instead.
    // - No data in the buffer, and the stream is in flowing mode. In this mode
    //   the loop below is responsible for ensuring read() is called. Failing to
    //   call read here would abort the flow and there's no other mechanism for
    //   continuing the flow if the stream consumer has just subscribed to the
    //   'data' event.
    //
    // In addition to the above conditions to keep reading data, the following
    // conditions prevent the data from being read:
    // - The stream has ended (state.ended).
    // - There is already a pending 'read' operation (state.reading). This is a
    //   case where the the stream has called the implementation defined _read()
    //   method, but they are processing the call asynchronously and have _not_
    //   called push() with new data. In this case we skip performing more
    //   read()s. The execution ends in this method again after the _read() ends
    //   up calling push() with more data.
    while(!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)){
        var len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length) break;
    }
    state.readingMore = false;
}
// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function(n) {
    errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
};
Readable.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state = this._readableState;
    switch(state.pipesCount){
        case 0:
            state.pipes = dest;
            break;
        case 1:
            state.pipes = [
                state.pipes,
                dest
            ];
            break;
        default:
            state.pipes.push(dest);
            break;
    }
    state.pipesCount += 1;
    debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state.endEmitted) process.nextTick(endFn);
    else src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                unpipeInfo.hasUnpiped = true;
                cleanup();
            }
        }
    }
    function onend() {
        debug("onend");
        dest.end();
    }
    // when the dest drains, it reduces the awaitDrain counter
    // on the source.  This would be more elegant with a .once()
    // handler in flow(), but adding and removing repeatedly is
    // too slow.
    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
        debug("cleanup");
        // cleanup event handlers once the pipe is broken
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        // if the reader is waiting for a drain event from this
        // specific writer, then it would cause it to never start
        // flowing again.
        // So, if this is awaiting a drain, then we just call it now.
        // If we don't know, then assume that we are waiting for one.
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
    }
    src.on("data", ondata);
    function ondata(chunk) {
        debug("ondata");
        var ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
            // If the user unpiped during `dest.write()`, it is possible
            // to get stuck in a permanently paused state if that write
            // also returned false.
            // => Check whether `dest` is still a piping destination.
            if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
                debug("false write response, pause", state.awaitDrain);
                state.awaitDrain++;
            }
            src.pause();
        }
    }
    // if the dest has an error, then stop piping into it.
    // however, don't suppress the throwing behavior for this.
    function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0) errorOrDestroy(dest, er);
    }
    // Make sure our error handler is attached before userland ones.
    prependListener(dest, "error", onerror);
    // Both close and finish should trigger unpipe, but only once.
    function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
    }
    // tell the dest that it's being piped to
    dest.emit("pipe", src);
    // start the flow if it hasn't been started already.
    if (!state.flowing) {
        debug("pipe resume");
        src.resume();
    }
    return dest;
};
function pipeOnDrain(src) {
    return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain) state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
            state.flowing = true;
            flow(src);
        }
    };
}
Readable.prototype.unpipe = function(dest) {
    var state = this._readableState;
    var unpipeInfo = {
        hasUnpiped: false
    };
    // if we're not piping anywhere, then do nothing.
    if (state.pipesCount === 0) return this;
    // just one destination.  most common case.
    if (state.pipesCount === 1) {
        // passed in one, but it's not the right one.
        if (dest && dest !== state.pipes) return this;
        if (!dest) dest = state.pipes;
        // got a match.
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest) dest.emit("unpipe", this, unpipeInfo);
        return this;
    }
    // slow case. multiple pipe destinations.
    if (!dest) {
        // remove all.
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for(var i = 0; i < len; i++)dests[i].emit("unpipe", this, {
            hasUnpiped: false
        });
        return this;
    }
    // try to find the right one.
    var index = indexOf(state.pipes, dest);
    if (index === -1) return this;
    state.pipes.splice(index, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1) state.pipes = state.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
};
// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function(ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    var state = this._readableState;
    if (ev === "data") {
        // update readableListening so that resume() may be a no-op
        // a few lines down. This is needed to support once('readable').
        state.readableListening = this.listenerCount("readable") > 0;
        // Try start flowing on next tick if stream isn't explicitly paused
        if (state.flowing !== false) this.resume();
    } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.flowing = false;
            state.emittedReadable = false;
            debug("on readable", state.length, state.reading);
            if (state.length) emitReadable(this);
            else if (!state.reading) process.nextTick(nReadingNextTick, this);
        }
    }
    return res;
};
Readable.prototype.addListener = Readable.prototype.on;
Readable.prototype.removeListener = function(ev, fn) {
    var res = Stream.prototype.removeListener.call(this, ev, fn);
    if (ev === "readable") // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
    return res;
};
Readable.prototype.removeAllListeners = function(ev) {
    var res = Stream.prototype.removeAllListeners.apply(this, arguments);
    if (ev === "readable" || ev === undefined) // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
    return res;
};
function updateReadableListening(self1) {
    var state = self1._readableState;
    state.readableListening = self1.listenerCount("readable") > 0;
    if (state.resumeScheduled && !state.paused) // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true;
    else if (self1.listenerCount("data") > 0) self1.resume();
}
function nReadingNextTick(self1) {
    debug("readable nexttick read 0");
    self1.read(0);
}
// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function() {
    var state = this._readableState;
    if (!state.flowing) {
        debug("resume");
        // we flow only if there is no one listening
        // for readable, but we still have to call
        // resume()
        state.flowing = !state.readableListening;
        resume(this, state);
    }
    state.paused = false;
    return this;
};
function resume(stream, state) {
    if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream, state);
    }
}
function resume_(stream, state) {
    debug("resume", state.reading);
    if (!state.reading) stream.read(0);
    state.resumeScheduled = false;
    stream.emit("resume");
    flow(stream);
    if (state.flowing && !state.reading) stream.read(0);
}
Readable.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
    }
    this._readableState.paused = true;
    return this;
};
function flow(stream) {
    var state = stream._readableState;
    debug("flow", state.flowing);
    while(state.flowing && stream.read() !== null);
}
// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function(stream) {
    var _this = this;
    var state = this._readableState;
    var paused = false;
    stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length) _this.push(chunk);
        }
        _this.push(null);
    });
    stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder) chunk = state.decoder.write(chunk);
        // don't skip over falsy values in objectMode
        if (state.objectMode && (chunk === null || chunk === undefined)) return;
        else if (!state.objectMode && (!chunk || !chunk.length)) return;
        var ret = _this.push(chunk);
        if (!ret) {
            paused = true;
            stream.pause();
        }
    });
    // proxy all the other methods.
    // important when wrapping filters and duplexes.
    for(var i in stream)if (this[i] === undefined && typeof stream[i] === "function") this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
            return stream[method].apply(stream, arguments);
        };
    }(i);
    // proxy certain important events.
    for(var n = 0; n < kProxyEvents.length; n++)stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    // when we try to consume some more bytes, simply unpause the
    // underlying stream.
    this._read = function(n) {
        debug("wrapped _read", n);
        if (paused) {
            paused = false;
            stream.resume();
        }
    };
    return this;
};
if (typeof Symbol === "function") Readable.prototype[Symbol.asyncIterator] = function() {
    if (createReadableStreamAsyncIterator === undefined) createReadableStreamAsyncIterator = require("830c56f840811f05");
    return createReadableStreamAsyncIterator(this);
};
Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._readableState.highWaterMark;
    }
});
Object.defineProperty(Readable.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._readableState && this._readableState.buffer;
    }
});
Object.defineProperty(Readable.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._readableState.flowing;
    },
    set: function set(state) {
        if (this._readableState) this._readableState.flowing = state;
    }
});
// exposed for testing purposes only.
Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._readableState.length;
    }
});
// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
    // nothing buffered
    if (state.length === 0) return null;
    var ret;
    if (state.objectMode) ret = state.buffer.shift();
    else if (!n || n >= state.length) {
        // read it all, truncate the list
        if (state.decoder) ret = state.buffer.join("");
        else if (state.buffer.length === 1) ret = state.buffer.first();
        else ret = state.buffer.concat(state.length);
        state.buffer.clear();
    } else // read part of list
    ret = state.buffer.consume(n, state.decoder);
    return ret;
}
function endReadable(stream) {
    var state = stream._readableState;
    debug("endReadable", state.endEmitted);
    if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream);
    }
}
function endReadableNT(state, stream) {
    debug("endReadableNT", state.endEmitted, state.length);
    // Check that we didn't get one last unshift.
    if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
            // In case of duplex streams we need a way to detect
            // if the writable side is ready for autoDestroy as well
            var wState = stream._writableState;
            if (!wState || wState.autoDestroy && wState.finished) stream.destroy();
        }
    }
}
if (typeof Symbol === "function") Readable.from = function(iterable, opts) {
    if (from === undefined) from = require("7451b8c4bf72370");
    return from(Readable, iterable, opts);
};
function indexOf(xs, x) {
    for(var i = 0, l = xs.length; i < l; i++){
        if (xs[i] === x) return i;
    }
    return -1;
}

},{"896ff8d56553f7a":"d5jf4","16782d660ac22e0c":"1VQLm","9a34f23fa53f83f7":"60BLS","fb95ecaa88342eae":"fCgem","a4a723b7297c7152":"jhUEF","7a14cc1689b8c63e":"hf3P2","efa8155386cc4283":"YI8DF","994c984d08c7bbf2":"61BRN","8de60461b822641b":"aJlwj","19affa8ce41f090d":"bRL3M","f1c95f846e94e4eb":"kKNA3","6392acd10886f115":"3vmkr","830c56f840811f05":"k019Y","7451b8c4bf72370":"ak0YH"}],"60BLS":[function(require,module,exports) {
module.exports = require("ed88fc9aa73f911").EventEmitter;

},{"ed88fc9aa73f911":"1VQLm"}],"hf3P2":[function(require,module,exports) {
"use strict";
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {
            _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
        writable: false
    });
    return Constructor;
}
function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
}
var _require = require("59f5d0111b7fa075"), Buffer = _require.Buffer;
var _require2 = require("eef6a677577349b8"), inspect = _require2.inspect;
var custom = inspect && inspect.custom || "inspect";
function copyBuffer(src, target, offset) {
    Buffer.prototype.copy.call(src, target, offset);
}
module.exports = /*#__PURE__*/ function() {
    function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
    }
    _createClass(BufferList, [
        {
            key: "push",
            value: function push(v) {
                var entry = {
                    data: v,
                    next: null
                };
                if (this.length > 0) this.tail.next = entry;
                else this.head = entry;
                this.tail = entry;
                ++this.length;
            }
        },
        {
            key: "unshift",
            value: function unshift(v) {
                var entry = {
                    data: v,
                    next: this.head
                };
                if (this.length === 0) this.tail = entry;
                this.head = entry;
                ++this.length;
            }
        },
        {
            key: "shift",
            value: function shift() {
                if (this.length === 0) return;
                var ret = this.head.data;
                if (this.length === 1) this.head = this.tail = null;
                else this.head = this.head.next;
                --this.length;
                return ret;
            }
        },
        {
            key: "clear",
            value: function clear() {
                this.head = this.tail = null;
                this.length = 0;
            }
        },
        {
            key: "join",
            value: function join(s) {
                if (this.length === 0) return "";
                var p = this.head;
                var ret = "" + p.data;
                while(p = p.next)ret += s + p.data;
                return ret;
            }
        },
        {
            key: "concat",
            value: function concat(n) {
                if (this.length === 0) return Buffer.alloc(0);
                var ret = Buffer.allocUnsafe(n >>> 0);
                var p = this.head;
                var i = 0;
                while(p){
                    copyBuffer(p.data, ret, i);
                    i += p.data.length;
                    p = p.next;
                }
                return ret;
            }
        },
        {
            key: "consume",
            value: function consume(n, hasStrings) {
                var ret;
                if (n < this.head.data.length) {
                    // `slice` is the same for buffers and strings.
                    ret = this.head.data.slice(0, n);
                    this.head.data = this.head.data.slice(n);
                } else if (n === this.head.data.length) // First chunk is a perfect match.
                ret = this.shift();
                else // Result spans more than one buffer.
                ret = hasStrings ? this._getString(n) : this._getBuffer(n);
                return ret;
            }
        },
        {
            key: "first",
            value: function first() {
                return this.head.data;
            }
        },
        {
            key: "_getString",
            value: function _getString(n) {
                var p = this.head;
                var c = 1;
                var ret = p.data;
                n -= ret.length;
                while(p = p.next){
                    var str = p.data;
                    var nb = n > str.length ? str.length : n;
                    if (nb === str.length) ret += str;
                    else ret += str.slice(0, n);
                    n -= nb;
                    if (n === 0) {
                        if (nb === str.length) {
                            ++c;
                            if (p.next) this.head = p.next;
                            else this.head = this.tail = null;
                        } else {
                            this.head = p;
                            p.data = str.slice(nb);
                        }
                        break;
                    }
                    ++c;
                }
                this.length -= c;
                return ret;
            }
        },
        {
            key: "_getBuffer",
            value: function _getBuffer(n) {
                var ret = Buffer.allocUnsafe(n);
                var p = this.head;
                var c = 1;
                p.data.copy(ret);
                n -= p.data.length;
                while(p = p.next){
                    var buf = p.data;
                    var nb = n > buf.length ? buf.length : n;
                    buf.copy(ret, ret.length - n, 0, nb);
                    n -= nb;
                    if (n === 0) {
                        if (nb === buf.length) {
                            ++c;
                            if (p.next) this.head = p.next;
                            else this.head = this.tail = null;
                        } else {
                            this.head = p;
                            p.data = buf.slice(nb);
                        }
                        break;
                    }
                    ++c;
                }
                this.length -= c;
                return ret;
            }
        },
        {
            key: custom,
            value: function value(_, options) {
                return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
                    // Only inspect one level.
                    depth: 0,
                    // It should not recurse.
                    customInspect: false
                }));
            }
        }
    ]);
    return BufferList;
}();

},{"59f5d0111b7fa075":"fCgem","eef6a677577349b8":"jhUEF"}],"YI8DF":[function(require,module,exports) {
var process = require("4284522496af5dfb");
"use strict";
// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
        if (cb) cb(err);
        else if (err) {
            if (!this._writableState) process.nextTick(emitErrorNT, this, err);
            else if (!this._writableState.errorEmitted) {
                this._writableState.errorEmitted = true;
                process.nextTick(emitErrorNT, this, err);
            }
        }
        return this;
    }
    // we set destroyed to true before firing error callbacks in order
    // to make it re-entrance safe in case destroy() is called within callbacks
    if (this._readableState) this._readableState.destroyed = true;
    // if this is a duplex stream mark the writable part as destroyed as well
    if (this._writableState) this._writableState.destroyed = true;
    this._destroy(err || null, function(err) {
        if (!cb && err) {
            if (!_this._writableState) process.nextTick(emitErrorAndCloseNT, _this, err);
            else if (!_this._writableState.errorEmitted) {
                _this._writableState.errorEmitted = true;
                process.nextTick(emitErrorAndCloseNT, _this, err);
            } else process.nextTick(emitCloseNT, _this);
        } else if (cb) {
            process.nextTick(emitCloseNT, _this);
            cb(err);
        } else process.nextTick(emitCloseNT, _this);
    });
    return this;
}
function emitErrorAndCloseNT(self, err) {
    emitErrorNT(self, err);
    emitCloseNT(self);
}
function emitCloseNT(self) {
    if (self._writableState && !self._writableState.emitClose) return;
    if (self._readableState && !self._readableState.emitClose) return;
    self.emit("close");
}
function undestroy() {
    if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
    }
    if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
    }
}
function emitErrorNT(self, err) {
    self.emit("error", err);
}
function errorOrDestroy(stream, err) {
    // We have tests that rely on errors being emitted
    // in the same tick, so changing this is semver major.
    // For now when you opt-in to autoDestroy we allow
    // the error to be emitted nextTick. In a future
    // semver major update we should change the default to this.
    var rState = stream._readableState;
    var wState = stream._writableState;
    if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);
    else stream.emit("error", err);
}
module.exports = {
    destroy: destroy,
    undestroy: undestroy,
    errorOrDestroy: errorOrDestroy
};

},{"4284522496af5dfb":"d5jf4"}],"61BRN":[function(require,module,exports) {
"use strict";
var ERR_INVALID_OPT_VALUE = require("4e508d569e2117ef").codes.ERR_INVALID_OPT_VALUE;
function highWaterMarkFrom(options, isDuplex, duplexKey) {
    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}
function getHighWaterMark(state, options, duplexKey, isDuplex) {
    var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
    if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
            var name = isDuplex ? duplexKey : "highWaterMark";
            throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
    }
    // Default value
    return state.objectMode ? 16 : 16384;
}
module.exports = {
    getHighWaterMark: getHighWaterMark
};

},{"4e508d569e2117ef":"aJlwj"}],"aJlwj":[function(require,module,exports) {
"use strict";
function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
}
var codes = {};
function createErrorType(code, message, Base) {
    if (!Base) Base = Error;
    function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") return message;
        else return message(arg1, arg2, arg3);
    }
    var NodeError = /*#__PURE__*/ function(_Base) {
        _inheritsLoose(NodeError, _Base);
        function NodeError(arg1, arg2, arg3) {
            return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
        }
        return NodeError;
    }(Base);
    NodeError.prototype.name = Base.name;
    NodeError.prototype.code = code;
    codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js
function oneOf(expected, thing) {
    if (Array.isArray(expected)) {
        var len = expected.length;
        expected = expected.map(function(i) {
            return String(i);
        });
        if (len > 2) return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
        else if (len === 2) return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
        else return "of ".concat(thing, " ").concat(expected[0]);
    } else return "of ".concat(thing, " ").concat(String(expected));
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
function startsWith(str, search, pos) {
    return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
function endsWith(str, search, this_len) {
    if (this_len === undefined || this_len > str.length) this_len = str.length;
    return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
function includes(str, search, start) {
    if (typeof start !== "number") start = 0;
    if (start + search.length > str.length) return false;
    else return str.indexOf(search, start) !== -1;
}
createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
    return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
    // determiner: 'must be' or 'must not be'
    var determiner;
    if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
    } else determiner = "must be";
    var msg;
    if (endsWith(name, " argument")) // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
    else {
        var type = includes(name, ".") ? "property" : "argument";
        msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
    }
    msg += ". Received type ".concat(typeof actual);
    return msg;
}, TypeError);
createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
    return "The " + name + " method is not implemented";
});
createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
createErrorType("ERR_STREAM_DESTROYED", function(name) {
    return "Cannot call " + name + " after a stream was destroyed";
});
createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
    return "Unknown encoding: " + arg;
}, TypeError);
createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
module.exports.codes = codes;

},{}],"kKNA3":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.
var process = require("2ab1115635c50a9f");
"use strict";
/*<replacement>*/ var objectKeys = Object.keys || function(obj) {
    var keys = [];
    for(var key in obj)keys.push(key);
    return keys;
};
/*</replacement>*/ module.exports = Duplex;
var Readable = require("68a7582259cd5865");
var Writable = require("93d042f8bb80078e");
require("aa7b11ba5bf4defc")(Duplex, Readable);
// Allow the keys array to be GC'ed.
var keys = objectKeys(Writable.prototype);
for(var v = 0; v < keys.length; v++){
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
}
function Duplex(options) {
    if (!(this instanceof Duplex)) return new Duplex(options);
    Readable.call(this, options);
    Writable.call(this, options);
    this.allowHalfOpen = true;
    if (options) {
        if (options.readable === false) this.readable = false;
        if (options.writable === false) this.writable = false;
        if (options.allowHalfOpen === false) {
            this.allowHalfOpen = false;
            this.once("end", onend);
        }
    }
}
Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState.highWaterMark;
    }
});
Object.defineProperty(Duplex.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState && this._writableState.getBuffer();
    }
});
Object.defineProperty(Duplex.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState.length;
    }
});
// the no-half-open enforcer
function onend() {
    // If the writable side ended, then we're ok.
    if (this._writableState.ended) return;
    // no more data can be written.
    // But allow more writes to happen in this tick.
    process.nextTick(onEndNT, this);
}
function onEndNT(self) {
    self.end();
}
Object.defineProperty(Duplex.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        if (this._readableState === undefined || this._writableState === undefined) return false;
        return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function set(value) {
        // we ignore the value if the stream
        // has not been initialized yet
        if (this._readableState === undefined || this._writableState === undefined) return;
        // backward compatibility, the user is explicitly
        // managing destroyed
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
    }
});

},{"2ab1115635c50a9f":"d5jf4","68a7582259cd5865":"6NdbQ","93d042f8bb80078e":"gTkcq","aa7b11ba5bf4defc":"bRL3M"}],"gTkcq":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.
var global = arguments[3];
var process = require("f05a2a5a09d4d8b0");
"use strict";
module.exports = Writable;
/* <replacement> */ function WriteReq(chunk, encoding, cb) {
    this.chunk = chunk;
    this.encoding = encoding;
    this.callback = cb;
    this.next = null;
}
// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
        onCorkedFinish(_this, state);
    };
}
/* </replacement> */ /*<replacement>*/ var Duplex;
/*</replacement>*/ Writable.WritableState = WritableState;
/*<replacement>*/ var internalUtil = {
    deprecate: require("dc51171b07b54af1")
};
/*</replacement>*/ /*<replacement>*/ var Stream = require("44a3cc22ec64fcd3");
/*</replacement>*/ var Buffer = require("de8f7fb7ccda8086").Buffer;
var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {};
function _uint8ArrayToBuffer(chunk) {
    return Buffer.from(chunk);
}
function _isUint8Array(obj) {
    return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
var destroyImpl = require("acf48fb5d9dc6204");
var _require = require("9d146cd974da0f53"), getHighWaterMark = _require.getHighWaterMark;
var _require$codes = require("3c574b8881abcf86").codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
var errorOrDestroy = destroyImpl.errorOrDestroy;
require("10dad555ffe77dde")(Writable, Stream);
function nop() {}
function WritableState(options, stream, isDuplex) {
    Duplex = Duplex || require("c5e7171d6f58d3c0");
    options = options || {};
    // Duplex streams are both readable and writable, but share
    // the same options object.
    // However, some cases require setting options to different
    // values for the readable and the writable sides of the duplex stream,
    // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.
    if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
    // object stream flag to indicate whether or not this stream
    // contains buffers or objects.
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
    // the point at which write() starts returning false
    // Note: 0 is a valid value, means that we always return false if
    // the entire buffer is not flushed immediately on write()
    this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
    // if _final has been called
    this.finalCalled = false;
    // drain event flag.
    this.needDrain = false;
    // at the start of calling end()
    this.ending = false;
    // when end() has been called, and returned
    this.ended = false;
    // when 'finish' is emitted
    this.finished = false;
    // has it been destroyed
    this.destroyed = false;
    // should we decode strings into buffers before passing to _write?
    // this is here so that some node-core streams can optimize string
    // handling at a lower level.
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    // Crypto is kind of old and crusty.  Historically, its default string
    // encoding is 'binary' so we have to make this configurable.
    // Everything else in the universe uses 'utf8', though.
    this.defaultEncoding = options.defaultEncoding || "utf8";
    // not an actual buffer we keep track of, but a measurement
    // of how much we're waiting to get pushed to some underlying
    // socket or file.
    this.length = 0;
    // a flag to see when we're in the middle of a write.
    this.writing = false;
    // when true all writes will be buffered until .uncork() call
    this.corked = 0;
    // a flag to be able to tell if the onwrite cb is called immediately,
    // or on a later tick.  We set this to true at first, because any
    // actions that shouldn't happen until "later" should generally also
    // not happen before the first write call.
    this.sync = true;
    // a flag to know if we're processing previously buffered items, which
    // may call the _write() callback in the same tick, so that we don't
    // end up in an overlapped onwrite situation.
    this.bufferProcessing = false;
    // the callback that's passed to _write(chunk,cb)
    this.onwrite = function(er) {
        onwrite(stream, er);
    };
    // the callback that the user supplies to write(chunk,encoding,cb)
    this.writecb = null;
    // the amount that is being written when _write is called.
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    // number of pending user-supplied write callbacks
    // this must be 0 before 'finish' can be emitted
    this.pendingcb = 0;
    // emit prefinish if the only thing we're waiting for is _write cbs
    // This is relevant for synchronous Transform streams
    this.prefinished = false;
    // True if the error was already emitted and should not be thrown again
    this.errorEmitted = false;
    // Should close be emitted on destroy. Defaults to true.
    this.emitClose = options.emitClose !== false;
    // Should .destroy() be called after 'finish' (and potentially 'end')
    this.autoDestroy = !!options.autoDestroy;
    // count buffered requests
    this.bufferedRequestCount = 0;
    // allocate the first CorkedRequest, there is always
    // one allocated and free to use, and we maintain at most two
    this.corkedRequestsFree = new CorkedRequest(this);
}
WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while(current){
        out.push(current);
        current = current.next;
    }
    return out;
};
(function() {
    try {
        Object.defineProperty(WritableState.prototype, "buffer", {
            get: internalUtil.deprecate(function writableStateBufferGetter() {
                return this.getBuffer();
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
    } catch (_) {}
})();
// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function value(object) {
            if (realHasInstance.call(this, object)) return true;
            if (this !== Writable) return false;
            return object && object._writableState instanceof WritableState;
        }
    });
} else realHasInstance = function realHasInstance(object) {
    return object instanceof this;
};
function Writable(options) {
    Duplex = Duplex || require("c5e7171d6f58d3c0");
    // Writable ctor is applied to Duplexes, too.
    // `realHasInstance` is necessary because using plain `instanceof`
    // would return false, as no `_writableState` property is attached.
    // Trying to use the custom `instanceof` for Writable here will also break the
    // Node.js LazyTransform implementation, which has a non-trivial getter for
    // `_writableState` that would lead to infinite recursion.
    // Checking for a Stream.Duplex instance is faster here instead of inside
    // the WritableState constructor, at least with V8 6.5
    var isDuplex = this instanceof Duplex;
    if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
    this._writableState = new WritableState(options, this, isDuplex);
    // legacy.
    this.writable = true;
    if (options) {
        if (typeof options.write === "function") this._write = options.write;
        if (typeof options.writev === "function") this._writev = options.writev;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
        if (typeof options.final === "function") this._final = options.final;
    }
    Stream.call(this);
}
// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function() {
    errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};
function writeAfterEnd(stream, cb) {
    var er = new ERR_STREAM_WRITE_AFTER_END();
    // TODO: defer error events consistently everywhere, not just the cb
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
}
// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
    var er;
    if (chunk === null) er = new ERR_STREAM_NULL_VALUES();
    else if (typeof chunk !== "string" && !state.objectMode) er = new ERR_INVALID_ARG_TYPE("chunk", [
        "string",
        "Buffer"
    ], chunk);
    if (er) {
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
        return false;
    }
    return true;
}
Writable.prototype.write = function(chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;
    var isBuf = !state.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer.isBuffer(chunk)) chunk = _uint8ArrayToBuffer(chunk);
    if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
    }
    if (isBuf) encoding = "buffer";
    else if (!encoding) encoding = state.defaultEncoding;
    if (typeof cb !== "function") cb = nop;
    if (state.ending) writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
    }
    return ret;
};
Writable.prototype.cork = function() {
    this._writableState.corked++;
};
Writable.prototype.uncork = function() {
    var state = this._writableState;
    if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
    }
};
Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    // node::ParseEncoding() requires lower case.
    if (typeof encoding === "string") encoding = encoding.toLowerCase();
    if (!([
        "hex",
        "utf8",
        "utf-8",
        "ascii",
        "binary",
        "base64",
        "ucs2",
        "ucs-2",
        "utf16le",
        "utf-16le",
        "raw"
    ].indexOf((encoding + "").toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
};
Object.defineProperty(Writable.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState && this._writableState.getBuffer();
    }
});
function decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") chunk = Buffer.from(chunk, encoding);
    return chunk;
}
Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState.highWaterMark;
    }
});
// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
            isBuf = true;
            encoding = "buffer";
            chunk = newChunk;
        }
    }
    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark;
    // we must ensure that previous needDrain will not be reset to false.
    if (!ret) state.needDrain = true;
    if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
            chunk: chunk,
            encoding: encoding,
            isBuf: isBuf,
            callback: cb,
            next: null
        };
        if (last) last.next = state.lastBufferedRequest;
        else state.bufferedRequest = state.lastBufferedRequest;
        state.bufferedRequestCount += 1;
    } else doWrite(stream, state, false, len, chunk, encoding, cb);
    return ret;
}
function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED("write"));
    else if (writev) stream._writev(chunk, state.onwrite);
    else stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
}
function onwriteError(stream, state, sync, er, cb) {
    --state.pendingcb;
    if (sync) {
        // defer the callback if we are being called synchronously
        // to avoid piling up things on the stack
        process.nextTick(cb, er);
        // this can emit finish, and it will always happen
        // after error
        process.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
    } else {
        // the caller expect this to happen before if
        // it is async
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
        // this can emit finish, but finish must
        // always follow error
        finishMaybe(stream, state);
    }
}
function onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
}
function onwrite(stream, er) {
    var state = stream._writableState;
    var sync = state.sync;
    var cb = state.writecb;
    if (typeof cb !== "function") throw new ERR_MULTIPLE_CALLBACK();
    onwriteStateUpdate(state);
    if (er) onwriteError(stream, state, sync, er, cb);
    else {
        // Check if we're actually ready to finish, but don't emit yet
        var finished = needFinish(state) || stream.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(stream, state);
        if (sync) process.nextTick(afterWrite, stream, state, finished, cb);
        else afterWrite(stream, state, finished, cb);
    }
}
function afterWrite(stream, state, finished, cb) {
    if (!finished) onwriteDrain(stream, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream, state);
}
// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
    if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
    }
}
// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;
    if (stream._writev && entry && entry.next) {
        // Fast case, write everything using _writev()
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while(entry){
            buffer[count] = entry;
            if (!entry.isBuf) allBuffers = false;
            entry = entry.next;
            count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        // doWrite is almost always async, defer these to save a bit of time
        // as the hot path ends with doWrite
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
            state.corkedRequestsFree = holder.next;
            holder.next = null;
        } else state.corkedRequestsFree = new CorkedRequest(state);
        state.bufferedRequestCount = 0;
    } else {
        // Slow case, write chunks one-by-one
        while(entry){
            var chunk = entry.chunk;
            var encoding = entry.encoding;
            var cb = entry.callback;
            var len = state.objectMode ? 1 : chunk.length;
            doWrite(stream, state, false, len, chunk, encoding, cb);
            entry = entry.next;
            state.bufferedRequestCount--;
            // if we didn't call the onwrite immediately, then
            // it means that we need to wait until it does.
            // also, that means that the chunk and cb are currently
            // being processed, so move the buffer counter past them.
            if (state.writing) break;
        }
        if (entry === null) state.lastBufferedRequest = null;
    }
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
}
Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
};
Writable.prototype._writev = null;
Writable.prototype.end = function(chunk, encoding, cb) {
    var state = this._writableState;
    if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
    } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
    }
    if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);
    // .end() fully uncorks
    if (state.corked) {
        state.corked = 1;
        this.uncork();
    }
    // ignore unnecessary end() calls.
    if (!state.ending) endWritable(this, state, cb);
    return this;
};
Object.defineProperty(Writable.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState.length;
    }
});
function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
    stream._final(function(err) {
        state.pendingcb--;
        if (err) errorOrDestroy(stream, err);
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
    });
}
function prefinish(stream, state) {
    if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
            state.pendingcb++;
            state.finalCalled = true;
            process.nextTick(callFinal, stream, state);
        } else {
            state.prefinished = true;
            stream.emit("prefinish");
        }
    }
}
function finishMaybe(stream, state) {
    var need = needFinish(state);
    if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
            state.finished = true;
            stream.emit("finish");
            if (state.autoDestroy) {
                // In case of duplex streams we need a way to detect
                // if the readable side is ready for autoDestroy as well
                var rState = stream._readableState;
                if (!rState || rState.autoDestroy && rState.endEmitted) stream.destroy();
            }
        }
    }
    return need;
}
function endWritable(stream, state, cb) {
    state.ending = true;
    finishMaybe(stream, state);
    if (cb) {
        if (state.finished) process.nextTick(cb);
        else stream.once("finish", cb);
    }
    state.ended = true;
    stream.writable = false;
}
function onCorkedFinish(corkReq, state, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while(entry){
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
    }
    // reuse the free corkReq.
    state.corkedRequestsFree.next = corkReq;
}
Object.defineProperty(Writable.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        if (this._writableState === undefined) return false;
        return this._writableState.destroyed;
    },
    set: function set(value) {
        // we ignore the value if the stream
        // has not been initialized yet
        if (!this._writableState) return;
        // backward compatibility, the user is explicitly
        // managing destroyed
        this._writableState.destroyed = value;
    }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function(err, cb) {
    cb(err);
};

},{"f05a2a5a09d4d8b0":"d5jf4","dc51171b07b54af1":"j92NQ","44a3cc22ec64fcd3":"60BLS","de8f7fb7ccda8086":"fCgem","acf48fb5d9dc6204":"YI8DF","9d146cd974da0f53":"61BRN","3c574b8881abcf86":"aJlwj","10dad555ffe77dde":"bRL3M","c5e7171d6f58d3c0":"kKNA3"}],"j92NQ":[function(require,module,exports) {
/**
 * Module exports.
 */ var global = arguments[3];
module.exports = deprecate;
/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */ function deprecate(fn, msg) {
    if (config("noDeprecation")) return fn;
    var warned = false;
    function deprecated() {
        if (!warned) {
            if (config("throwDeprecation")) throw new Error(msg);
            else if (config("traceDeprecation")) console.trace(msg);
            else console.warn(msg);
            warned = true;
        }
        return fn.apply(this, arguments);
    }
    return deprecated;
}
/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */ function config(name) {
    // accessing global.localStorage can trigger a DOMException in sandboxed iframes
    try {
        if (!global.localStorage) return false;
    } catch (_) {
        return false;
    }
    var val = global.localStorage[name];
    if (null == val) return false;
    return String(val).toLowerCase() === "true";
}

},{}],"3vmkr":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
"use strict";
/*<replacement>*/ var Buffer = require("2a29807c689a070a").Buffer;
/*</replacement>*/ var isEncoding = Buffer.isEncoding || function(encoding) {
    encoding = "" + encoding;
    switch(encoding && encoding.toLowerCase()){
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
            return true;
        default:
            return false;
    }
};
function _normalizeEncoding(enc) {
    if (!enc) return "utf8";
    var retried;
    while(true)switch(enc){
        case "utf8":
        case "utf-8":
            return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return "utf16le";
        case "latin1":
        case "binary":
            return "latin1";
        case "base64":
        case "ascii":
        case "hex":
            return enc;
        default:
            if (retried) return; // undefined
            enc = ("" + enc).toLowerCase();
            retried = true;
    }
}
// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== "string" && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
}
// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch(this.encoding){
        case "utf16le":
            this.text = utf16Text;
            this.end = utf16End;
            nb = 4;
            break;
        case "utf8":
            this.fillLast = utf8FillLast;
            nb = 4;
            break;
        case "base64":
            this.text = base64Text;
            this.end = base64End;
            nb = 3;
            break;
        default:
            this.write = simpleWrite;
            this.end = simpleEnd;
            return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer.allocUnsafe(nb);
}
StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0) return "";
    var r;
    var i;
    if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === undefined) return "";
        i = this.lastNeed;
        this.lastNeed = 0;
    } else i = 0;
    if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || "";
};
StringDecoder.prototype.end = utf8End;
// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;
// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
};
// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
    if (byte <= 0x7F) return 0;
    else if (byte >> 5 === 0x06) return 2;
    else if (byte >> 4 === 0x0E) return 3;
    else if (byte >> 3 === 0x1E) return 4;
    return byte >> 6 === 0x02 ? -1 : -2;
}
// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
    var j = buf.length - 1;
    if (j < i) return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 1;
        return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 2;
        return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) {
            if (nb === 2) nb = 0;
            else self.lastNeed = nb - 3;
        }
        return nb;
    }
    return 0;
}
// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
    if ((buf[0] & 0xC0) !== 0x80) {
        self.lastNeed = 0;
        return "�";
    }
    if (self.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 0xC0) !== 0x80) {
            self.lastNeed = 1;
            return "�";
        }
        if (self.lastNeed > 2 && buf.length > 2) {
            if ((buf[2] & 0xC0) !== 0x80) {
                self.lastNeed = 2;
                return "�";
            }
        }
    }
}
// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf, p);
    if (r !== undefined) return r;
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
}
// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed) return buf.toString("utf8", i);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString("utf8", i, end);
}
// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + "�";
    return r;
}
// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
            var c = r.charCodeAt(r.length - 1);
            if (c >= 0xD800 && c <= 0xDBFF) {
                this.lastNeed = 2;
                this.lastTotal = 4;
                this.lastChar[0] = buf[buf.length - 2];
                this.lastChar[1] = buf[buf.length - 1];
                return r.slice(0, -1);
            }
        }
        return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString("utf16le", i, buf.length - 1);
}
// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
    }
    return r;
}
function base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0) return buf.toString("base64", i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) this.lastChar[0] = buf[buf.length - 1];
    else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i, buf.length - n);
}
function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r;
}
// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
    return buf.toString(this.encoding);
}
function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
}

},{"2a29807c689a070a":"eW7r9"}],"eW7r9":[function(require,module,exports) {
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */ /* eslint-disable node/no-deprecated-api */ var buffer = require("7e0d6ecd698c3ca6");
var Buffer = buffer.Buffer;
// alternative to using Object.keys for old browsers
function copyProps(src, dst) {
    for(var key in src)dst[key] = src[key];
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) module.exports = buffer;
else {
    // Copy properties from require('buffer')
    copyProps(buffer, exports);
    exports.Buffer = SafeBuffer;
}
function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer(arg, encodingOrOffset, length);
}
SafeBuffer.prototype = Object.create(Buffer.prototype);
// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer);
SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") throw new TypeError("Argument must not be a number");
    return Buffer(arg, encodingOrOffset, length);
};
SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") throw new TypeError("Argument must be a number");
    var buf = Buffer(size);
    if (fill !== undefined) {
        if (typeof encoding === "string") buf.fill(fill, encoding);
        else buf.fill(fill);
    } else buf.fill(0);
    return buf;
};
SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") throw new TypeError("Argument must be a number");
    return Buffer(size);
};
SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") throw new TypeError("Argument must be a number");
    return buffer.SlowBuffer(size);
};

},{"7e0d6ecd698c3ca6":"fCgem"}],"k019Y":[function(require,module,exports) {
var process = require("96b869862a96261a");
"use strict";
var _Object$setPrototypeO;
function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
}
var finished = require("745a3cd8f6469ed5");
var kLastResolve = Symbol("lastResolve");
var kLastReject = Symbol("lastReject");
var kError = Symbol("error");
var kEnded = Symbol("ended");
var kLastPromise = Symbol("lastPromise");
var kHandlePromise = Symbol("handlePromise");
var kStream = Symbol("stream");
function createIterResult(value, done) {
    return {
        value: value,
        done: done
    };
}
function readAndResolve(iter) {
    var resolve = iter[kLastResolve];
    if (resolve !== null) {
        var data = iter[kStream].read();
        // we defer if data is null
        // we can be expecting either 'end' or
        // 'error'
        if (data !== null) {
            iter[kLastPromise] = null;
            iter[kLastResolve] = null;
            iter[kLastReject] = null;
            resolve(createIterResult(data, false));
        }
    }
}
function onReadable(iter) {
    // we wait for the next tick, because it might
    // emit an error with process.nextTick
    process.nextTick(readAndResolve, iter);
}
function wrapForNext(lastPromise, iter) {
    return function(resolve, reject) {
        lastPromise.then(function() {
            if (iter[kEnded]) {
                resolve(createIterResult(undefined, true));
                return;
            }
            iter[kHandlePromise](resolve, reject);
        }, reject);
    };
}
var AsyncIteratorPrototype = Object.getPrototypeOf(function() {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
    get stream () {
        return this[kStream];
    },
    next: function next() {
        var _this = this;
        // if we have detected an error in the meanwhile
        // reject straight away
        var error = this[kError];
        if (error !== null) return Promise.reject(error);
        if (this[kEnded]) return Promise.resolve(createIterResult(undefined, true));
        if (this[kStream].destroyed) // We need to defer via nextTick because if .destroy(err) is
        // called, the error will be emitted via nextTick, and
        // we cannot guarantee that there is no error lingering around
        // waiting to be emitted.
        return new Promise(function(resolve, reject) {
            process.nextTick(function() {
                if (_this[kError]) reject(_this[kError]);
                else resolve(createIterResult(undefined, true));
            });
        });
        // if we have multiple next() calls
        // we will wait for the previous Promise to finish
        // this logic is optimized to support for await loops,
        // where next() is only called once at a time
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) promise = new Promise(wrapForNext(lastPromise, this));
        else {
            // fast path needed to support multiple this.push()
            // without triggering the next() queue
            var data = this[kStream].read();
            if (data !== null) return Promise.resolve(createIterResult(data, false));
            promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
    }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
    return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
    var _this2 = this;
    // destroy(err, cb) is a private API
    // we can guarantee we have that here, because we control the
    // Readable class this is attached to
    return new Promise(function(resolve, reject) {
        _this2[kStream].destroy(null, function(err) {
            if (err) {
                reject(err);
                return;
            }
            resolve(createIterResult(undefined, true));
        });
    });
}), _Object$setPrototypeO), AsyncIteratorPrototype);
var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
    var _Object$create;
    var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
    }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
    }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
    }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
    }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
    }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve, reject) {
            var data = iterator[kStream].read();
            if (data) {
                iterator[kLastPromise] = null;
                iterator[kLastResolve] = null;
                iterator[kLastReject] = null;
                resolve(createIterResult(data, false));
            } else {
                iterator[kLastResolve] = resolve;
                iterator[kLastReject] = reject;
            }
        },
        writable: true
    }), _Object$create));
    iterator[kLastPromise] = null;
    finished(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
            var reject = iterator[kLastReject];
            // reject if we are waiting for data in the Promise
            // returned by next() and store the error
            if (reject !== null) {
                iterator[kLastPromise] = null;
                iterator[kLastResolve] = null;
                iterator[kLastReject] = null;
                reject(err);
            }
            iterator[kError] = err;
            return;
        }
        var resolve = iterator[kLastResolve];
        if (resolve !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(undefined, true));
        }
        iterator[kEnded] = true;
    });
    stream.on("readable", onReadable.bind(null, iterator));
    return iterator;
};
module.exports = createReadableStreamAsyncIterator;

},{"96b869862a96261a":"d5jf4","745a3cd8f6469ed5":"aOMy2"}],"aOMy2":[function(require,module,exports) {
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).
"use strict";
var ERR_STREAM_PREMATURE_CLOSE = require("d35458f585bdd360").codes.ERR_STREAM_PREMATURE_CLOSE;
function once(callback) {
    var called = false;
    return function() {
        if (called) return;
        called = true;
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
        callback.apply(this, args);
    };
}
function noop() {}
function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
}
function eos(stream, opts, callback) {
    if (typeof opts === "function") return eos(stream, null, opts);
    if (!opts) opts = {};
    callback = once(callback || noop);
    var readable = opts.readable || opts.readable !== false && stream.readable;
    var writable = opts.writable || opts.writable !== false && stream.writable;
    var onlegacyfinish = function onlegacyfinish() {
        if (!stream.writable) onfinish();
    };
    var writableEnded = stream._writableState && stream._writableState.finished;
    var onfinish = function onfinish() {
        writable = false;
        writableEnded = true;
        if (!readable) callback.call(stream);
    };
    var readableEnded = stream._readableState && stream._readableState.endEmitted;
    var onend = function onend() {
        readable = false;
        readableEnded = true;
        if (!writable) callback.call(stream);
    };
    var onerror = function onerror(err) {
        callback.call(stream, err);
    };
    var onclose = function onclose() {
        var err;
        if (readable && !readableEnded) {
            if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
            if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
        }
    };
    var onrequest = function onrequest() {
        stream.req.on("finish", onfinish);
    };
    if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req) onrequest();
        else stream.on("request", onrequest);
    } else if (writable && !stream._writableState) {
        // legacy streams
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
    }
    stream.on("end", onend);
    stream.on("finish", onfinish);
    if (opts.error !== false) stream.on("error", onerror);
    stream.on("close", onclose);
    return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req) stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
    };
}
module.exports = eos;

},{"d35458f585bdd360":"aJlwj"}],"ak0YH":[function(require,module,exports) {
module.exports = function() {
    throw new Error("Readable.from is not available in the browser");
};

},{}],"ba8Mr":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.
"use strict";
module.exports = Transform;
var _require$codes = require("baab47252aa06434").codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
var Duplex = require("db11ebf938e536ed");
require("82049677fa603d40")(Transform, Duplex);
function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (cb === null) return this.emit("error", new ERR_MULTIPLE_CALLBACK());
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
}
function Transform(options) {
    if (!(this instanceof Transform)) return new Transform(options);
    Duplex.call(this, options);
    this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
    };
    // start out asking for a readable event once data is transformed.
    this._readableState.needReadable = true;
    // we have implemented the _read method, and done the other things
    // that Readable wants before the first _read call, so unset the
    // sync guard flag.
    this._readableState.sync = false;
    if (options) {
        if (typeof options.transform === "function") this._transform = options.transform;
        if (typeof options.flush === "function") this._flush = options.flush;
    }
    // When the writable side finishes, then flush out anything remaining.
    this.on("prefinish", prefinish);
}
function prefinish() {
    var _this = this;
    if (typeof this._flush === "function" && !this._readableState.destroyed) this._flush(function(er, data) {
        done(_this, er, data);
    });
    else done(this, null, null);
}
Transform.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
};
// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
};
Transform.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
    }
};
// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
};
Transform.prototype._destroy = function(err, cb) {
    Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
    });
};
function done(stream, er, data) {
    if (er) return stream.emit("error", er);
    if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);
    // TODO(BridgeAR): Write a test for these two error cases
    // if there's nothing in the write buffer, then that means
    // that nothing more will ever be provided
    if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
    if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
    return stream.push(null);
}

},{"baab47252aa06434":"aJlwj","db11ebf938e536ed":"kKNA3","82049677fa603d40":"bRL3M"}],"2xP98":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.
"use strict";
module.exports = PassThrough;
var Transform = require("7ab21291895ec3d2");
require("f24ec1883eef5e9b")(PassThrough, Transform);
function PassThrough(options) {
    if (!(this instanceof PassThrough)) return new PassThrough(options);
    Transform.call(this, options);
}
PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
};

},{"7ab21291895ec3d2":"ba8Mr","f24ec1883eef5e9b":"bRL3M"}],"fyp4t":[function(require,module,exports) {
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).
"use strict";
var eos;
function once(callback) {
    var called = false;
    return function() {
        if (called) return;
        called = true;
        callback.apply(void 0, arguments);
    };
}
var _require$codes = require("6ba21bd580ac7d57").codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
function noop(err) {
    // Rethrow the error if it exists to avoid swallowing it
    if (err) throw err;
}
function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
}
function destroyer(stream, reading, writing, callback) {
    callback = once(callback);
    var closed = false;
    stream.on("close", function() {
        closed = true;
    });
    if (eos === undefined) eos = require("dd7fd89dd81b8674");
    eos(stream, {
        readable: reading,
        writable: writing
    }, function(err) {
        if (err) return callback(err);
        closed = true;
        callback();
    });
    var destroyed = false;
    return function(err) {
        if (closed) return;
        if (destroyed) return;
        destroyed = true;
        // request.destroy just do .end - .abort is what we want
        if (isRequest(stream)) return stream.abort();
        if (typeof stream.destroy === "function") return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
    };
}
function call(fn) {
    fn();
}
function pipe(from, to) {
    return from.pipe(to);
}
function popCallback(streams) {
    if (!streams.length) return noop;
    if (typeof streams[streams.length - 1] !== "function") return noop;
    return streams.pop();
}
function pipeline() {
    for(var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++)streams[_key] = arguments[_key];
    var callback = popCallback(streams);
    if (Array.isArray(streams[0])) streams = streams[0];
    if (streams.length < 2) throw new ERR_MISSING_ARGS("streams");
    var error;
    var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
            if (!error) error = err;
            if (err) destroys.forEach(call);
            if (reading) return;
            destroys.forEach(call);
            callback(error);
        });
    });
    return streams.reduce(pipe);
}
module.exports = pipeline;

},{"6ba21bd580ac7d57":"aJlwj","dd7fd89dd81b8674":"aOMy2"}],"eE9w7":[function(require,module,exports) {
!function(e, t) {
    module.exports = t();
}(self, ()=>(()=>{
        "use strict";
        var e = {
            345: (e, t)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.forwardEvent = t.EventEmitter = void 0, t.EventEmitter = class {
                    constructor(){
                        this._listeners = [], this._disposed = !1;
                    }
                    get event() {
                        return this._event || (this._event = (e)=>(this._listeners.push(e), {
                                dispose: ()=>{
                                    if (!this._disposed) {
                                        for(let t = 0; t < this._listeners.length; t++)if (this._listeners[t] === e) return void this._listeners.splice(t, 1);
                                    }
                                }
                            })), this._event;
                    }
                    fire(e, t) {
                        const i = [];
                        for(let e = 0; e < this._listeners.length; e++)i.push(this._listeners[e]);
                        for(let s = 0; s < i.length; s++)i[s].call(void 0, e, t);
                    }
                    dispose() {
                        this._listeners && (this._listeners.length = 0), this._disposed = !0;
                    }
                }, t.forwardEvent = function(e, t) {
                    return e((e)=>t.fire(e));
                };
            },
            859: (e, t)=>{
                function i(e) {
                    for (const t of e)t.dispose();
                    e.length = 0;
                }
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.getDisposeArrayDisposable = t.disposeArray = t.toDisposable = t.Disposable = void 0, t.Disposable = class {
                    constructor(){
                        this._disposables = [], this._isDisposed = !1;
                    }
                    dispose() {
                        this._isDisposed = !0;
                        for (const e of this._disposables)e.dispose();
                        this._disposables.length = 0;
                    }
                    register(e) {
                        return this._disposables.push(e), e;
                    }
                    unregister(e) {
                        const t = this._disposables.indexOf(e);
                        -1 !== t && this._disposables.splice(t, 1);
                    }
                }, t.toDisposable = function(e) {
                    return {
                        dispose: e
                    };
                }, t.disposeArray = i, t.getDisposeArrayDisposable = function(e) {
                    return {
                        dispose: ()=>i(e)
                    };
                };
            }
        }, t = {};
        function i(s) {
            var r = t[s];
            if (void 0 !== r) return r.exports;
            var o = t[s] = {
                exports: {}
            };
            return e[s](o, o.exports, i), o.exports;
        }
        var s = {};
        return (()=>{
            var e = s;
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.SearchAddon = void 0;
            const t = i(345), r = i(859), o = " ~!@#$%^&*()+`-=[]{}|\\;:\"',./<>?";
            class n extends r.Disposable {
                constructor(e){
                    var i;
                    super(), this._highlightedLines = new Set, this._highlightDecorations = [], this._linesCacheTimeoutId = 0, this._onDidChangeResults = this.register(new t.EventEmitter), this.onDidChangeResults = this._onDidChangeResults.event, this._highlightLimit = null !== (i = null == e ? void 0 : e.highlightLimit) && void 0 !== i ? i : 1e3;
                }
                activate(e) {
                    this._terminal = e, this._onDataDisposable = this.register(this._terminal.onWriteParsed(()=>this._updateMatches())), this._onResizeDisposable = this.register(this._terminal.onResize(()=>this._updateMatches())), this.register((0, r.toDisposable)(()=>{
                        var e, t;
                        this.clearDecorations(), null === (e = this._onDataDisposable) || void 0 === e || e.dispose(), null === (t = this._onResizeDisposable) || void 0 === t || t.dispose();
                    }));
                }
                _updateMatches() {
                    var e;
                    this._highlightTimeout && window.clearTimeout(this._highlightTimeout), this._cachedSearchTerm && (null === (e = this._lastSearchOptions) || void 0 === e ? void 0 : e.decorations) && (this._highlightTimeout = setTimeout(()=>{
                        const e = this._cachedSearchTerm;
                        this._cachedSearchTerm = void 0, this.findPrevious(e, Object.assign(Object.assign({}, this._lastSearchOptions), {
                            incremental: !0,
                            noScroll: !0
                        }));
                    }, 200));
                }
                clearDecorations(e) {
                    this.clearActiveDecoration(), (0, r.disposeArray)(this._highlightDecorations), this._highlightDecorations = [], this._highlightedLines.clear(), e || (this._cachedSearchTerm = void 0);
                }
                clearActiveDecoration() {
                    var e;
                    null === (e = this._selectedDecoration) || void 0 === e || e.dispose(), this._selectedDecoration = void 0;
                }
                findNext(e, t) {
                    if (!this._terminal) throw new Error("Cannot use addon until it has been loaded");
                    this._lastSearchOptions = t, (null == t ? void 0 : t.decorations) && (void 0 !== this._cachedSearchTerm && e === this._cachedSearchTerm || this._highlightAllMatches(e, t));
                    const i = this._findNextAndSelect(e, t);
                    return this._fireResults(t), this._cachedSearchTerm = e, i;
                }
                _highlightAllMatches(e, t) {
                    if (!this._terminal) throw new Error("Cannot use addon until it has been loaded");
                    if (!e || 0 === e.length) return void this.clearDecorations();
                    t = t || {}, this.clearDecorations(!0);
                    const i = [];
                    let s, r = this._find(e, 0, 0, t);
                    for(; r && ((null == s ? void 0 : s.row) !== r.row || (null == s ? void 0 : s.col) !== r.col) && !(i.length >= this._highlightLimit);)s = r, i.push(s), r = this._find(e, s.col + s.term.length >= this._terminal.cols ? s.row + 1 : s.row, s.col + s.term.length >= this._terminal.cols ? 0 : s.col + 1, t);
                    for (const e of i){
                        const i = this._createResultDecoration(e, t.decorations);
                        i && (this._highlightedLines.add(i.marker.line), this._highlightDecorations.push({
                            decoration: i,
                            match: e,
                            dispose () {
                                i.dispose();
                            }
                        }));
                    }
                }
                _find(e, t, i, s) {
                    var r;
                    if (!this._terminal || !e || 0 === e.length) return null === (r = this._terminal) || void 0 === r || r.clearSelection(), void this.clearDecorations();
                    if (i > this._terminal.cols) throw new Error(`Invalid col: ${i} to search in terminal of ${this._terminal.cols} cols`);
                    let o;
                    this._initLinesCache();
                    const n = {
                        startRow: t,
                        startCol: i
                    };
                    if (o = this._findInLine(e, n, s), !o) for(let i = t + 1; i < this._terminal.buffer.active.baseY + this._terminal.rows && (n.startRow = i, n.startCol = 0, o = this._findInLine(e, n, s), !o); i++);
                    return o;
                }
                _findNextAndSelect(e, t) {
                    var i;
                    if (!this._terminal || !e || 0 === e.length) return null === (i = this._terminal) || void 0 === i || i.clearSelection(), this.clearDecorations(), !1;
                    const s = this._terminal.getSelectionPosition();
                    this._terminal.clearSelection();
                    let r = 0, o = 0;
                    s && (this._cachedSearchTerm === e ? (r = s.end.x, o = s.end.y) : (r = s.start.x, o = s.start.y)), this._initLinesCache();
                    const n = {
                        startRow: o,
                        startCol: r
                    };
                    let l = this._findInLine(e, n, t);
                    if (!l) for(let i = o + 1; i < this._terminal.buffer.active.baseY + this._terminal.rows && (n.startRow = i, n.startCol = 0, l = this._findInLine(e, n, t), !l); i++);
                    if (!l && 0 !== o) for(let i = 0; i < o && (n.startRow = i, n.startCol = 0, l = this._findInLine(e, n, t), !l); i++);
                    return !l && s && (n.startRow = s.start.y, n.startCol = 0, l = this._findInLine(e, n, t)), this._selectResult(l, null == t ? void 0 : t.decorations, null == t ? void 0 : t.noScroll);
                }
                findPrevious(e, t) {
                    if (!this._terminal) throw new Error("Cannot use addon until it has been loaded");
                    this._lastSearchOptions = t, (null == t ? void 0 : t.decorations) && (void 0 !== this._cachedSearchTerm && e === this._cachedSearchTerm || this._highlightAllMatches(e, t));
                    const i = this._findPreviousAndSelect(e, t);
                    return this._fireResults(t), this._cachedSearchTerm = e, i;
                }
                _fireResults(e) {
                    if (null == e ? void 0 : e.decorations) {
                        let e = -1;
                        if (this._selectedDecoration) {
                            const t = this._selectedDecoration.match;
                            for(let i = 0; i < this._highlightDecorations.length; i++){
                                const s = this._highlightDecorations[i].match;
                                if (s.row === t.row && s.col === t.col && s.size === t.size) {
                                    e = i;
                                    break;
                                }
                            }
                        }
                        this._onDidChangeResults.fire({
                            resultIndex: e,
                            resultCount: this._highlightDecorations.length
                        });
                    }
                }
                _findPreviousAndSelect(e, t) {
                    var i;
                    if (!this._terminal) throw new Error("Cannot use addon until it has been loaded");
                    if (!this._terminal || !e || 0 === e.length) return null === (i = this._terminal) || void 0 === i || i.clearSelection(), this.clearDecorations(), !1;
                    const s = this._terminal.getSelectionPosition();
                    this._terminal.clearSelection();
                    let r = this._terminal.buffer.active.baseY + this._terminal.rows - 1, o = this._terminal.cols;
                    const n = !0;
                    this._initLinesCache();
                    const l = {
                        startRow: r,
                        startCol: o
                    };
                    let h;
                    if (s && (l.startRow = r = s.start.y, l.startCol = o = s.start.x, this._cachedSearchTerm !== e && (h = this._findInLine(e, l, t, !1), h || (l.startRow = r = s.end.y, l.startCol = o = s.end.x))), h || (h = this._findInLine(e, l, t, n)), !h) {
                        l.startCol = Math.max(l.startCol, this._terminal.cols);
                        for(let i = r - 1; i >= 0 && (l.startRow = i, h = this._findInLine(e, l, t, n), !h); i--);
                    }
                    if (!h && r !== this._terminal.buffer.active.baseY + this._terminal.rows - 1) for(let i = this._terminal.buffer.active.baseY + this._terminal.rows - 1; i >= r && (l.startRow = i, h = this._findInLine(e, l, t, n), !h); i--);
                    return this._selectResult(h, null == t ? void 0 : t.decorations, null == t ? void 0 : t.noScroll);
                }
                _initLinesCache() {
                    const e = this._terminal;
                    this._linesCache || (this._linesCache = new Array(e.buffer.active.length), this._cursorMoveListener = e.onCursorMove(()=>this._destroyLinesCache()), this._resizeListener = e.onResize(()=>this._destroyLinesCache())), window.clearTimeout(this._linesCacheTimeoutId), this._linesCacheTimeoutId = window.setTimeout(()=>this._destroyLinesCache(), 15e3);
                }
                _destroyLinesCache() {
                    this._linesCache = void 0, this._cursorMoveListener && (this._cursorMoveListener.dispose(), this._cursorMoveListener = void 0), this._resizeListener && (this._resizeListener.dispose(), this._resizeListener = void 0), this._linesCacheTimeoutId && (window.clearTimeout(this._linesCacheTimeoutId), this._linesCacheTimeoutId = 0);
                }
                _isWholeWord(e, t, i) {
                    return (0 === e || o.includes(t[e - 1])) && (e + i.length === t.length || o.includes(t[e + i.length]));
                }
                _findInLine(e, t, i = {}, s = !1) {
                    var r;
                    const o = this._terminal, n = t.startRow, l = t.startCol, h = o.buffer.active.getLine(n);
                    if (null == h ? void 0 : h.isWrapped) return s ? void (t.startCol += o.cols) : (t.startRow--, t.startCol += o.cols, this._findInLine(e, t, i));
                    let a = null === (r = this._linesCache) || void 0 === r ? void 0 : r[n];
                    a || (a = this._translateBufferLineToStringWithWrap(n, !0), this._linesCache && (this._linesCache[n] = a));
                    const [c, d] = a, _ = this._bufferColsToStringOffset(n, l), u = i.caseSensitive ? e : e.toLowerCase(), f = i.caseSensitive ? c : c.toLowerCase();
                    let g = -1;
                    if (i.regex) {
                        const t = RegExp(u, "g");
                        let i;
                        if (s) for(; i = t.exec(f.slice(0, _));)g = t.lastIndex - i[0].length, e = i[0], t.lastIndex -= e.length - 1;
                        else i = t.exec(f.slice(_)), i && i[0].length > 0 && (g = _ + (t.lastIndex - i[0].length), e = i[0]);
                    } else s ? _ - u.length >= 0 && (g = f.lastIndexOf(u, _ - u.length)) : g = f.indexOf(u, _);
                    if (g >= 0) {
                        if (i.wholeWord && !this._isWholeWord(g, f, e)) return;
                        let t = 0;
                        for(; t < d.length - 1 && g >= d[t + 1];)t++;
                        let s = t;
                        for(; s < d.length - 1 && g + e.length >= d[s + 1];)s++;
                        const r = g - d[t], l = g + e.length - d[s], h = this._stringLengthToBufferSize(n + t, r);
                        return {
                            term: e,
                            col: h,
                            row: n + t,
                            size: this._stringLengthToBufferSize(n + s, l) - h + o.cols * (s - t)
                        };
                    }
                }
                _stringLengthToBufferSize(e, t) {
                    const i = this._terminal.buffer.active.getLine(e);
                    if (!i) return 0;
                    for(let e = 0; e < t; e++){
                        const s = i.getCell(e);
                        if (!s) break;
                        const r = s.getChars();
                        r.length > 1 && (t -= r.length - 1);
                        const o = i.getCell(e + 1);
                        o && 0 === o.getWidth() && t++;
                    }
                    return t;
                }
                _bufferColsToStringOffset(e, t) {
                    const i = this._terminal;
                    let s = e, r = 0, o = i.buffer.active.getLine(s);
                    for(; t > 0 && o;){
                        for(let e = 0; e < t && e < i.cols; e++){
                            const t = o.getCell(e);
                            if (!t) break;
                            t.getWidth() && (r += 0 === t.getCode() ? 1 : t.getChars().length);
                        }
                        if (s++, o = i.buffer.active.getLine(s), o && !o.isWrapped) break;
                        t -= i.cols;
                    }
                    return r;
                }
                _translateBufferLineToStringWithWrap(e, t) {
                    var i;
                    const s = this._terminal, r = [], o = [
                        0
                    ];
                    let n = s.buffer.active.getLine(e);
                    for(; n;){
                        const l = s.buffer.active.getLine(e + 1), h = !!l && l.isWrapped;
                        let a = n.translateToString(!h && t);
                        if (h && l) {
                            const e = n.getCell(n.length - 1);
                            e && 0 === e.getCode() && 1 === e.getWidth() && 2 === (null === (i = l.getCell(0)) || void 0 === i ? void 0 : i.getWidth()) && (a = a.slice(0, -1));
                        }
                        if (r.push(a), !h) break;
                        o.push(o[o.length - 1] + a.length), e++, n = l;
                    }
                    return [
                        r.join(""),
                        o
                    ];
                }
                _selectResult(e, t, i) {
                    const s = this._terminal;
                    if (this.clearActiveDecoration(), !e) return s.clearSelection(), !1;
                    if (s.select(e.col, e.row, e.size), t) {
                        const i = s.registerMarker(-s.buffer.active.baseY - s.buffer.active.cursorY + e.row);
                        if (i) {
                            const o = s.registerDecoration({
                                marker: i,
                                x: e.col,
                                width: e.size,
                                backgroundColor: t.activeMatchBackground,
                                layer: "top",
                                overviewRulerOptions: {
                                    color: t.activeMatchColorOverviewRuler
                                }
                            });
                            if (o) {
                                const s = [];
                                s.push(i), s.push(o.onRender((e)=>this._applyStyles(e, t.activeMatchBorder, !0))), s.push(o.onDispose(()=>(0, r.disposeArray)(s))), this._selectedDecoration = {
                                    decoration: o,
                                    match: e,
                                    dispose () {
                                        o.dispose();
                                    }
                                };
                            }
                        }
                    }
                    if (!i && (e.row >= s.buffer.active.viewportY + s.rows || e.row < s.buffer.active.viewportY)) {
                        let t = e.row - s.buffer.active.viewportY;
                        t -= Math.floor(s.rows / 2), s.scrollLines(t);
                    }
                    return !0;
                }
                _applyStyles(e, t, i) {
                    e.classList.contains("xterm-find-result-decoration") || (e.classList.add("xterm-find-result-decoration"), t && (e.style.outline = `1px solid ${t}`)), i && e.classList.add("xterm-find-active-result-decoration");
                }
                _createResultDecoration(e, t) {
                    const i = this._terminal, s = i.registerMarker(-i.buffer.active.baseY - i.buffer.active.cursorY + e.row);
                    if (!s) return;
                    const o = i.registerDecoration({
                        marker: s,
                        x: e.col,
                        width: e.size,
                        backgroundColor: t.matchBackground,
                        overviewRulerOptions: this._highlightedLines.has(s.line) ? void 0 : {
                            color: t.matchOverviewRuler,
                            position: "center"
                        }
                    });
                    if (o) {
                        const e = [];
                        e.push(s), e.push(o.onRender((e)=>this._applyStyles(e, t.matchBorder, !1))), e.push(o.onDispose(()=>(0, r.disposeArray)(e)));
                    }
                    return o;
                }
            }
            e.SearchAddon = n;
        })(), s;
    })());

},{}],"gojVV":[function(require,module,exports) {
!function(t, e) {
    module.exports = e();
}(this, ()=>(()=>{
        "use strict";
        var t = {};
        return (()=>{
            var e = t;
            function s(t, e, s) {
                return Math.max(e, Math.min(t, s));
            }
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.HTMLSerializeHandler = e.SerializeAddon = void 0;
            class i {
                constructor(t){
                    this._buffer = t;
                }
                serialize(t) {
                    const e = this._buffer.getNullCell(), s = this._buffer.getNullCell();
                    let i = e;
                    const r = t.start.x, l = t.end.x, o = t.start.y, n = t.end.y;
                    this._beforeSerialize(l - r, r, l);
                    for(let h = r; h <= l; h++){
                        const r = this._buffer.getLine(h);
                        if (r) {
                            const l = h !== t.start.x ? 0 : o, u = h !== t.end.x ? r.length : n;
                            for(let t = l; t < u; t++){
                                const l = r.getCell(t, i === e ? s : e);
                                l ? (this._nextCell(l, i, h, t), i = l) : console.warn(`Can't get cell at row=${h}, col=${t}`);
                            }
                        }
                        this._rowEnd(h, h === l);
                    }
                    return this._afterSerialize(), this._serializeString();
                }
                _nextCell(t, e, s, i) {}
                _rowEnd(t, e) {}
                _beforeSerialize(t, e, s) {}
                _afterSerialize() {}
                _serializeString() {
                    return "";
                }
            }
            function r(t, e) {
                return t.getFgColorMode() === e.getFgColorMode() && t.getFgColor() === e.getFgColor();
            }
            function l(t, e) {
                return t.getBgColorMode() === e.getBgColorMode() && t.getBgColor() === e.getBgColor();
            }
            function o(t, e) {
                return t.isInverse() === e.isInverse() && t.isBold() === e.isBold() && t.isUnderline() === e.isUnderline() && t.isOverline() === e.isOverline() && t.isBlink() === e.isBlink() && t.isInvisible() === e.isInvisible() && t.isItalic() === e.isItalic() && t.isDim() === e.isDim() && t.isStrikethrough() === e.isStrikethrough();
            }
            class n extends i {
                constructor(t, e){
                    super(t), this._terminal = e, this._rowIndex = 0, this._allRows = new Array, this._allRowSeparators = new Array, this._currentRow = "", this._nullCellCount = 0, this._cursorStyle = this._buffer.getNullCell(), this._cursorStyleRow = 0, this._cursorStyleCol = 0, this._backgroundCell = this._buffer.getNullCell(), this._firstRow = 0, this._lastCursorRow = 0, this._lastCursorCol = 0, this._lastContentCursorRow = 0, this._lastContentCursorCol = 0, this._thisRowLastChar = this._buffer.getNullCell(), this._thisRowLastSecondChar = this._buffer.getNullCell(), this._nextRowFirstChar = this._buffer.getNullCell();
                }
                _beforeSerialize(t, e, s) {
                    this._allRows = new Array(t), this._lastContentCursorRow = e, this._lastCursorRow = e, this._firstRow = e;
                }
                _rowEnd(t, e) {
                    var s;
                    this._nullCellCount > 0 && !l(this._cursorStyle, this._backgroundCell) && (this._currentRow += `[${this._nullCellCount}X`);
                    let i = "";
                    if (!e) {
                        t - this._firstRow >= this._terminal.rows && (null === (s = this._buffer.getLine(this._cursorStyleRow)) || void 0 === s || s.getCell(this._cursorStyleCol, this._backgroundCell));
                        const e = this._buffer.getLine(t), r = this._buffer.getLine(t + 1);
                        if (r.isWrapped) {
                            i = "";
                            const s = e.getCell(e.length - 1, this._thisRowLastChar), o = e.getCell(e.length - 2, this._thisRowLastSecondChar), n = r.getCell(0, this._nextRowFirstChar), h = n.getWidth() > 1;
                            let u = !1;
                            (n.getChars() && h ? this._nullCellCount <= 1 : this._nullCellCount <= 0) && ((s.getChars() || 0 === s.getWidth()) && l(s, n) && (u = !0), h && (o.getChars() || 0 === o.getWidth()) && l(s, n) && l(o, n) && (u = !0)), u || (i = "-".repeat(this._nullCellCount + 1), i += "\x1b[1D\x1b[1X", this._nullCellCount > 0 && (i += "\x1b[A", i += `[${e.length - this._nullCellCount}C`, i += `[${this._nullCellCount}X`, i += `[${e.length - this._nullCellCount}D`, i += "\x1b[B"), this._lastContentCursorRow = t + 1, this._lastContentCursorCol = 0, this._lastCursorRow = t + 1, this._lastCursorCol = 0);
                        } else i = "\r\n", this._lastCursorRow = t + 1, this._lastCursorCol = 0;
                    }
                    this._allRows[this._rowIndex] = this._currentRow, this._allRowSeparators[this._rowIndex++] = i, this._currentRow = "", this._nullCellCount = 0;
                }
                _diffStyle(t, e) {
                    const s = [], i = !r(t, e), n = !l(t, e), h = !o(t, e);
                    if (i || n || h) {
                        if (t.isAttributeDefault()) e.isAttributeDefault() || s.push(0);
                        else {
                            if (i) {
                                const e = t.getFgColor();
                                t.isFgRGB() ? s.push(38, 2, e >>> 16 & 255, e >>> 8 & 255, 255 & e) : t.isFgPalette() ? e >= 16 ? s.push(38, 5, e) : s.push(8 & e ? 90 + (7 & e) : 30 + (7 & e)) : s.push(39);
                            }
                            if (n) {
                                const e = t.getBgColor();
                                t.isBgRGB() ? s.push(48, 2, e >>> 16 & 255, e >>> 8 & 255, 255 & e) : t.isBgPalette() ? e >= 16 ? s.push(48, 5, e) : s.push(8 & e ? 100 + (7 & e) : 40 + (7 & e)) : s.push(49);
                            }
                            h && (t.isInverse() !== e.isInverse() && s.push(t.isInverse() ? 7 : 27), t.isBold() !== e.isBold() && s.push(t.isBold() ? 1 : 22), t.isUnderline() !== e.isUnderline() && s.push(t.isUnderline() ? 4 : 24), t.isOverline() !== e.isOverline() && s.push(t.isOverline() ? 53 : 55), t.isBlink() !== e.isBlink() && s.push(t.isBlink() ? 5 : 25), t.isInvisible() !== e.isInvisible() && s.push(t.isInvisible() ? 8 : 28), t.isItalic() !== e.isItalic() && s.push(t.isItalic() ? 3 : 23), t.isDim() !== e.isDim() && s.push(t.isDim() ? 2 : 22), t.isStrikethrough() !== e.isStrikethrough() && s.push(t.isStrikethrough() ? 9 : 29));
                        }
                    }
                    return s;
                }
                _nextCell(t, e, s, i) {
                    if (0 === t.getWidth()) return;
                    const r = "" === t.getChars(), o = this._diffStyle(t, this._cursorStyle);
                    if (r ? !l(this._cursorStyle, t) : o.length > 0) {
                        this._nullCellCount > 0 && (l(this._cursorStyle, this._backgroundCell) || (this._currentRow += `[${this._nullCellCount}X`), this._currentRow += `[${this._nullCellCount}C`, this._nullCellCount = 0), this._lastContentCursorRow = this._lastCursorRow = s, this._lastContentCursorCol = this._lastCursorCol = i, this._currentRow += `[${o.join(";")}m`;
                        const t = this._buffer.getLine(s);
                        void 0 !== t && (t.getCell(i, this._cursorStyle), this._cursorStyleRow = s, this._cursorStyleCol = i);
                    }
                    r ? this._nullCellCount += t.getWidth() : (this._nullCellCount > 0 && (l(this._cursorStyle, this._backgroundCell) || (this._currentRow += `[${this._nullCellCount}X`), this._currentRow += `[${this._nullCellCount}C`, this._nullCellCount = 0), this._currentRow += t.getChars(), this._lastContentCursorRow = this._lastCursorRow = s, this._lastContentCursorCol = this._lastCursorCol = i + t.getWidth());
                }
                _serializeString() {
                    let t = this._allRows.length;
                    this._buffer.length - this._firstRow <= this._terminal.rows && (t = this._lastContentCursorRow + 1 - this._firstRow, this._lastCursorCol = this._lastContentCursorCol, this._lastCursorRow = this._lastContentCursorRow);
                    let e = "";
                    for(let s = 0; s < t; s++)e += this._allRows[s], s + 1 < t && (e += this._allRowSeparators[s]);
                    const s = this._buffer.baseY + this._buffer.cursorY, i = this._buffer.cursorX;
                    var r;
                    (s !== this._lastCursorRow || i !== this._lastCursorCol) && ((r = s - this._lastCursorRow) > 0 ? e += `[${r}B` : r < 0 && (e += `[${-r}A`), ((t)=>{
                        t > 0 ? e += `[${t}C` : t < 0 && (e += `[${-t}D`);
                    })(i - this._lastCursorCol));
                    const l = this._terminal._core._inputHandler._curAttrData, o = this._diffStyle(l, this._cursorStyle);
                    return o.length > 0 && (e += `[${o.join(";")}m`), e;
                }
            }
            e.SerializeAddon = class {
                constructor(){}
                activate(t) {
                    this._terminal = t;
                }
                _serializeBuffer(t, e, i) {
                    const r = e.length, l = new n(e, t), o = void 0 === i ? r : s(i + t.rows, 0, r);
                    return l.serialize({
                        start: {
                            x: r - o,
                            y: 0
                        },
                        end: {
                            x: r - 1,
                            y: t.cols
                        }
                    });
                }
                _serializeBufferAsHTML(t, e) {
                    var i, r;
                    const l = t.buffer.active, o = new h(l, t, e);
                    if (null === (i = e.onlySelection) || void 0 === i || !i) {
                        const i = l.length, r = e.scrollback, n = void 0 === r ? i : s(r + t.rows, 0, i);
                        return o.serialize({
                            start: {
                                x: i - n,
                                y: 0
                            },
                            end: {
                                x: i - 1,
                                y: t.cols
                            }
                        });
                    }
                    const n = null === (r = this._terminal) || void 0 === r ? void 0 : r.getSelectionPosition();
                    return void 0 !== n ? o.serialize({
                        start: {
                            x: n.start.y,
                            y: n.start.x
                        },
                        end: {
                            x: n.end.y,
                            y: n.end.x
                        }
                    }) : "";
                }
                _serializeModes(t) {
                    let e = "";
                    const s = t.modes;
                    if (s.applicationCursorKeysMode && (e += "\x1b[?1h"), s.applicationKeypadMode && (e += "\x1b[?66h"), s.bracketedPasteMode && (e += "\x1b[?2004h"), s.insertMode && (e += "\x1b[4h"), s.originMode && (e += "\x1b[?6h"), s.reverseWraparoundMode && (e += "\x1b[?45h"), s.sendFocusMode && (e += "\x1b[?1004h"), !1 === s.wraparoundMode && (e += "\x1b[?7l"), "none" !== s.mouseTrackingMode) switch(s.mouseTrackingMode){
                        case "x10":
                            e += "\x1b[?9h";
                            break;
                        case "vt200":
                            e += "\x1b[?1000h";
                            break;
                        case "drag":
                            e += "\x1b[?1002h";
                            break;
                        case "any":
                            e += "\x1b[?1003h";
                    }
                    return e;
                }
                serialize(t) {
                    if (!this._terminal) throw new Error("Cannot use addon until it has been loaded");
                    let e = this._serializeBuffer(this._terminal, this._terminal.buffer.normal, null == t ? void 0 : t.scrollback);
                    return (null == t ? void 0 : t.excludeAltBuffer) || "alternate" !== this._terminal.buffer.active.type || (e += `[?1049h[H${this._serializeBuffer(this._terminal, this._terminal.buffer.alternate, void 0)}`), (null == t ? void 0 : t.excludeModes) || (e += this._serializeModes(this._terminal)), e;
                }
                serializeAsHTML(t) {
                    if (!this._terminal) throw new Error("Cannot use addon until it has been loaded");
                    return this._serializeBufferAsHTML(this._terminal, t || {});
                }
                dispose() {}
            };
            class h extends i {
                constructor(t, e, s){
                    super(t), this._terminal = e, this._options = s, this._currentRow = "", this._htmlContent = "", this._colors = e._core._themeService.colors;
                }
                _padStart(t, e, s) {
                    return e >>= 0, s = null != s ? s : " ", t.length > e ? t : ((e -= t.length) > s.length && (s += s.repeat(e / s.length)), s.slice(0, e) + t);
                }
                _beforeSerialize(t, e, s) {
                    var i, r, l, o, n;
                    this._htmlContent += "<html><body><!--StartFragment--><pre>";
                    let h = "#000000", u = "#ffffff";
                    null !== (i = this._options.includeGlobalBackground) && void 0 !== i && i && (h = null !== (l = null === (r = this._terminal.options.theme) || void 0 === r ? void 0 : r.foreground) && void 0 !== l ? l : "#ffffff", u = null !== (n = null === (o = this._terminal.options.theme) || void 0 === o ? void 0 : o.background) && void 0 !== n ? n : "#000000");
                    const a = [];
                    a.push("color: " + h + ";"), a.push("background-color: " + u + ";"), a.push("font-family: " + this._terminal.options.fontFamily + ";"), a.push("font-size: " + this._terminal.options.fontSize + "px;"), this._htmlContent += "<div style='" + a.join(" ") + "'>";
                }
                _afterSerialize() {
                    this._htmlContent += "</div>", this._htmlContent += "</pre><!--EndFragment--></body></html>";
                }
                _rowEnd(t, e) {
                    this._htmlContent += "<div><span>" + this._currentRow + "</span></div>", this._currentRow = "";
                }
                _getHexColor(t, e) {
                    const s = e ? t.getFgColor() : t.getBgColor();
                    return (e ? t.isFgRGB() : t.isBgRGB()) ? [
                        s >> 16 & 255,
                        s >> 8 & 255,
                        255 & s
                    ].map((t)=>this._padStart(t.toString(16), 2, "0")).join("") : (e ? t.isFgPalette() : t.isBgPalette()) ? this._colors.ansi[s].css : void 0;
                }
                _diffStyle(t, e) {
                    const s = [], i = !r(t, e), n = !l(t, e), h = !o(t, e);
                    if (i || n || h) {
                        const e = this._getHexColor(t, !0);
                        e && s.push("color: " + e + ";");
                        const i = this._getHexColor(t, !1);
                        return i && s.push("background-color: " + i + ";"), t.isInverse() && s.push("color: #000000; background-color: #BFBFBF;"), t.isBold() && s.push("font-weight: bold;"), t.isUnderline() && t.isOverline() ? s.push("text-decoration: overline underline;") : t.isUnderline() ? s.push("text-decoration: underline;") : t.isOverline() && s.push("text-decoration: overline;"), t.isBlink() && s.push("text-decoration: blink;"), t.isInvisible() && s.push("visibility: hidden;"), t.isItalic() && s.push("font-style: italic;"), t.isDim() && s.push("opacity: 0.5;"), t.isStrikethrough() && s.push("text-decoration: line-through;"), s;
                    }
                }
                _nextCell(t, e, s, i) {
                    if (0 === t.getWidth()) return;
                    const r = "" === t.getChars(), l = this._diffStyle(t, e);
                    l && (this._currentRow += 0 === l.length ? "</span><span>" : "</span><span style='" + l.join(" ") + "'>"), this._currentRow += r ? " " : t.getChars();
                }
                _serializeString() {
                    return this._htmlContent;
                }
            }
            e.HTMLSerializeHandler = h;
        })(), t;
    })());

},{}],"7BS3Y":[function(require,module,exports) {
!function(e, t) {
    module.exports = t();
}(this, function() {
    return (()=>{
        "use strict";
        var e = {
            433: (e, t)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.UnicodeV11 = void 0;
                const o = [
                    [
                        768,
                        879
                    ],
                    [
                        1155,
                        1161
                    ],
                    [
                        1425,
                        1469
                    ],
                    [
                        1471,
                        1471
                    ],
                    [
                        1473,
                        1474
                    ],
                    [
                        1476,
                        1477
                    ],
                    [
                        1479,
                        1479
                    ],
                    [
                        1536,
                        1541
                    ],
                    [
                        1552,
                        1562
                    ],
                    [
                        1564,
                        1564
                    ],
                    [
                        1611,
                        1631
                    ],
                    [
                        1648,
                        1648
                    ],
                    [
                        1750,
                        1757
                    ],
                    [
                        1759,
                        1764
                    ],
                    [
                        1767,
                        1768
                    ],
                    [
                        1770,
                        1773
                    ],
                    [
                        1807,
                        1807
                    ],
                    [
                        1809,
                        1809
                    ],
                    [
                        1840,
                        1866
                    ],
                    [
                        1958,
                        1968
                    ],
                    [
                        2027,
                        2035
                    ],
                    [
                        2045,
                        2045
                    ],
                    [
                        2070,
                        2073
                    ],
                    [
                        2075,
                        2083
                    ],
                    [
                        2085,
                        2087
                    ],
                    [
                        2089,
                        2093
                    ],
                    [
                        2137,
                        2139
                    ],
                    [
                        2259,
                        2306
                    ],
                    [
                        2362,
                        2362
                    ],
                    [
                        2364,
                        2364
                    ],
                    [
                        2369,
                        2376
                    ],
                    [
                        2381,
                        2381
                    ],
                    [
                        2385,
                        2391
                    ],
                    [
                        2402,
                        2403
                    ],
                    [
                        2433,
                        2433
                    ],
                    [
                        2492,
                        2492
                    ],
                    [
                        2497,
                        2500
                    ],
                    [
                        2509,
                        2509
                    ],
                    [
                        2530,
                        2531
                    ],
                    [
                        2558,
                        2558
                    ],
                    [
                        2561,
                        2562
                    ],
                    [
                        2620,
                        2620
                    ],
                    [
                        2625,
                        2626
                    ],
                    [
                        2631,
                        2632
                    ],
                    [
                        2635,
                        2637
                    ],
                    [
                        2641,
                        2641
                    ],
                    [
                        2672,
                        2673
                    ],
                    [
                        2677,
                        2677
                    ],
                    [
                        2689,
                        2690
                    ],
                    [
                        2748,
                        2748
                    ],
                    [
                        2753,
                        2757
                    ],
                    [
                        2759,
                        2760
                    ],
                    [
                        2765,
                        2765
                    ],
                    [
                        2786,
                        2787
                    ],
                    [
                        2810,
                        2815
                    ],
                    [
                        2817,
                        2817
                    ],
                    [
                        2876,
                        2876
                    ],
                    [
                        2879,
                        2879
                    ],
                    [
                        2881,
                        2884
                    ],
                    [
                        2893,
                        2893
                    ],
                    [
                        2902,
                        2902
                    ],
                    [
                        2914,
                        2915
                    ],
                    [
                        2946,
                        2946
                    ],
                    [
                        3008,
                        3008
                    ],
                    [
                        3021,
                        3021
                    ],
                    [
                        3072,
                        3072
                    ],
                    [
                        3076,
                        3076
                    ],
                    [
                        3134,
                        3136
                    ],
                    [
                        3142,
                        3144
                    ],
                    [
                        3146,
                        3149
                    ],
                    [
                        3157,
                        3158
                    ],
                    [
                        3170,
                        3171
                    ],
                    [
                        3201,
                        3201
                    ],
                    [
                        3260,
                        3260
                    ],
                    [
                        3263,
                        3263
                    ],
                    [
                        3270,
                        3270
                    ],
                    [
                        3276,
                        3277
                    ],
                    [
                        3298,
                        3299
                    ],
                    [
                        3328,
                        3329
                    ],
                    [
                        3387,
                        3388
                    ],
                    [
                        3393,
                        3396
                    ],
                    [
                        3405,
                        3405
                    ],
                    [
                        3426,
                        3427
                    ],
                    [
                        3530,
                        3530
                    ],
                    [
                        3538,
                        3540
                    ],
                    [
                        3542,
                        3542
                    ],
                    [
                        3633,
                        3633
                    ],
                    [
                        3636,
                        3642
                    ],
                    [
                        3655,
                        3662
                    ],
                    [
                        3761,
                        3761
                    ],
                    [
                        3764,
                        3772
                    ],
                    [
                        3784,
                        3789
                    ],
                    [
                        3864,
                        3865
                    ],
                    [
                        3893,
                        3893
                    ],
                    [
                        3895,
                        3895
                    ],
                    [
                        3897,
                        3897
                    ],
                    [
                        3953,
                        3966
                    ],
                    [
                        3968,
                        3972
                    ],
                    [
                        3974,
                        3975
                    ],
                    [
                        3981,
                        3991
                    ],
                    [
                        3993,
                        4028
                    ],
                    [
                        4038,
                        4038
                    ],
                    [
                        4141,
                        4144
                    ],
                    [
                        4146,
                        4151
                    ],
                    [
                        4153,
                        4154
                    ],
                    [
                        4157,
                        4158
                    ],
                    [
                        4184,
                        4185
                    ],
                    [
                        4190,
                        4192
                    ],
                    [
                        4209,
                        4212
                    ],
                    [
                        4226,
                        4226
                    ],
                    [
                        4229,
                        4230
                    ],
                    [
                        4237,
                        4237
                    ],
                    [
                        4253,
                        4253
                    ],
                    [
                        4448,
                        4607
                    ],
                    [
                        4957,
                        4959
                    ],
                    [
                        5906,
                        5908
                    ],
                    [
                        5938,
                        5940
                    ],
                    [
                        5970,
                        5971
                    ],
                    [
                        6002,
                        6003
                    ],
                    [
                        6068,
                        6069
                    ],
                    [
                        6071,
                        6077
                    ],
                    [
                        6086,
                        6086
                    ],
                    [
                        6089,
                        6099
                    ],
                    [
                        6109,
                        6109
                    ],
                    [
                        6155,
                        6158
                    ],
                    [
                        6277,
                        6278
                    ],
                    [
                        6313,
                        6313
                    ],
                    [
                        6432,
                        6434
                    ],
                    [
                        6439,
                        6440
                    ],
                    [
                        6450,
                        6450
                    ],
                    [
                        6457,
                        6459
                    ],
                    [
                        6679,
                        6680
                    ],
                    [
                        6683,
                        6683
                    ],
                    [
                        6742,
                        6742
                    ],
                    [
                        6744,
                        6750
                    ],
                    [
                        6752,
                        6752
                    ],
                    [
                        6754,
                        6754
                    ],
                    [
                        6757,
                        6764
                    ],
                    [
                        6771,
                        6780
                    ],
                    [
                        6783,
                        6783
                    ],
                    [
                        6832,
                        6846
                    ],
                    [
                        6912,
                        6915
                    ],
                    [
                        6964,
                        6964
                    ],
                    [
                        6966,
                        6970
                    ],
                    [
                        6972,
                        6972
                    ],
                    [
                        6978,
                        6978
                    ],
                    [
                        7019,
                        7027
                    ],
                    [
                        7040,
                        7041
                    ],
                    [
                        7074,
                        7077
                    ],
                    [
                        7080,
                        7081
                    ],
                    [
                        7083,
                        7085
                    ],
                    [
                        7142,
                        7142
                    ],
                    [
                        7144,
                        7145
                    ],
                    [
                        7149,
                        7149
                    ],
                    [
                        7151,
                        7153
                    ],
                    [
                        7212,
                        7219
                    ],
                    [
                        7222,
                        7223
                    ],
                    [
                        7376,
                        7378
                    ],
                    [
                        7380,
                        7392
                    ],
                    [
                        7394,
                        7400
                    ],
                    [
                        7405,
                        7405
                    ],
                    [
                        7412,
                        7412
                    ],
                    [
                        7416,
                        7417
                    ],
                    [
                        7616,
                        7673
                    ],
                    [
                        7675,
                        7679
                    ],
                    [
                        8203,
                        8207
                    ],
                    [
                        8234,
                        8238
                    ],
                    [
                        8288,
                        8292
                    ],
                    [
                        8294,
                        8303
                    ],
                    [
                        8400,
                        8432
                    ],
                    [
                        11503,
                        11505
                    ],
                    [
                        11647,
                        11647
                    ],
                    [
                        11744,
                        11775
                    ],
                    [
                        12330,
                        12333
                    ],
                    [
                        12441,
                        12442
                    ],
                    [
                        42607,
                        42610
                    ],
                    [
                        42612,
                        42621
                    ],
                    [
                        42654,
                        42655
                    ],
                    [
                        42736,
                        42737
                    ],
                    [
                        43010,
                        43010
                    ],
                    [
                        43014,
                        43014
                    ],
                    [
                        43019,
                        43019
                    ],
                    [
                        43045,
                        43046
                    ],
                    [
                        43204,
                        43205
                    ],
                    [
                        43232,
                        43249
                    ],
                    [
                        43263,
                        43263
                    ],
                    [
                        43302,
                        43309
                    ],
                    [
                        43335,
                        43345
                    ],
                    [
                        43392,
                        43394
                    ],
                    [
                        43443,
                        43443
                    ],
                    [
                        43446,
                        43449
                    ],
                    [
                        43452,
                        43453
                    ],
                    [
                        43493,
                        43493
                    ],
                    [
                        43561,
                        43566
                    ],
                    [
                        43569,
                        43570
                    ],
                    [
                        43573,
                        43574
                    ],
                    [
                        43587,
                        43587
                    ],
                    [
                        43596,
                        43596
                    ],
                    [
                        43644,
                        43644
                    ],
                    [
                        43696,
                        43696
                    ],
                    [
                        43698,
                        43700
                    ],
                    [
                        43703,
                        43704
                    ],
                    [
                        43710,
                        43711
                    ],
                    [
                        43713,
                        43713
                    ],
                    [
                        43756,
                        43757
                    ],
                    [
                        43766,
                        43766
                    ],
                    [
                        44005,
                        44005
                    ],
                    [
                        44008,
                        44008
                    ],
                    [
                        44013,
                        44013
                    ],
                    [
                        64286,
                        64286
                    ],
                    [
                        65024,
                        65039
                    ],
                    [
                        65056,
                        65071
                    ],
                    [
                        65279,
                        65279
                    ],
                    [
                        65529,
                        65531
                    ]
                ], n = [
                    [
                        66045,
                        66045
                    ],
                    [
                        66272,
                        66272
                    ],
                    [
                        66422,
                        66426
                    ],
                    [
                        68097,
                        68099
                    ],
                    [
                        68101,
                        68102
                    ],
                    [
                        68108,
                        68111
                    ],
                    [
                        68152,
                        68154
                    ],
                    [
                        68159,
                        68159
                    ],
                    [
                        68325,
                        68326
                    ],
                    [
                        68900,
                        68903
                    ],
                    [
                        69446,
                        69456
                    ],
                    [
                        69633,
                        69633
                    ],
                    [
                        69688,
                        69702
                    ],
                    [
                        69759,
                        69761
                    ],
                    [
                        69811,
                        69814
                    ],
                    [
                        69817,
                        69818
                    ],
                    [
                        69821,
                        69821
                    ],
                    [
                        69837,
                        69837
                    ],
                    [
                        69888,
                        69890
                    ],
                    [
                        69927,
                        69931
                    ],
                    [
                        69933,
                        69940
                    ],
                    [
                        70003,
                        70003
                    ],
                    [
                        70016,
                        70017
                    ],
                    [
                        70070,
                        70078
                    ],
                    [
                        70089,
                        70092
                    ],
                    [
                        70191,
                        70193
                    ],
                    [
                        70196,
                        70196
                    ],
                    [
                        70198,
                        70199
                    ],
                    [
                        70206,
                        70206
                    ],
                    [
                        70367,
                        70367
                    ],
                    [
                        70371,
                        70378
                    ],
                    [
                        70400,
                        70401
                    ],
                    [
                        70459,
                        70460
                    ],
                    [
                        70464,
                        70464
                    ],
                    [
                        70502,
                        70508
                    ],
                    [
                        70512,
                        70516
                    ],
                    [
                        70712,
                        70719
                    ],
                    [
                        70722,
                        70724
                    ],
                    [
                        70726,
                        70726
                    ],
                    [
                        70750,
                        70750
                    ],
                    [
                        70835,
                        70840
                    ],
                    [
                        70842,
                        70842
                    ],
                    [
                        70847,
                        70848
                    ],
                    [
                        70850,
                        70851
                    ],
                    [
                        71090,
                        71093
                    ],
                    [
                        71100,
                        71101
                    ],
                    [
                        71103,
                        71104
                    ],
                    [
                        71132,
                        71133
                    ],
                    [
                        71219,
                        71226
                    ],
                    [
                        71229,
                        71229
                    ],
                    [
                        71231,
                        71232
                    ],
                    [
                        71339,
                        71339
                    ],
                    [
                        71341,
                        71341
                    ],
                    [
                        71344,
                        71349
                    ],
                    [
                        71351,
                        71351
                    ],
                    [
                        71453,
                        71455
                    ],
                    [
                        71458,
                        71461
                    ],
                    [
                        71463,
                        71467
                    ],
                    [
                        71727,
                        71735
                    ],
                    [
                        71737,
                        71738
                    ],
                    [
                        72148,
                        72151
                    ],
                    [
                        72154,
                        72155
                    ],
                    [
                        72160,
                        72160
                    ],
                    [
                        72193,
                        72202
                    ],
                    [
                        72243,
                        72248
                    ],
                    [
                        72251,
                        72254
                    ],
                    [
                        72263,
                        72263
                    ],
                    [
                        72273,
                        72278
                    ],
                    [
                        72281,
                        72283
                    ],
                    [
                        72330,
                        72342
                    ],
                    [
                        72344,
                        72345
                    ],
                    [
                        72752,
                        72758
                    ],
                    [
                        72760,
                        72765
                    ],
                    [
                        72767,
                        72767
                    ],
                    [
                        72850,
                        72871
                    ],
                    [
                        72874,
                        72880
                    ],
                    [
                        72882,
                        72883
                    ],
                    [
                        72885,
                        72886
                    ],
                    [
                        73009,
                        73014
                    ],
                    [
                        73018,
                        73018
                    ],
                    [
                        73020,
                        73021
                    ],
                    [
                        73023,
                        73029
                    ],
                    [
                        73031,
                        73031
                    ],
                    [
                        73104,
                        73105
                    ],
                    [
                        73109,
                        73109
                    ],
                    [
                        73111,
                        73111
                    ],
                    [
                        73459,
                        73460
                    ],
                    [
                        78896,
                        78904
                    ],
                    [
                        92912,
                        92916
                    ],
                    [
                        92976,
                        92982
                    ],
                    [
                        94031,
                        94031
                    ],
                    [
                        94095,
                        94098
                    ],
                    [
                        113821,
                        113822
                    ],
                    [
                        113824,
                        113827
                    ],
                    [
                        119143,
                        119145
                    ],
                    [
                        119155,
                        119170
                    ],
                    [
                        119173,
                        119179
                    ],
                    [
                        119210,
                        119213
                    ],
                    [
                        119362,
                        119364
                    ],
                    [
                        121344,
                        121398
                    ],
                    [
                        121403,
                        121452
                    ],
                    [
                        121461,
                        121461
                    ],
                    [
                        121476,
                        121476
                    ],
                    [
                        121499,
                        121503
                    ],
                    [
                        121505,
                        121519
                    ],
                    [
                        122880,
                        122886
                    ],
                    [
                        122888,
                        122904
                    ],
                    [
                        122907,
                        122913
                    ],
                    [
                        122915,
                        122916
                    ],
                    [
                        122918,
                        122922
                    ],
                    [
                        123184,
                        123190
                    ],
                    [
                        123628,
                        123631
                    ],
                    [
                        125136,
                        125142
                    ],
                    [
                        125252,
                        125258
                    ],
                    [
                        917505,
                        917505
                    ],
                    [
                        917536,
                        917631
                    ],
                    [
                        917760,
                        917999
                    ]
                ], r = [
                    [
                        4352,
                        4447
                    ],
                    [
                        8986,
                        8987
                    ],
                    [
                        9001,
                        9002
                    ],
                    [
                        9193,
                        9196
                    ],
                    [
                        9200,
                        9200
                    ],
                    [
                        9203,
                        9203
                    ],
                    [
                        9725,
                        9726
                    ],
                    [
                        9748,
                        9749
                    ],
                    [
                        9800,
                        9811
                    ],
                    [
                        9855,
                        9855
                    ],
                    [
                        9875,
                        9875
                    ],
                    [
                        9889,
                        9889
                    ],
                    [
                        9898,
                        9899
                    ],
                    [
                        9917,
                        9918
                    ],
                    [
                        9924,
                        9925
                    ],
                    [
                        9934,
                        9934
                    ],
                    [
                        9940,
                        9940
                    ],
                    [
                        9962,
                        9962
                    ],
                    [
                        9970,
                        9971
                    ],
                    [
                        9973,
                        9973
                    ],
                    [
                        9978,
                        9978
                    ],
                    [
                        9981,
                        9981
                    ],
                    [
                        9989,
                        9989
                    ],
                    [
                        9994,
                        9995
                    ],
                    [
                        10024,
                        10024
                    ],
                    [
                        10060,
                        10060
                    ],
                    [
                        10062,
                        10062
                    ],
                    [
                        10067,
                        10069
                    ],
                    [
                        10071,
                        10071
                    ],
                    [
                        10133,
                        10135
                    ],
                    [
                        10160,
                        10160
                    ],
                    [
                        10175,
                        10175
                    ],
                    [
                        11035,
                        11036
                    ],
                    [
                        11088,
                        11088
                    ],
                    [
                        11093,
                        11093
                    ],
                    [
                        11904,
                        11929
                    ],
                    [
                        11931,
                        12019
                    ],
                    [
                        12032,
                        12245
                    ],
                    [
                        12272,
                        12283
                    ],
                    [
                        12288,
                        12329
                    ],
                    [
                        12334,
                        12350
                    ],
                    [
                        12353,
                        12438
                    ],
                    [
                        12443,
                        12543
                    ],
                    [
                        12549,
                        12591
                    ],
                    [
                        12593,
                        12686
                    ],
                    [
                        12688,
                        12730
                    ],
                    [
                        12736,
                        12771
                    ],
                    [
                        12784,
                        12830
                    ],
                    [
                        12832,
                        12871
                    ],
                    [
                        12880,
                        19903
                    ],
                    [
                        19968,
                        42124
                    ],
                    [
                        42128,
                        42182
                    ],
                    [
                        43360,
                        43388
                    ],
                    [
                        44032,
                        55203
                    ],
                    [
                        63744,
                        64255
                    ],
                    [
                        65040,
                        65049
                    ],
                    [
                        65072,
                        65106
                    ],
                    [
                        65108,
                        65126
                    ],
                    [
                        65128,
                        65131
                    ],
                    [
                        65281,
                        65376
                    ],
                    [
                        65504,
                        65510
                    ]
                ], i = [
                    [
                        94176,
                        94179
                    ],
                    [
                        94208,
                        100343
                    ],
                    [
                        100352,
                        101106
                    ],
                    [
                        110592,
                        110878
                    ],
                    [
                        110928,
                        110930
                    ],
                    [
                        110948,
                        110951
                    ],
                    [
                        110960,
                        111355
                    ],
                    [
                        126980,
                        126980
                    ],
                    [
                        127183,
                        127183
                    ],
                    [
                        127374,
                        127374
                    ],
                    [
                        127377,
                        127386
                    ],
                    [
                        127488,
                        127490
                    ],
                    [
                        127504,
                        127547
                    ],
                    [
                        127552,
                        127560
                    ],
                    [
                        127568,
                        127569
                    ],
                    [
                        127584,
                        127589
                    ],
                    [
                        127744,
                        127776
                    ],
                    [
                        127789,
                        127797
                    ],
                    [
                        127799,
                        127868
                    ],
                    [
                        127870,
                        127891
                    ],
                    [
                        127904,
                        127946
                    ],
                    [
                        127951,
                        127955
                    ],
                    [
                        127968,
                        127984
                    ],
                    [
                        127988,
                        127988
                    ],
                    [
                        127992,
                        128062
                    ],
                    [
                        128064,
                        128064
                    ],
                    [
                        128066,
                        128252
                    ],
                    [
                        128255,
                        128317
                    ],
                    [
                        128331,
                        128334
                    ],
                    [
                        128336,
                        128359
                    ],
                    [
                        128378,
                        128378
                    ],
                    [
                        128405,
                        128406
                    ],
                    [
                        128420,
                        128420
                    ],
                    [
                        128507,
                        128591
                    ],
                    [
                        128640,
                        128709
                    ],
                    [
                        128716,
                        128716
                    ],
                    [
                        128720,
                        128722
                    ],
                    [
                        128725,
                        128725
                    ],
                    [
                        128747,
                        128748
                    ],
                    [
                        128756,
                        128762
                    ],
                    [
                        128992,
                        129003
                    ],
                    [
                        129293,
                        129393
                    ],
                    [
                        129395,
                        129398
                    ],
                    [
                        129402,
                        129442
                    ],
                    [
                        129445,
                        129450
                    ],
                    [
                        129454,
                        129482
                    ],
                    [
                        129485,
                        129535
                    ],
                    [
                        129648,
                        129651
                    ],
                    [
                        129656,
                        129658
                    ],
                    [
                        129664,
                        129666
                    ],
                    [
                        129680,
                        129685
                    ],
                    [
                        131072,
                        196605
                    ],
                    [
                        196608,
                        262141
                    ]
                ];
                let d;
                function c(e, t) {
                    let o, n = 0, r = t.length - 1;
                    if (e < t[0][0] || e > t[r][1]) return !1;
                    for(; r >= n;)if (o = n + r >> 1, e > t[o][1]) n = o + 1;
                    else {
                        if (!(e < t[o][0])) return !0;
                        r = o - 1;
                    }
                    return !1;
                }
                t.UnicodeV11 = class {
                    constructor(){
                        if (this.version = "11", !d) {
                            d = new Uint8Array(65536), d.fill(1), d[0] = 0, d.fill(0, 1, 32), d.fill(0, 127, 160);
                            for(let e = 0; e < o.length; ++e)d.fill(0, o[e][0], o[e][1] + 1);
                            for(let e = 0; e < r.length; ++e)d.fill(2, r[e][0], r[e][1] + 1);
                        }
                    }
                    wcwidth(e) {
                        return e < 32 ? 0 : e < 127 ? 1 : e < 65536 ? d[e] : c(e, n) ? 0 : c(e, i) ? 2 : 1;
                    }
                };
            }
        }, t = {};
        function o(n) {
            var r = t[n];
            if (void 0 !== r) return r.exports;
            var i = t[n] = {
                exports: {}
            };
            return e[n](i, i.exports, o), i.exports;
        }
        var n = {};
        return (()=>{
            var e = n;
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.Unicode11Addon = void 0;
            const t = o(433);
            e.Unicode11Addon = class {
                activate(e) {
                    e.unicode.register(new t.UnicodeV11);
                }
                dispose() {}
            };
        })(), n;
    })();
});

},{}],"hbPbQ":[function(require,module,exports) {
!function(e, t) {
    module.exports = t();
}(self, function() {
    return (()=>{
        "use strict";
        var e = {
            6: (e, t)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.LinkComputer = t.WebLinkProvider = void 0, t.WebLinkProvider = class {
                    constructor(e, t, n, i = {}){
                        this._terminal = e, this._regex = t, this._handler = n, this._options = i;
                    }
                    provideLinks(e, t) {
                        const i = n.computeLink(e, this._regex, this._terminal, this._handler);
                        t(this._addCallbacks(i));
                    }
                    _addCallbacks(e) {
                        return e.map((e)=>(e.leave = this._options.leave, e.hover = (t, n)=>{
                                if (this._options.hover) {
                                    const { range: i } = e;
                                    this._options.hover(t, n, i);
                                }
                            }, e));
                    }
                };
                class n {
                    static computeLink(e, t, i, r) {
                        const o = new RegExp(t.source, (t.flags || "") + "g"), [s, a] = n._getWindowedLineStrings(e - 1, i), c = s.join("");
                        let d;
                        const l = [];
                        for(; d = o.exec(c);){
                            const e = d[0];
                            try {
                                const t = new URL(e), n = decodeURI(t.toString());
                                if (e !== n && e + "/" !== n) continue;
                            } catch (e) {
                                continue;
                            }
                            const [t, o] = n._mapStrIdx(i, a, 0, d.index), [s, c] = n._mapStrIdx(i, t, o, e.length);
                            if (-1 === t || -1 === o || -1 === s || -1 === c) continue;
                            const p = {
                                start: {
                                    x: o + 1,
                                    y: t + 1
                                },
                                end: {
                                    x: c,
                                    y: s + 1
                                }
                            };
                            l.push({
                                range: p,
                                text: e,
                                activate: r
                            });
                        }
                        return l;
                    }
                    static _getWindowedLineStrings(e, t) {
                        let n, i = e, r = e, o = 0, s = "";
                        const a = [];
                        if (n = t.buffer.active.getLine(e)) {
                            const e = n.translateToString(!0);
                            if (n.isWrapped && " " !== e[0]) {
                                for(o = 0; (n = t.buffer.active.getLine(--i)) && o < 2048 && (s = n.translateToString(!0), o += s.length, a.push(s), n.isWrapped && -1 === s.indexOf(" ")););
                                a.reverse();
                            }
                            for(a.push(e), o = 0; (n = t.buffer.active.getLine(++r)) && n.isWrapped && o < 2048 && (s = n.translateToString(!0), o += s.length, a.push(s), -1 === s.indexOf(" ")););
                        }
                        return [
                            a,
                            i
                        ];
                    }
                    static _mapStrIdx(e, t, n, i) {
                        const r = e.buffer.active, o = r.getNullCell();
                        let s = n;
                        for(; i;){
                            const e = r.getLine(t);
                            if (!e) return [
                                -1,
                                -1
                            ];
                            for(let n = s; n < e.length; ++n){
                                e.getCell(n, o);
                                const s = o.getChars();
                                if (o.getWidth() && (i -= s.length || 1, n === e.length - 1 && "" === s)) {
                                    const e = r.getLine(t + 1);
                                    e && e.isWrapped && (e.getCell(0, o), 2 === o.getWidth() && (i += 1));
                                }
                                if (i < 0) return [
                                    t,
                                    n
                                ];
                            }
                            t++, s = 0;
                        }
                        return [
                            t,
                            s
                        ];
                    }
                }
                t.LinkComputer = n;
            }
        }, t = {};
        function n(i) {
            var r = t[i];
            if (void 0 !== r) return r.exports;
            var o = t[i] = {
                exports: {}
            };
            return e[i](o, o.exports, n), o.exports;
        }
        var i = {};
        return (()=>{
            var e = i;
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.WebLinksAddon = void 0;
            const t = n(6), r = /https?:[/]{2}[^\s"'!*(){}|\\\^<>`]*[^\s"':,.!?{}|\\\^~\[\]`()<>]/;
            function o(e, t) {
                const n = window.open();
                if (n) {
                    try {
                        n.opener = null;
                    } catch (e) {}
                    n.location.href = t;
                } else console.warn("Opening link blocked as opener could not be cleared");
            }
            e.WebLinksAddon = class {
                constructor(e = o, t = {}){
                    this._handler = e, this._options = t;
                }
                activate(e) {
                    this._terminal = e;
                    const n = this._options, i = n.urlRegex || r;
                    this._linkProvider = this._terminal.registerLinkProvider(new t.WebLinkProvider(this._terminal, i, this._handler, n));
                }
                dispose() {
                    var e;
                    null === (e = this._linkProvider) || void 0 === e || e.dispose();
                }
            };
        })(), i;
    })();
});

},{}],"8OLZt":[function(require,module,exports) {
!function(e, t) {
    module.exports = t();
}(self, ()=>(()=>{
        "use strict";
        var e = {
            965: (e, t, i)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.GlyphRenderer = void 0;
                const s = i(381), r = i(855), o = i(859), n = i(374), a = i(509), h = 11, l = h * Float32Array.BYTES_PER_ELEMENT;
                let c, d = 0, _ = 0, u = 0;
                class g extends o.Disposable {
                    constructor(e, t, i){
                        super(), this._terminal = e, this._gl = t, this._dimensions = i, this._activeBuffer = 0, this._vertices = {
                            count: 0,
                            attributes: new Float32Array(0),
                            attributesBuffers: [
                                new Float32Array(0),
                                new Float32Array(0)
                            ]
                        };
                        const r = this._gl;
                        void 0 === a.TextureAtlas.maxAtlasPages && (a.TextureAtlas.maxAtlasPages = Math.min(32, (0, n.throwIfFalsy)(r.getParameter(r.MAX_TEXTURE_IMAGE_UNITS))), a.TextureAtlas.maxTextureSize = (0, n.throwIfFalsy)(r.getParameter(r.MAX_TEXTURE_SIZE))), this._program = (0, n.throwIfFalsy)((0, s.createProgram)(r, "#version 300 es\nlayout (location = 0) in vec2 a_unitquad;\nlayout (location = 1) in vec2 a_cellpos;\nlayout (location = 2) in vec2 a_offset;\nlayout (location = 3) in vec2 a_size;\nlayout (location = 4) in float a_texpage;\nlayout (location = 5) in vec2 a_texcoord;\nlayout (location = 6) in vec2 a_texsize;\n\nuniform mat4 u_projection;\nuniform vec2 u_resolution;\n\nout vec2 v_texcoord;\nflat out int v_texpage;\n\nvoid main() {\n  vec2 zeroToOne = (a_offset / u_resolution) + a_cellpos + (a_unitquad * a_size);\n  gl_Position = u_projection * vec4(zeroToOne, 0.0, 1.0);\n  v_texpage = int(a_texpage);\n  v_texcoord = a_texcoord + a_unitquad * a_texsize;\n}", function(e) {
                            let t = "";
                            for(let i = 1; i < e; i++)t += ` else if (v_texpage == ${i}) { outColor = texture(u_texture[${i}], v_texcoord); }`;
                            return `#version 300 es\nprecision lowp float;\n\nin vec2 v_texcoord;\nflat in int v_texpage;\n\nuniform sampler2D u_texture[${e}];\n\nout vec4 outColor;\n\nvoid main() {\n  if (v_texpage == 0) {\n    outColor = texture(u_texture[0], v_texcoord);\n  } ${t}\n}`;
                        }(a.TextureAtlas.maxAtlasPages))), this.register((0, o.toDisposable)(()=>r.deleteProgram(this._program))), this._projectionLocation = (0, n.throwIfFalsy)(r.getUniformLocation(this._program, "u_projection")), this._resolutionLocation = (0, n.throwIfFalsy)(r.getUniformLocation(this._program, "u_resolution")), this._textureLocation = (0, n.throwIfFalsy)(r.getUniformLocation(this._program, "u_texture")), this._vertexArrayObject = r.createVertexArray(), r.bindVertexArray(this._vertexArrayObject);
                        const h = new Float32Array([
                            0,
                            0,
                            1,
                            0,
                            0,
                            1,
                            1,
                            1
                        ]), c = r.createBuffer();
                        this.register((0, o.toDisposable)(()=>r.deleteBuffer(c))), r.bindBuffer(r.ARRAY_BUFFER, c), r.bufferData(r.ARRAY_BUFFER, h, r.STATIC_DRAW), r.enableVertexAttribArray(0), r.vertexAttribPointer(0, 2, this._gl.FLOAT, !1, 0, 0);
                        const d = new Uint8Array([
                            0,
                            1,
                            2,
                            3
                        ]), _ = r.createBuffer();
                        this.register((0, o.toDisposable)(()=>r.deleteBuffer(_))), r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, _), r.bufferData(r.ELEMENT_ARRAY_BUFFER, d, r.STATIC_DRAW), this._attributesBuffer = (0, n.throwIfFalsy)(r.createBuffer()), this.register((0, o.toDisposable)(()=>r.deleteBuffer(this._attributesBuffer))), r.bindBuffer(r.ARRAY_BUFFER, this._attributesBuffer), r.enableVertexAttribArray(2), r.vertexAttribPointer(2, 2, r.FLOAT, !1, l, 0), r.vertexAttribDivisor(2, 1), r.enableVertexAttribArray(3), r.vertexAttribPointer(3, 2, r.FLOAT, !1, l, 2 * Float32Array.BYTES_PER_ELEMENT), r.vertexAttribDivisor(3, 1), r.enableVertexAttribArray(4), r.vertexAttribPointer(4, 1, r.FLOAT, !1, l, 4 * Float32Array.BYTES_PER_ELEMENT), r.vertexAttribDivisor(4, 1), r.enableVertexAttribArray(5), r.vertexAttribPointer(5, 2, r.FLOAT, !1, l, 5 * Float32Array.BYTES_PER_ELEMENT), r.vertexAttribDivisor(5, 1), r.enableVertexAttribArray(6), r.vertexAttribPointer(6, 2, r.FLOAT, !1, l, 7 * Float32Array.BYTES_PER_ELEMENT), r.vertexAttribDivisor(6, 1), r.enableVertexAttribArray(1), r.vertexAttribPointer(1, 2, r.FLOAT, !1, l, 9 * Float32Array.BYTES_PER_ELEMENT), r.vertexAttribDivisor(1, 1), r.useProgram(this._program);
                        const u = new Int32Array(a.TextureAtlas.maxAtlasPages);
                        for(let e = 0; e < a.TextureAtlas.maxAtlasPages; e++)u[e] = e;
                        r.uniform1iv(this._textureLocation, u), r.uniformMatrix4fv(this._projectionLocation, !1, s.PROJECTION_MATRIX), this._atlasTextures = [];
                        for(let e = 0; e < a.TextureAtlas.maxAtlasPages; e++){
                            const t = new s.GLTexture((0, n.throwIfFalsy)(r.createTexture()));
                            this.register((0, o.toDisposable)(()=>r.deleteTexture(t.texture))), r.activeTexture(r.TEXTURE0 + e), r.bindTexture(r.TEXTURE_2D, t.texture), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_S, r.CLAMP_TO_EDGE), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_T, r.CLAMP_TO_EDGE), r.texImage2D(r.TEXTURE_2D, 0, r.RGBA, 1, 1, 0, r.RGBA, r.UNSIGNED_BYTE, new Uint8Array([
                                255,
                                0,
                                0,
                                255
                            ])), this._atlasTextures[e] = t;
                        }
                        r.enable(r.BLEND), r.blendFunc(r.SRC_ALPHA, r.ONE_MINUS_SRC_ALPHA), this.handleResize();
                    }
                    beginFrame() {
                        return !this._atlas || this._atlas.beginFrame();
                    }
                    updateCell(e, t, i, s, r, o, n, a) {
                        this._updateCell(this._vertices.attributes, e, t, i, s, r, o, n, a);
                    }
                    _updateCell(e, t, i, s, o, n, a, l, g) {
                        d = (i * this._terminal.cols + t) * h, s !== r.NULL_CELL_CODE && void 0 !== s ? this._atlas && (c = l && l.length > 1 ? this._atlas.getRasterizedGlyphCombinedChar(l, o, n, a) : this._atlas.getRasterizedGlyph(s, o, n, a), _ = Math.floor((this._dimensions.device.cell.width - this._dimensions.device.char.width) / 2), o !== g && c.offset.x > _ ? (u = c.offset.x - _, e[d] = -(c.offset.x - u) + this._dimensions.device.char.left, e[d + 1] = -c.offset.y + this._dimensions.device.char.top, e[d + 2] = (c.size.x - u) / this._dimensions.device.canvas.width, e[d + 3] = c.size.y / this._dimensions.device.canvas.height, e[d + 4] = c.texturePage, e[d + 5] = c.texturePositionClipSpace.x + u / this._atlas.pages[c.texturePage].canvas.width, e[d + 6] = c.texturePositionClipSpace.y, e[d + 7] = c.sizeClipSpace.x - u / this._atlas.pages[c.texturePage].canvas.width, e[d + 8] = c.sizeClipSpace.y) : (e[d] = -c.offset.x + this._dimensions.device.char.left, e[d + 1] = -c.offset.y + this._dimensions.device.char.top, e[d + 2] = c.size.x / this._dimensions.device.canvas.width, e[d + 3] = c.size.y / this._dimensions.device.canvas.height, e[d + 4] = c.texturePage, e[d + 5] = c.texturePositionClipSpace.x, e[d + 6] = c.texturePositionClipSpace.y, e[d + 7] = c.sizeClipSpace.x, e[d + 8] = c.sizeClipSpace.y)) : e.fill(0, d, d + h - 1 - 2);
                    }
                    clear() {
                        const e = this._terminal, t = e.cols * e.rows * h;
                        this._vertices.count !== t ? this._vertices.attributes = new Float32Array(t) : this._vertices.attributes.fill(0);
                        let i = 0;
                        for(; i < this._vertices.attributesBuffers.length; i++)this._vertices.count !== t ? this._vertices.attributesBuffers[i] = new Float32Array(t) : this._vertices.attributesBuffers[i].fill(0);
                        this._vertices.count = t, i = 0;
                        for(let t = 0; t < e.rows; t++)for(let s = 0; s < e.cols; s++)this._vertices.attributes[i + 9] = s / e.cols, this._vertices.attributes[i + 10] = t / e.rows, i += h;
                    }
                    handleResize() {
                        const e = this._gl;
                        e.viewport(0, 0, e.canvas.width, e.canvas.height), e.uniform2f(this._resolutionLocation, e.canvas.width, e.canvas.height), this.clear();
                    }
                    render(e) {
                        if (!this._atlas) return;
                        const t = this._gl;
                        t.useProgram(this._program), t.bindVertexArray(this._vertexArrayObject), this._activeBuffer = (this._activeBuffer + 1) % 2;
                        const i = this._vertices.attributesBuffers[this._activeBuffer];
                        let s = 0;
                        for(let t = 0; t < e.lineLengths.length; t++){
                            const r = t * this._terminal.cols * h, o = this._vertices.attributes.subarray(r, r + e.lineLengths[t] * h);
                            i.set(o, s), s += o.length;
                        }
                        t.bindBuffer(t.ARRAY_BUFFER, this._attributesBuffer), t.bufferData(t.ARRAY_BUFFER, i.subarray(0, s), t.STREAM_DRAW);
                        for(let e = 0; e < this._atlas.pages.length; e++)this._atlas.pages[e].version !== this._atlasTextures[e].version && this._bindAtlasPageTexture(t, this._atlas, e);
                        t.drawElementsInstanced(t.TRIANGLE_STRIP, 4, t.UNSIGNED_BYTE, 0, s / h);
                    }
                    setAtlas(e) {
                        this._atlas = e;
                        for (const e of this._atlasTextures)e.version = -1;
                    }
                    _bindAtlasPageTexture(e, t, i) {
                        e.activeTexture(e.TEXTURE0 + i), e.bindTexture(e.TEXTURE_2D, this._atlasTextures[i].texture), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, t.pages[i].canvas), e.generateMipmap(e.TEXTURE_2D), this._atlasTextures[i].version = t.pages[i].version;
                    }
                    setDimensions(e) {
                        this._dimensions = e;
                    }
                }
                t.GlyphRenderer = g;
            },
            742: (e, t, i)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.RectangleRenderer = void 0;
                const s = i(381), r = i(310), o = i(859), n = i(374), a = 8 * Float32Array.BYTES_PER_ELEMENT;
                let h = 0, l = !1, c = 0, d = 0, _ = 0, u = 0, g = 0, v = 0;
                class f extends o.Disposable {
                    constructor(e, t, i, r){
                        super(), this._terminal = e, this._gl = t, this._dimensions = i, this._themeService = r, this._vertices = {
                            count: 0,
                            attributes: new Float32Array(160)
                        };
                        const h = this._gl;
                        this._program = (0, n.throwIfFalsy)((0, s.createProgram)(h, "#version 300 es\nlayout (location = 0) in vec2 a_position;\nlayout (location = 1) in vec2 a_size;\nlayout (location = 2) in vec4 a_color;\nlayout (location = 3) in vec2 a_unitquad;\n\nuniform mat4 u_projection;\n\nout vec4 v_color;\n\nvoid main() {\n  vec2 zeroToOne = a_position + (a_unitquad * a_size);\n  gl_Position = u_projection * vec4(zeroToOne, 0.0, 1.0);\n  v_color = a_color;\n}", "#version 300 es\nprecision lowp float;\n\nin vec4 v_color;\n\nout vec4 outColor;\n\nvoid main() {\n  outColor = v_color;\n}")), this.register((0, o.toDisposable)(()=>h.deleteProgram(this._program))), this._projectionLocation = (0, n.throwIfFalsy)(h.getUniformLocation(this._program, "u_projection")), this._vertexArrayObject = h.createVertexArray(), h.bindVertexArray(this._vertexArrayObject);
                        const l = new Float32Array([
                            0,
                            0,
                            1,
                            0,
                            0,
                            1,
                            1,
                            1
                        ]), c = h.createBuffer();
                        this.register((0, o.toDisposable)(()=>h.deleteBuffer(c))), h.bindBuffer(h.ARRAY_BUFFER, c), h.bufferData(h.ARRAY_BUFFER, l, h.STATIC_DRAW), h.enableVertexAttribArray(3), h.vertexAttribPointer(3, 2, this._gl.FLOAT, !1, 0, 0);
                        const d = new Uint8Array([
                            0,
                            1,
                            2,
                            3
                        ]), _ = h.createBuffer();
                        this.register((0, o.toDisposable)(()=>h.deleteBuffer(_))), h.bindBuffer(h.ELEMENT_ARRAY_BUFFER, _), h.bufferData(h.ELEMENT_ARRAY_BUFFER, d, h.STATIC_DRAW), this._attributesBuffer = (0, n.throwIfFalsy)(h.createBuffer()), this.register((0, o.toDisposable)(()=>h.deleteBuffer(this._attributesBuffer))), h.bindBuffer(h.ARRAY_BUFFER, this._attributesBuffer), h.enableVertexAttribArray(0), h.vertexAttribPointer(0, 2, h.FLOAT, !1, a, 0), h.vertexAttribDivisor(0, 1), h.enableVertexAttribArray(1), h.vertexAttribPointer(1, 2, h.FLOAT, !1, a, 2 * Float32Array.BYTES_PER_ELEMENT), h.vertexAttribDivisor(1, 1), h.enableVertexAttribArray(2), h.vertexAttribPointer(2, 4, h.FLOAT, !1, a, 4 * Float32Array.BYTES_PER_ELEMENT), h.vertexAttribDivisor(2, 1), this._updateCachedColors(r.colors), this.register(this._themeService.onChangeColors((e)=>{
                            this._updateCachedColors(e), this._updateViewportRectangle();
                        }));
                    }
                    render() {
                        const e = this._gl;
                        e.useProgram(this._program), e.bindVertexArray(this._vertexArrayObject), e.uniformMatrix4fv(this._projectionLocation, !1, s.PROJECTION_MATRIX), e.bindBuffer(e.ARRAY_BUFFER, this._attributesBuffer), e.bufferData(e.ARRAY_BUFFER, this._vertices.attributes, e.DYNAMIC_DRAW), e.drawElementsInstanced(this._gl.TRIANGLE_STRIP, 4, e.UNSIGNED_BYTE, 0, this._vertices.count);
                    }
                    handleResize() {
                        this._updateViewportRectangle();
                    }
                    setDimensions(e) {
                        this._dimensions = e;
                    }
                    _updateCachedColors(e) {
                        this._bgFloat = this._colorToFloat32Array(e.background);
                    }
                    _updateViewportRectangle() {
                        this._addRectangleFloat(this._vertices.attributes, 0, 0, 0, this._terminal.cols * this._dimensions.device.cell.width, this._terminal.rows * this._dimensions.device.cell.height, this._bgFloat);
                    }
                    updateBackgrounds(e) {
                        const t = this._terminal, i = this._vertices;
                        let s, o, n, a, h, l, c, d, _, u, g, v = 1;
                        for(s = 0; s < t.rows; s++){
                            for(n = -1, a = 0, h = 0, l = !1, o = 0; o < t.cols; o++)c = (s * t.cols + o) * r.RENDER_MODEL_INDICIES_PER_CELL, d = e.cells[c + r.RENDER_MODEL_BG_OFFSET], _ = e.cells[c + r.RENDER_MODEL_FG_OFFSET], u = !!(67108864 & _), (d !== a || _ !== h && (l || u)) && ((0 !== a || l && 0 !== h) && (g = 8 * v++, this._updateRectangle(i, g, h, a, n, o, s)), n = o, a = d, h = _, l = u);
                            (0 !== a || l && 0 !== h) && (g = 8 * v++, this._updateRectangle(i, g, h, a, n, t.cols, s));
                        }
                        i.count = v;
                    }
                    _updateRectangle(e, t, i, r, o, n, a) {
                        if (l = !1, 67108864 & i) switch(50331648 & i){
                            case 16777216:
                            case 33554432:
                                h = this._themeService.colors.ansi[255 & i].rgba;
                                break;
                            case 50331648:
                                h = (16777215 & i) << 8;
                                break;
                            default:
                                h = this._themeService.colors.foreground.rgba;
                        }
                        else switch(50331648 & r){
                            case 16777216:
                            case 33554432:
                                h = this._themeService.colors.ansi[255 & r].rgba;
                                break;
                            case 50331648:
                                h = (16777215 & r) << 8;
                                break;
                            default:
                                h = this._themeService.colors.background.rgba, l = !0;
                        }
                        e.attributes.length < t + 4 && (e.attributes = (0, s.expandFloat32Array)(e.attributes, this._terminal.rows * this._terminal.cols * 8)), c = o * this._dimensions.device.cell.width, d = a * this._dimensions.device.cell.height, _ = (h >> 24 & 255) / 255, u = (h >> 16 & 255) / 255, g = (h >> 8 & 255) / 255, v = 1, this._addRectangle(e.attributes, t, c, d, (n - o) * this._dimensions.device.cell.width, this._dimensions.device.cell.height, _, u, g, v);
                    }
                    _addRectangle(e, t, i, s, r, o, n, a, h, l) {
                        e[t] = i / this._dimensions.device.canvas.width, e[t + 1] = s / this._dimensions.device.canvas.height, e[t + 2] = r / this._dimensions.device.canvas.width, e[t + 3] = o / this._dimensions.device.canvas.height, e[t + 4] = n, e[t + 5] = a, e[t + 6] = h, e[t + 7] = l;
                    }
                    _addRectangleFloat(e, t, i, s, r, o, n) {
                        e[t] = i / this._dimensions.device.canvas.width, e[t + 1] = s / this._dimensions.device.canvas.height, e[t + 2] = r / this._dimensions.device.canvas.width, e[t + 3] = o / this._dimensions.device.canvas.height, e[t + 4] = n[0], e[t + 5] = n[1], e[t + 6] = n[2], e[t + 7] = n[3];
                    }
                    _colorToFloat32Array(e) {
                        return new Float32Array([
                            (e.rgba >> 24 & 255) / 255,
                            (e.rgba >> 16 & 255) / 255,
                            (e.rgba >> 8 & 255) / 255,
                            (255 & e.rgba) / 255
                        ]);
                    }
                }
                t.RectangleRenderer = f;
            },
            310: (e, t, i)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.RenderModel = t.COMBINED_CHAR_BIT_MASK = t.RENDER_MODEL_EXT_OFFSET = t.RENDER_MODEL_FG_OFFSET = t.RENDER_MODEL_BG_OFFSET = t.RENDER_MODEL_INDICIES_PER_CELL = void 0;
                const s = i(296);
                t.RENDER_MODEL_INDICIES_PER_CELL = 4, t.RENDER_MODEL_BG_OFFSET = 1, t.RENDER_MODEL_FG_OFFSET = 2, t.RENDER_MODEL_EXT_OFFSET = 3, t.COMBINED_CHAR_BIT_MASK = 2147483648, t.RenderModel = class {
                    constructor(){
                        this.cells = new Uint32Array(0), this.lineLengths = new Uint32Array(0), this.selection = (0, s.createSelectionRenderModel)();
                    }
                    resize(e, i) {
                        const s = e * i * t.RENDER_MODEL_INDICIES_PER_CELL;
                        s !== this.cells.length && (this.cells = new Uint32Array(s), this.lineLengths = new Uint32Array(i));
                    }
                    clear() {
                        this.cells.fill(0, 0), this.lineLengths.fill(0, 0);
                    }
                };
            },
            666: (e, t, i)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.JoinedCellData = t.WebglRenderer = void 0;
                const s = i(820), r = i(274), o = i(627), n = i(56), a = i(374), h = i(147), l = i(782), c = i(855), d = i(345), _ = i(859), u = i(965), g = i(742), v = i(461), f = i(733), C = i(310);
                class p extends _.Disposable {
                    constructor(e, t, i, h, c, u, g, p, m){
                        super(), this._terminal = e, this._characterJoinerService = t, this._charSizeService = i, this._coreBrowserService = h, this._decorationService = u, this._optionsService = g, this._themeService = p, this._model = new C.RenderModel, this._workCell = new l.CellData, this._onChangeTextureAtlas = this.register(new d.EventEmitter), this.onChangeTextureAtlas = this._onChangeTextureAtlas.event, this._onAddTextureAtlasCanvas = this.register(new d.EventEmitter), this.onAddTextureAtlasCanvas = this._onAddTextureAtlasCanvas.event, this._onRemoveTextureAtlasCanvas = this.register(new d.EventEmitter), this.onRemoveTextureAtlasCanvas = this._onRemoveTextureAtlasCanvas.event, this._onRequestRedraw = this.register(new d.EventEmitter), this.onRequestRedraw = this._onRequestRedraw.event, this._onContextLoss = this.register(new d.EventEmitter), this.onContextLoss = this._onContextLoss.event, this.register(this._themeService.onChangeColors(()=>this._handleColorChange())), this._cellColorResolver = new r.CellColorResolver(this._terminal, this._model.selection, this._decorationService, this._coreBrowserService, this._themeService), this._core = this._terminal._core, this._renderLayers = [
                            new f.LinkRenderLayer(this._core.screenElement, 2, this._terminal, this._core.linkifier2, this._coreBrowserService, g, this._themeService),
                            new v.CursorRenderLayer(e, this._core.screenElement, 3, this._onRequestRedraw, this._coreBrowserService, c, g, this._themeService)
                        ], this.dimensions = (0, a.createRenderDimensions)(), this._devicePixelRatio = this._coreBrowserService.dpr, this._updateDimensions(), this.register(g.onOptionChange(()=>this._handleOptionsChanged())), this._canvas = document.createElement("canvas");
                        const x = {
                            antialias: !1,
                            depth: !1,
                            preserveDrawingBuffer: m
                        };
                        if (this._gl = this._canvas.getContext("webgl2", x), !this._gl) throw new Error("WebGL2 not supported " + this._gl);
                        this.register((0, s.addDisposableDomListener)(this._canvas, "webglcontextlost", (e)=>{
                            console.log("webglcontextlost event received"), e.preventDefault(), this._contextRestorationTimeout = setTimeout(()=>{
                                this._contextRestorationTimeout = void 0, console.warn("webgl context not restored; firing onContextLoss"), this._onContextLoss.fire(e);
                            }, 3e3);
                        })), this.register((0, s.addDisposableDomListener)(this._canvas, "webglcontextrestored", (e)=>{
                            console.warn("webglcontextrestored event received"), clearTimeout(this._contextRestorationTimeout), this._contextRestorationTimeout = void 0, (0, o.removeTerminalFromCache)(this._terminal), this._initializeWebGLState(), this._requestRedrawViewport();
                        })), this.register((0, n.observeDevicePixelDimensions)(this._canvas, this._coreBrowserService.window, (e, t)=>this._setCanvasDevicePixelDimensions(e, t))), this._core.screenElement.appendChild(this._canvas), [this._rectangleRenderer, this._glyphRenderer] = this._initializeWebGLState(), this._isAttached = this._coreBrowserService.window.document.body.contains(this._core.screenElement), this.register((0, _.toDisposable)(()=>{
                            var e;
                            for (const e of this._renderLayers)e.dispose();
                            null === (e = this._canvas.parentElement) || void 0 === e || e.removeChild(this._canvas), (0, o.removeTerminalFromCache)(this._terminal);
                        }));
                    }
                    get textureAtlas() {
                        var e;
                        return null === (e = this._charAtlas) || void 0 === e ? void 0 : e.pages[0].canvas;
                    }
                    _handleColorChange() {
                        this._refreshCharAtlas(), this._clearModel(!0);
                    }
                    handleDevicePixelRatioChange() {
                        this._devicePixelRatio !== this._coreBrowserService.dpr && (this._devicePixelRatio = this._coreBrowserService.dpr, this.handleResize(this._terminal.cols, this._terminal.rows));
                    }
                    handleResize(e, t) {
                        var i, s, r, o;
                        this._updateDimensions(), this._model.resize(this._terminal.cols, this._terminal.rows);
                        for (const e of this._renderLayers)e.resize(this._terminal, this.dimensions);
                        this._canvas.width = this.dimensions.device.canvas.width, this._canvas.height = this.dimensions.device.canvas.height, this._canvas.style.width = `${this.dimensions.css.canvas.width}px`, this._canvas.style.height = `${this.dimensions.css.canvas.height}px`, this._core.screenElement.style.width = `${this.dimensions.css.canvas.width}px`, this._core.screenElement.style.height = `${this.dimensions.css.canvas.height}px`, null === (i = this._rectangleRenderer) || void 0 === i || i.setDimensions(this.dimensions), null === (s = this._rectangleRenderer) || void 0 === s || s.handleResize(), null === (r = this._glyphRenderer) || void 0 === r || r.setDimensions(this.dimensions), null === (o = this._glyphRenderer) || void 0 === o || o.handleResize(), this._refreshCharAtlas(), this._clearModel(!1);
                    }
                    handleCharSizeChanged() {
                        this.handleResize(this._terminal.cols, this._terminal.rows);
                    }
                    handleBlur() {
                        for (const e of this._renderLayers)e.handleBlur(this._terminal);
                        this._requestRedrawViewport();
                    }
                    handleFocus() {
                        for (const e of this._renderLayers)e.handleFocus(this._terminal);
                        this._requestRedrawViewport();
                    }
                    handleSelectionChanged(e, t, i) {
                        for (const s of this._renderLayers)s.handleSelectionChanged(this._terminal, e, t, i);
                        this._model.selection.update(this._terminal, e, t, i), this._requestRedrawViewport();
                    }
                    handleCursorMove() {
                        for (const e of this._renderLayers)e.handleCursorMove(this._terminal);
                    }
                    _handleOptionsChanged() {
                        this._updateDimensions(), this._refreshCharAtlas();
                    }
                    _initializeWebGLState() {
                        var e, t;
                        return null === (e = this._rectangleRenderer) || void 0 === e || e.dispose(), null === (t = this._glyphRenderer) || void 0 === t || t.dispose(), this._rectangleRenderer = this.register(new g.RectangleRenderer(this._terminal, this._gl, this.dimensions, this._themeService)), this._glyphRenderer = this.register(new u.GlyphRenderer(this._terminal, this._gl, this.dimensions)), this.handleCharSizeChanged(), [
                            this._rectangleRenderer,
                            this._glyphRenderer
                        ];
                    }
                    _refreshCharAtlas() {
                        var e, t;
                        if (this.dimensions.device.char.width <= 0 && this.dimensions.device.char.height <= 0) return void (this._isAttached = !1);
                        const i = (0, o.acquireTextureAtlas)(this._terminal, this._optionsService.rawOptions, this._themeService.colors, this.dimensions.device.cell.width, this.dimensions.device.cell.height, this.dimensions.device.char.width, this.dimensions.device.char.height, this._coreBrowserService.dpr);
                        this._charAtlas !== i && (null === (e = this._charAtlasDisposable) || void 0 === e || e.dispose(), this._onChangeTextureAtlas.fire(i.pages[0].canvas), this._charAtlasDisposable = (0, _.getDisposeArrayDisposable)([
                            (0, d.forwardEvent)(i.onAddTextureAtlasCanvas, this._onAddTextureAtlasCanvas),
                            (0, d.forwardEvent)(i.onRemoveTextureAtlasCanvas, this._onRemoveTextureAtlasCanvas)
                        ])), this._charAtlas = i, this._charAtlas.warmUp(), null === (t = this._glyphRenderer) || void 0 === t || t.setAtlas(this._charAtlas);
                    }
                    _clearModel(e) {
                        var t;
                        this._model.clear(), e && (null === (t = this._glyphRenderer) || void 0 === t || t.clear());
                    }
                    clearTextureAtlas() {
                        var e;
                        null === (e = this._charAtlas) || void 0 === e || e.clearTexture(), this._clearModel(!0), this._requestRedrawViewport();
                    }
                    clear() {
                        this._clearModel(!0);
                        for (const e of this._renderLayers)e.reset(this._terminal);
                    }
                    registerCharacterJoiner(e) {
                        return -1;
                    }
                    deregisterCharacterJoiner(e) {
                        return !1;
                    }
                    renderRows(e, t) {
                        var i, s;
                        if (!this._isAttached) {
                            if (!(this._coreBrowserService.window.document.body.contains(this._core.screenElement) && this._charSizeService.width && this._charSizeService.height)) return;
                            this._updateDimensions(), this._refreshCharAtlas(), this._isAttached = !0;
                        }
                        for (const i of this._renderLayers)i.handleGridChanged(this._terminal, e, t);
                        this._glyphRenderer && this._rectangleRenderer && (this._glyphRenderer.beginFrame() ? (this._clearModel(!0), this._updateModel(0, this._terminal.rows - 1)) : this._updateModel(e, t), null === (i = this._rectangleRenderer) || void 0 === i || i.render(), null === (s = this._glyphRenderer) || void 0 === s || s.render(this._model));
                    }
                    _updateModel(e, t) {
                        const i = this._core;
                        let s, r, o, n, a, h, l, d, _, u, g, v, f, p = this._workCell;
                        for(e = x(e, i.rows - 1, 0), t = x(t, i.rows - 1, 0), r = e; r <= t; r++)for(o = r + i.buffer.ydisp, n = i.buffer.lines.get(o), this._model.lineLengths[r] = 0, a = this._characterJoinerService.getJoinedCharacters(o), v = 0; v < i.cols; v++)if (s = this._cellColorResolver.result.bg, n.loadCell(v, p), 0 === v && (s = this._cellColorResolver.result.bg), h = !1, l = v, a.length > 0 && v === a[0][0] && (h = !0, d = a.shift(), p = new m(p, n.translateToString(!0, d[0], d[1]), d[1] - d[0]), l = d[1] - 1), _ = p.getChars(), u = p.getCode(), g = (r * i.cols + v) * C.RENDER_MODEL_INDICIES_PER_CELL, this._cellColorResolver.resolve(p, v, o), u !== c.NULL_CELL_CODE && (this._model.lineLengths[r] = v + 1), (this._model.cells[g] !== u || this._model.cells[g + C.RENDER_MODEL_BG_OFFSET] !== this._cellColorResolver.result.bg || this._model.cells[g + C.RENDER_MODEL_FG_OFFSET] !== this._cellColorResolver.result.fg || this._model.cells[g + C.RENDER_MODEL_EXT_OFFSET] !== this._cellColorResolver.result.ext) && (_.length > 1 && (u |= C.COMBINED_CHAR_BIT_MASK), this._model.cells[g] = u, this._model.cells[g + C.RENDER_MODEL_BG_OFFSET] = this._cellColorResolver.result.bg, this._model.cells[g + C.RENDER_MODEL_FG_OFFSET] = this._cellColorResolver.result.fg, this._model.cells[g + C.RENDER_MODEL_EXT_OFFSET] = this._cellColorResolver.result.ext, this._glyphRenderer.updateCell(v, r, u, this._cellColorResolver.result.bg, this._cellColorResolver.result.fg, this._cellColorResolver.result.ext, _, s), h)) for(p = this._workCell, v++; v < l; v++)f = (r * i.cols + v) * C.RENDER_MODEL_INDICIES_PER_CELL, this._glyphRenderer.updateCell(v, r, c.NULL_CELL_CODE, 0, 0, 0, c.NULL_CELL_CHAR, 0), this._model.cells[f] = c.NULL_CELL_CODE, this._model.cells[f + C.RENDER_MODEL_BG_OFFSET] = this._cellColorResolver.result.bg, this._model.cells[f + C.RENDER_MODEL_FG_OFFSET] = this._cellColorResolver.result.fg, this._model.cells[f + C.RENDER_MODEL_EXT_OFFSET] = this._cellColorResolver.result.ext;
                        this._rectangleRenderer.updateBackgrounds(this._model);
                    }
                    _updateDimensions() {
                        this._charSizeService.width && this._charSizeService.height && (this.dimensions.device.char.width = Math.floor(this._charSizeService.width * this._devicePixelRatio), this.dimensions.device.char.height = Math.ceil(this._charSizeService.height * this._devicePixelRatio), this.dimensions.device.cell.height = Math.floor(this.dimensions.device.char.height * this._optionsService.rawOptions.lineHeight), this.dimensions.device.char.top = 1 === this._optionsService.rawOptions.lineHeight ? 0 : Math.round((this.dimensions.device.cell.height - this.dimensions.device.char.height) / 2), this.dimensions.device.cell.width = this.dimensions.device.char.width + Math.round(this._optionsService.rawOptions.letterSpacing), this.dimensions.device.char.left = Math.floor(this._optionsService.rawOptions.letterSpacing / 2), this.dimensions.device.canvas.height = this._terminal.rows * this.dimensions.device.cell.height, this.dimensions.device.canvas.width = this._terminal.cols * this.dimensions.device.cell.width, this.dimensions.css.canvas.height = Math.round(this.dimensions.device.canvas.height / this._devicePixelRatio), this.dimensions.css.canvas.width = Math.round(this.dimensions.device.canvas.width / this._devicePixelRatio), this.dimensions.css.cell.height = this.dimensions.device.cell.height / this._devicePixelRatio, this.dimensions.css.cell.width = this.dimensions.device.cell.width / this._devicePixelRatio);
                    }
                    _setCanvasDevicePixelDimensions(e, t) {
                        this._canvas.width === e && this._canvas.height === t || (this._canvas.width = e, this._canvas.height = t, this._requestRedrawViewport());
                    }
                    _requestRedrawViewport() {
                        this._onRequestRedraw.fire({
                            start: 0,
                            end: this._terminal.rows - 1
                        });
                    }
                }
                t.WebglRenderer = p;
                class m extends h.AttributeData {
                    constructor(e, t, i){
                        super(), this.content = 0, this.combinedData = "", this.fg = e.fg, this.bg = e.bg, this.combinedData = t, this._width = i;
                    }
                    isCombined() {
                        return 2097152;
                    }
                    getWidth() {
                        return this._width;
                    }
                    getChars() {
                        return this.combinedData;
                    }
                    getCode() {
                        return 2097151;
                    }
                    setFromCharData(e) {
                        throw new Error("not implemented");
                    }
                    getAsCharData() {
                        return [
                            this.fg,
                            this.getChars(),
                            this.getWidth(),
                            this.getCode()
                        ];
                    }
                }
                function x(e, t, i = 0) {
                    return Math.max(Math.min(e, t), i);
                }
                t.JoinedCellData = m;
            },
            381: (e, t, i)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.GLTexture = t.expandFloat32Array = t.createShader = t.createProgram = t.PROJECTION_MATRIX = void 0;
                const s = i(374);
                function r(e, t, i) {
                    const r = (0, s.throwIfFalsy)(e.createShader(t));
                    if (e.shaderSource(r, i), e.compileShader(r), e.getShaderParameter(r, e.COMPILE_STATUS)) return r;
                    console.error(e.getShaderInfoLog(r)), e.deleteShader(r);
                }
                t.PROJECTION_MATRIX = new Float32Array([
                    2,
                    0,
                    0,
                    0,
                    0,
                    -2,
                    0,
                    0,
                    0,
                    0,
                    1,
                    0,
                    -1,
                    1,
                    0,
                    1
                ]), t.createProgram = function(e, t, i) {
                    const o = (0, s.throwIfFalsy)(e.createProgram());
                    if (e.attachShader(o, (0, s.throwIfFalsy)(r(e, e.VERTEX_SHADER, t))), e.attachShader(o, (0, s.throwIfFalsy)(r(e, e.FRAGMENT_SHADER, i))), e.linkProgram(o), e.getProgramParameter(o, e.LINK_STATUS)) return o;
                    console.error(e.getProgramInfoLog(o)), e.deleteProgram(o);
                }, t.createShader = r, t.expandFloat32Array = function(e, t) {
                    const i = Math.min(2 * e.length, t), s = new Float32Array(i);
                    for(let t = 0; t < e.length; t++)s[t] = e[t];
                    return s;
                }, t.GLTexture = class {
                    constructor(e){
                        this.texture = e, this.version = -1;
                    }
                };
            },
            592: (e, t, i)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.BaseRenderLayer = void 0;
                const s = i(627), r = i(237), o = i(374), n = i(859);
                class a extends n.Disposable {
                    constructor(e, t, i, s, r, o, a, h){
                        super(), this._container = t, this._alpha = r, this._coreBrowserService = o, this._optionsService = a, this._themeService = h, this._deviceCharWidth = 0, this._deviceCharHeight = 0, this._deviceCellWidth = 0, this._deviceCellHeight = 0, this._deviceCharLeft = 0, this._deviceCharTop = 0, this._canvas = document.createElement("canvas"), this._canvas.classList.add(`xterm-${i}-layer`), this._canvas.style.zIndex = s.toString(), this._initCanvas(), this._container.appendChild(this._canvas), this.register(this._themeService.onChangeColors((t)=>{
                            this._refreshCharAtlas(e, t), this.reset(e);
                        })), this.register((0, n.toDisposable)(()=>{
                            var e;
                            this._canvas.remove(), null === (e = this._charAtlas) || void 0 === e || e.dispose();
                        }));
                    }
                    _initCanvas() {
                        this._ctx = (0, o.throwIfFalsy)(this._canvas.getContext("2d", {
                            alpha: this._alpha
                        })), this._alpha || this._clearAll();
                    }
                    handleBlur(e) {}
                    handleFocus(e) {}
                    handleCursorMove(e) {}
                    handleGridChanged(e, t, i) {}
                    handleSelectionChanged(e, t, i, s = !1) {}
                    _setTransparency(e, t) {
                        if (t === this._alpha) return;
                        const i = this._canvas;
                        this._alpha = t, this._canvas = this._canvas.cloneNode(), this._initCanvas(), this._container.replaceChild(this._canvas, i), this._refreshCharAtlas(e, this._themeService.colors), this.handleGridChanged(e, 0, e.rows - 1);
                    }
                    _refreshCharAtlas(e, t) {
                        this._deviceCharWidth <= 0 && this._deviceCharHeight <= 0 || (this._charAtlas = (0, s.acquireTextureAtlas)(e, this._optionsService.rawOptions, t, this._deviceCellWidth, this._deviceCellHeight, this._deviceCharWidth, this._deviceCharHeight, this._coreBrowserService.dpr), this._charAtlas.warmUp());
                    }
                    resize(e, t) {
                        this._deviceCellWidth = t.device.cell.width, this._deviceCellHeight = t.device.cell.height, this._deviceCharWidth = t.device.char.width, this._deviceCharHeight = t.device.char.height, this._deviceCharLeft = t.device.char.left, this._deviceCharTop = t.device.char.top, this._canvas.width = t.device.canvas.width, this._canvas.height = t.device.canvas.height, this._canvas.style.width = `${t.css.canvas.width}px`, this._canvas.style.height = `${t.css.canvas.height}px`, this._alpha || this._clearAll(), this._refreshCharAtlas(e, this._themeService.colors);
                    }
                    _fillCells(e, t, i, s) {
                        this._ctx.fillRect(e * this._deviceCellWidth, t * this._deviceCellHeight, i * this._deviceCellWidth, s * this._deviceCellHeight);
                    }
                    _fillBottomLineAtCells(e, t, i = 1) {
                        this._ctx.fillRect(e * this._deviceCellWidth, (t + 1) * this._deviceCellHeight - this._coreBrowserService.dpr - 1, i * this._deviceCellWidth, this._coreBrowserService.dpr);
                    }
                    _fillLeftLineAtCell(e, t, i) {
                        this._ctx.fillRect(e * this._deviceCellWidth, t * this._deviceCellHeight, this._coreBrowserService.dpr * i, this._deviceCellHeight);
                    }
                    _strokeRectAtCell(e, t, i, s) {
                        this._ctx.lineWidth = this._coreBrowserService.dpr, this._ctx.strokeRect(e * this._deviceCellWidth + this._coreBrowserService.dpr / 2, t * this._deviceCellHeight + this._coreBrowserService.dpr / 2, i * this._deviceCellWidth - this._coreBrowserService.dpr, s * this._deviceCellHeight - this._coreBrowserService.dpr);
                    }
                    _clearAll() {
                        this._alpha ? this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height) : (this._ctx.fillStyle = this._themeService.colors.background.css, this._ctx.fillRect(0, 0, this._canvas.width, this._canvas.height));
                    }
                    _clearCells(e, t, i, s) {
                        this._alpha ? this._ctx.clearRect(e * this._deviceCellWidth, t * this._deviceCellHeight, i * this._deviceCellWidth, s * this._deviceCellHeight) : (this._ctx.fillStyle = this._themeService.colors.background.css, this._ctx.fillRect(e * this._deviceCellWidth, t * this._deviceCellHeight, i * this._deviceCellWidth, s * this._deviceCellHeight));
                    }
                    _fillCharTrueColor(e, t, i, s) {
                        this._ctx.font = this._getFont(e, !1, !1), this._ctx.textBaseline = r.TEXT_BASELINE, this._clipCell(i, s, t.getWidth()), this._ctx.fillText(t.getChars(), i * this._deviceCellWidth + this._deviceCharLeft, s * this._deviceCellHeight + this._deviceCharTop + this._deviceCharHeight);
                    }
                    _clipCell(e, t, i) {
                        this._ctx.beginPath(), this._ctx.rect(e * this._deviceCellWidth, t * this._deviceCellHeight, i * this._deviceCellWidth, this._deviceCellHeight), this._ctx.clip();
                    }
                    _getFont(e, t, i) {
                        return `${i ? "italic" : ""} ${t ? e.options.fontWeightBold : e.options.fontWeight} ${e.options.fontSize * this._coreBrowserService.dpr}px ${e.options.fontFamily}`;
                    }
                }
                t.BaseRenderLayer = a;
            },
            461: (e, t, i)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.CursorRenderLayer = void 0;
                const s = i(592), r = i(782), o = i(859), n = i(399);
                class a extends s.BaseRenderLayer {
                    constructor(e, t, i, s, n, a, h, l){
                        super(e, t, "cursor", i, !0, n, h, l), this._onRequestRefreshRowsEvent = s, this._coreService = a, this._cell = new r.CellData, this._state = {
                            x: 0,
                            y: 0,
                            isFocused: !1,
                            style: "",
                            width: 0
                        }, this._cursorRenderers = {
                            bar: this._renderBarCursor.bind(this),
                            block: this._renderBlockCursor.bind(this),
                            underline: this._renderUnderlineCursor.bind(this)
                        }, this._handleOptionsChanged(e), this.register(h.onOptionChange(()=>this._handleOptionsChanged(e))), this.register((0, o.toDisposable)(()=>{
                            var e;
                            null === (e = this._cursorBlinkStateManager) || void 0 === e || e.dispose(), this._cursorBlinkStateManager = void 0;
                        }));
                    }
                    resize(e, t) {
                        super.resize(e, t), this._state = {
                            x: 0,
                            y: 0,
                            isFocused: !1,
                            style: "",
                            width: 0
                        };
                    }
                    reset(e) {
                        var t;
                        this._clearCursor(), null === (t = this._cursorBlinkStateManager) || void 0 === t || t.restartBlinkAnimation(e), this._handleOptionsChanged(e);
                    }
                    handleBlur(e) {
                        var t;
                        null === (t = this._cursorBlinkStateManager) || void 0 === t || t.pause(), this._onRequestRefreshRowsEvent.fire({
                            start: e.buffer.active.cursorY,
                            end: e.buffer.active.cursorY
                        });
                    }
                    handleFocus(e) {
                        var t;
                        null === (t = this._cursorBlinkStateManager) || void 0 === t || t.resume(e), this._onRequestRefreshRowsEvent.fire({
                            start: e.buffer.active.cursorY,
                            end: e.buffer.active.cursorY
                        });
                    }
                    _handleOptionsChanged(e) {
                        var t;
                        e.options.cursorBlink ? this._cursorBlinkStateManager || (this._cursorBlinkStateManager = new h(()=>{
                            this._render(e, !0);
                        }, this._coreBrowserService)) : (null === (t = this._cursorBlinkStateManager) || void 0 === t || t.dispose(), this._cursorBlinkStateManager = void 0), this._onRequestRefreshRowsEvent.fire({
                            start: e.buffer.active.cursorY,
                            end: e.buffer.active.cursorY
                        });
                    }
                    handleCursorMove(e) {
                        var t;
                        null === (t = this._cursorBlinkStateManager) || void 0 === t || t.restartBlinkAnimation(e);
                    }
                    handleGridChanged(e, t, i) {
                        !this._cursorBlinkStateManager || this._cursorBlinkStateManager.isPaused ? this._render(e, !1) : this._cursorBlinkStateManager.restartBlinkAnimation(e);
                    }
                    _render(e, t) {
                        if (!this._coreService.isCursorInitialized || this._coreService.isCursorHidden) return void this._clearCursor();
                        const i = e.buffer.active.baseY + e.buffer.active.cursorY, s = i - e.buffer.active.viewportY, r = Math.min(e.buffer.active.cursorX, e.cols - 1);
                        if (s < 0 || s >= e.rows) this._clearCursor();
                        else if (e._core.buffer.lines.get(i).loadCell(r, this._cell), void 0 !== this._cell.content) {
                            if (!this._coreBrowserService.isFocused) {
                                this._clearCursor(), this._ctx.save(), this._ctx.fillStyle = this._themeService.colors.cursor.css;
                                const t = e.options.cursorStyle;
                                return this._renderBlurCursor(e, r, s, this._cell), this._ctx.restore(), this._state.x = r, this._state.y = s, this._state.isFocused = !1, this._state.style = t, void (this._state.width = this._cell.getWidth());
                            }
                            if (!this._cursorBlinkStateManager || this._cursorBlinkStateManager.isCursorVisible) {
                                if (this._state) {
                                    if (this._state.x === r && this._state.y === s && this._state.isFocused === this._coreBrowserService.isFocused && this._state.style === e.options.cursorStyle && this._state.width === this._cell.getWidth()) return;
                                    this._clearCursor();
                                }
                                this._ctx.save(), this._cursorRenderers[e.options.cursorStyle || "block"](e, r, s, this._cell), this._ctx.restore(), this._state.x = r, this._state.y = s, this._state.isFocused = !1, this._state.style = e.options.cursorStyle, this._state.width = this._cell.getWidth();
                            } else this._clearCursor();
                        }
                    }
                    _clearCursor() {
                        this._state && (n.isFirefox || this._coreBrowserService.dpr < 1 ? this._clearAll() : this._clearCells(this._state.x, this._state.y, this._state.width, 1), this._state = {
                            x: 0,
                            y: 0,
                            isFocused: !1,
                            style: "",
                            width: 0
                        });
                    }
                    _renderBarCursor(e, t, i, s) {
                        this._ctx.save(), this._ctx.fillStyle = this._themeService.colors.cursor.css, this._fillLeftLineAtCell(t, i, this._optionsService.rawOptions.cursorWidth), this._ctx.restore();
                    }
                    _renderBlockCursor(e, t, i, s) {
                        this._ctx.save(), this._ctx.fillStyle = this._themeService.colors.cursor.css, this._fillCells(t, i, s.getWidth(), 1), this._ctx.fillStyle = this._themeService.colors.cursorAccent.css, this._fillCharTrueColor(e, s, t, i), this._ctx.restore();
                    }
                    _renderUnderlineCursor(e, t, i, s) {
                        this._ctx.save(), this._ctx.fillStyle = this._themeService.colors.cursor.css, this._fillBottomLineAtCells(t, i), this._ctx.restore();
                    }
                    _renderBlurCursor(e, t, i, s) {
                        this._ctx.save(), this._ctx.strokeStyle = this._themeService.colors.cursor.css, this._strokeRectAtCell(t, i, s.getWidth(), 1), this._ctx.restore();
                    }
                }
                t.CursorRenderLayer = a;
                class h {
                    constructor(e, t){
                        this._renderCallback = e, this._coreBrowserService = t, this.isCursorVisible = !0, this._coreBrowserService.isFocused && this._restartInterval();
                    }
                    get isPaused() {
                        return !(this._blinkStartTimeout || this._blinkInterval);
                    }
                    dispose() {
                        this._blinkInterval && (this._coreBrowserService.window.clearInterval(this._blinkInterval), this._blinkInterval = void 0), this._blinkStartTimeout && (this._coreBrowserService.window.clearTimeout(this._blinkStartTimeout), this._blinkStartTimeout = void 0), this._animationFrame && (this._coreBrowserService.window.cancelAnimationFrame(this._animationFrame), this._animationFrame = void 0);
                    }
                    restartBlinkAnimation(e) {
                        this.isPaused || (this._animationTimeRestarted = Date.now(), this.isCursorVisible = !0, this._animationFrame || (this._animationFrame = this._coreBrowserService.window.requestAnimationFrame(()=>{
                            this._renderCallback(), this._animationFrame = void 0;
                        })));
                    }
                    _restartInterval(e = 600) {
                        this._blinkInterval && (this._coreBrowserService.window.clearInterval(this._blinkInterval), this._blinkInterval = void 0), this._blinkStartTimeout = this._coreBrowserService.window.setTimeout(()=>{
                            if (this._animationTimeRestarted) {
                                const e = 600 - (Date.now() - this._animationTimeRestarted);
                                if (this._animationTimeRestarted = void 0, e > 0) return void this._restartInterval(e);
                            }
                            this.isCursorVisible = !1, this._animationFrame = this._coreBrowserService.window.requestAnimationFrame(()=>{
                                this._renderCallback(), this._animationFrame = void 0;
                            }), this._blinkInterval = this._coreBrowserService.window.setInterval(()=>{
                                if (this._animationTimeRestarted) {
                                    const e = 600 - (Date.now() - this._animationTimeRestarted);
                                    return this._animationTimeRestarted = void 0, void this._restartInterval(e);
                                }
                                this.isCursorVisible = !this.isCursorVisible, this._animationFrame = this._coreBrowserService.window.requestAnimationFrame(()=>{
                                    this._renderCallback(), this._animationFrame = void 0;
                                });
                            }, 600);
                        }, e);
                    }
                    pause() {
                        this.isCursorVisible = !0, this._blinkInterval && (this._coreBrowserService.window.clearInterval(this._blinkInterval), this._blinkInterval = void 0), this._blinkStartTimeout && (this._coreBrowserService.window.clearTimeout(this._blinkStartTimeout), this._blinkStartTimeout = void 0), this._animationFrame && (this._coreBrowserService.window.cancelAnimationFrame(this._animationFrame), this._animationFrame = void 0);
                    }
                    resume(e) {
                        this.pause(), this._animationTimeRestarted = void 0, this._restartInterval(), this.restartBlinkAnimation(e);
                    }
                }
            },
            733: (e, t, i)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.LinkRenderLayer = void 0;
                const s = i(197), r = i(237), o = i(592);
                class n extends o.BaseRenderLayer {
                    constructor(e, t, i, s, r, o, n){
                        super(i, e, "link", t, !0, r, o, n), this.register(s.onShowLinkUnderline((e)=>this._handleShowLinkUnderline(e))), this.register(s.onHideLinkUnderline((e)=>this._handleHideLinkUnderline(e)));
                    }
                    resize(e, t) {
                        super.resize(e, t), this._state = void 0;
                    }
                    reset(e) {
                        this._clearCurrentLink();
                    }
                    _clearCurrentLink() {
                        if (this._state) {
                            this._clearCells(this._state.x1, this._state.y1, this._state.cols - this._state.x1, 1);
                            const e = this._state.y2 - this._state.y1 - 1;
                            e > 0 && this._clearCells(0, this._state.y1 + 1, this._state.cols, e), this._clearCells(0, this._state.y2, this._state.x2, 1), this._state = void 0;
                        }
                    }
                    _handleShowLinkUnderline(e) {
                        if (e.fg === r.INVERTED_DEFAULT_COLOR ? this._ctx.fillStyle = this._themeService.colors.background.css : void 0 !== e.fg && (0, s.is256Color)(e.fg) ? this._ctx.fillStyle = this._themeService.colors.ansi[e.fg].css : this._ctx.fillStyle = this._themeService.colors.foreground.css, e.y1 === e.y2) this._fillBottomLineAtCells(e.x1, e.y1, e.x2 - e.x1);
                        else {
                            this._fillBottomLineAtCells(e.x1, e.y1, e.cols - e.x1);
                            for(let t = e.y1 + 1; t < e.y2; t++)this._fillBottomLineAtCells(0, t, e.cols);
                            this._fillBottomLineAtCells(0, e.y2, e.x2);
                        }
                        this._state = e;
                    }
                    _handleHideLinkUnderline(e) {
                        this._clearCurrentLink();
                    }
                }
                t.LinkRenderLayer = n;
            },
            820: (e, t)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.addDisposableDomListener = void 0, t.addDisposableDomListener = function(e, t, i, s) {
                    e.addEventListener(t, i, s);
                    let r = !1;
                    return {
                        dispose: ()=>{
                            r || (r = !0, e.removeEventListener(t, i, s));
                        }
                    };
                };
            },
            274: (e, t)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.CellColorResolver = void 0;
                let i, s = 0, r = 0, o = !1, n = !1, a = !1;
                t.CellColorResolver = class {
                    constructor(e, t, i, s, r){
                        this._terminal = e, this._selectionRenderModel = t, this._decorationService = i, this._coreBrowserService = s, this._themeService = r, this.result = {
                            fg: 0,
                            bg: 0,
                            ext: 0
                        };
                    }
                    resolve(e, t, h) {
                        this.result.bg = e.bg, this.result.fg = e.fg, this.result.ext = 268435456 & e.bg ? e.extended.ext : 0, r = 0, s = 0, n = !1, o = !1, a = !1, i = this._themeService.colors, this._decorationService.forEachDecorationAtCell(t, h, "bottom", (e)=>{
                            e.backgroundColorRGB && (r = e.backgroundColorRGB.rgba >> 8 & 16777215, n = !0), e.foregroundColorRGB && (s = e.foregroundColorRGB.rgba >> 8 & 16777215, o = !0);
                        }), a = this._selectionRenderModel.isCellSelected(this._terminal, t, h), a && (r = (this._coreBrowserService.isFocused ? i.selectionBackgroundOpaque : i.selectionInactiveBackgroundOpaque).rgba >> 8 & 16777215, n = !0, i.selectionForeground && (s = i.selectionForeground.rgba >> 8 & 16777215, o = !0)), this._decorationService.forEachDecorationAtCell(t, h, "top", (e)=>{
                            e.backgroundColorRGB && (r = e.backgroundColorRGB.rgba >> 8 & 16777215, n = !0), e.foregroundColorRGB && (s = e.foregroundColorRGB.rgba >> 8 & 16777215, o = !0);
                        }), n && (r = a ? -16777216 & e.bg & -134217729 | r | 50331648 : -16777216 & e.bg | r | 50331648), o && (s = -16777216 & e.fg & -67108865 | s | 50331648), 67108864 & this.result.fg && (n && !o && (s = 0 == (50331648 & this.result.bg) ? -134217728 & this.result.fg | 16777215 & i.background.rgba >> 8 | 50331648 : -134217728 & this.result.fg | 67108863 & this.result.bg, o = !0), !n && o && (r = 0 == (50331648 & this.result.fg) ? -67108864 & this.result.bg | 16777215 & i.foreground.rgba >> 8 | 50331648 : -67108864 & this.result.bg | 67108863 & this.result.fg, n = !0)), i = void 0, this.result.bg = n ? r : this.result.bg, this.result.fg = o ? s : this.result.fg;
                    }
                };
            },
            627: (e, t, i)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.removeTerminalFromCache = t.acquireTextureAtlas = void 0;
                const s = i(509), r = i(197), o = [];
                t.acquireTextureAtlas = function(e, t, i, n, a, h, l, c) {
                    const d = (0, r.generateConfig)(n, a, h, l, t, i, c);
                    for(let t = 0; t < o.length; t++){
                        const i = o[t], s = i.ownedBy.indexOf(e);
                        if (s >= 0) {
                            if ((0, r.configEquals)(i.config, d)) return i.atlas;
                            1 === i.ownedBy.length ? (i.atlas.dispose(), o.splice(t, 1)) : i.ownedBy.splice(s, 1);
                            break;
                        }
                    }
                    for(let t = 0; t < o.length; t++){
                        const i = o[t];
                        if ((0, r.configEquals)(i.config, d)) return i.ownedBy.push(e), i.atlas;
                    }
                    const _ = e._core, u = {
                        atlas: new s.TextureAtlas(document, d, _.unicodeService),
                        config: d,
                        ownedBy: [
                            e
                        ]
                    };
                    return o.push(u), u.atlas;
                }, t.removeTerminalFromCache = function(e) {
                    for(let t = 0; t < o.length; t++){
                        const i = o[t].ownedBy.indexOf(e);
                        if (-1 !== i) {
                            1 === o[t].ownedBy.length ? (o[t].atlas.dispose(), o.splice(t, 1)) : o[t].ownedBy.splice(i, 1);
                            break;
                        }
                    }
                };
            },
            197: (e, t, i)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.is256Color = t.configEquals = t.generateConfig = void 0;
                const s = i(160);
                t.generateConfig = function(e, t, i, r, o, n, a) {
                    const h = {
                        foreground: n.foreground,
                        background: n.background,
                        cursor: s.NULL_COLOR,
                        cursorAccent: s.NULL_COLOR,
                        selectionForeground: s.NULL_COLOR,
                        selectionBackgroundTransparent: s.NULL_COLOR,
                        selectionBackgroundOpaque: s.NULL_COLOR,
                        selectionInactiveBackgroundTransparent: s.NULL_COLOR,
                        selectionInactiveBackgroundOpaque: s.NULL_COLOR,
                        ansi: n.ansi.slice(),
                        contrastCache: n.contrastCache
                    };
                    return {
                        customGlyphs: o.customGlyphs,
                        devicePixelRatio: a,
                        letterSpacing: o.letterSpacing,
                        lineHeight: o.lineHeight,
                        deviceCellWidth: e,
                        deviceCellHeight: t,
                        deviceCharWidth: i,
                        deviceCharHeight: r,
                        fontFamily: o.fontFamily,
                        fontSize: o.fontSize,
                        fontWeight: o.fontWeight,
                        fontWeightBold: o.fontWeightBold,
                        allowTransparency: o.allowTransparency,
                        drawBoldTextInBrightColors: o.drawBoldTextInBrightColors,
                        minimumContrastRatio: o.minimumContrastRatio,
                        colors: h
                    };
                }, t.configEquals = function(e, t) {
                    for(let i = 0; i < e.colors.ansi.length; i++)if (e.colors.ansi[i].rgba !== t.colors.ansi[i].rgba) return !1;
                    return e.devicePixelRatio === t.devicePixelRatio && e.customGlyphs === t.customGlyphs && e.lineHeight === t.lineHeight && e.letterSpacing === t.letterSpacing && e.fontFamily === t.fontFamily && e.fontSize === t.fontSize && e.fontWeight === t.fontWeight && e.fontWeightBold === t.fontWeightBold && e.allowTransparency === t.allowTransparency && e.deviceCharWidth === t.deviceCharWidth && e.deviceCharHeight === t.deviceCharHeight && e.drawBoldTextInBrightColors === t.drawBoldTextInBrightColors && e.minimumContrastRatio === t.minimumContrastRatio && e.colors.foreground.rgba === t.colors.foreground.rgba && e.colors.background.rgba === t.colors.background.rgba;
                }, t.is256Color = function(e) {
                    return 16777216 == (50331648 & e) || 33554432 == (50331648 & e);
                };
            },
            237: (e, t, i)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.TEXT_BASELINE = t.DIM_OPACITY = t.INVERTED_DEFAULT_COLOR = void 0;
                const s = i(399);
                t.INVERTED_DEFAULT_COLOR = 257, t.DIM_OPACITY = .5, t.TEXT_BASELINE = s.isFirefox || s.isLegacyEdge ? "bottom" : "ideographic";
            },
            860: (e, t, i)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.tryDrawCustomChar = t.powerlineDefinitions = t.boxDrawingDefinitions = t.blockElementDefinitions = void 0;
                const s = i(374);
                t.blockElementDefinitions = {
                    "▀": [
                        {
                            x: 0,
                            y: 0,
                            w: 8,
                            h: 4
                        }
                    ],
                    "▁": [
                        {
                            x: 0,
                            y: 7,
                            w: 8,
                            h: 1
                        }
                    ],
                    "▂": [
                        {
                            x: 0,
                            y: 6,
                            w: 8,
                            h: 2
                        }
                    ],
                    "▃": [
                        {
                            x: 0,
                            y: 5,
                            w: 8,
                            h: 3
                        }
                    ],
                    "▄": [
                        {
                            x: 0,
                            y: 4,
                            w: 8,
                            h: 4
                        }
                    ],
                    "▅": [
                        {
                            x: 0,
                            y: 3,
                            w: 8,
                            h: 5
                        }
                    ],
                    "▆": [
                        {
                            x: 0,
                            y: 2,
                            w: 8,
                            h: 6
                        }
                    ],
                    "▇": [
                        {
                            x: 0,
                            y: 1,
                            w: 8,
                            h: 7
                        }
                    ],
                    "█": [
                        {
                            x: 0,
                            y: 0,
                            w: 8,
                            h: 8
                        }
                    ],
                    "▉": [
                        {
                            x: 0,
                            y: 0,
                            w: 7,
                            h: 8
                        }
                    ],
                    "▊": [
                        {
                            x: 0,
                            y: 0,
                            w: 6,
                            h: 8
                        }
                    ],
                    "▋": [
                        {
                            x: 0,
                            y: 0,
                            w: 5,
                            h: 8
                        }
                    ],
                    "▌": [
                        {
                            x: 0,
                            y: 0,
                            w: 4,
                            h: 8
                        }
                    ],
                    "▍": [
                        {
                            x: 0,
                            y: 0,
                            w: 3,
                            h: 8
                        }
                    ],
                    "▎": [
                        {
                            x: 0,
                            y: 0,
                            w: 2,
                            h: 8
                        }
                    ],
                    "▏": [
                        {
                            x: 0,
                            y: 0,
                            w: 1,
                            h: 8
                        }
                    ],
                    "▐": [
                        {
                            x: 4,
                            y: 0,
                            w: 4,
                            h: 8
                        }
                    ],
                    "▔": [
                        {
                            x: 0,
                            y: 0,
                            w: 8,
                            h: 1
                        }
                    ],
                    "▕": [
                        {
                            x: 7,
                            y: 0,
                            w: 1,
                            h: 8
                        }
                    ],
                    "▖": [
                        {
                            x: 0,
                            y: 4,
                            w: 4,
                            h: 4
                        }
                    ],
                    "▗": [
                        {
                            x: 4,
                            y: 4,
                            w: 4,
                            h: 4
                        }
                    ],
                    "▘": [
                        {
                            x: 0,
                            y: 0,
                            w: 4,
                            h: 4
                        }
                    ],
                    "▙": [
                        {
                            x: 0,
                            y: 0,
                            w: 4,
                            h: 8
                        },
                        {
                            x: 0,
                            y: 4,
                            w: 8,
                            h: 4
                        }
                    ],
                    "▚": [
                        {
                            x: 0,
                            y: 0,
                            w: 4,
                            h: 4
                        },
                        {
                            x: 4,
                            y: 4,
                            w: 4,
                            h: 4
                        }
                    ],
                    "▛": [
                        {
                            x: 0,
                            y: 0,
                            w: 4,
                            h: 8
                        },
                        {
                            x: 4,
                            y: 0,
                            w: 4,
                            h: 4
                        }
                    ],
                    "▜": [
                        {
                            x: 0,
                            y: 0,
                            w: 8,
                            h: 4
                        },
                        {
                            x: 4,
                            y: 0,
                            w: 4,
                            h: 8
                        }
                    ],
                    "▝": [
                        {
                            x: 4,
                            y: 0,
                            w: 4,
                            h: 4
                        }
                    ],
                    "▞": [
                        {
                            x: 4,
                            y: 0,
                            w: 4,
                            h: 4
                        },
                        {
                            x: 0,
                            y: 4,
                            w: 4,
                            h: 4
                        }
                    ],
                    "▟": [
                        {
                            x: 4,
                            y: 0,
                            w: 4,
                            h: 8
                        },
                        {
                            x: 0,
                            y: 4,
                            w: 8,
                            h: 4
                        }
                    ],
                    "\uD83E\uDF70": [
                        {
                            x: 1,
                            y: 0,
                            w: 1,
                            h: 8
                        }
                    ],
                    "\uD83E\uDF71": [
                        {
                            x: 2,
                            y: 0,
                            w: 1,
                            h: 8
                        }
                    ],
                    "\uD83E\uDF72": [
                        {
                            x: 3,
                            y: 0,
                            w: 1,
                            h: 8
                        }
                    ],
                    "\uD83E\uDF73": [
                        {
                            x: 4,
                            y: 0,
                            w: 1,
                            h: 8
                        }
                    ],
                    "\uD83E\uDF74": [
                        {
                            x: 5,
                            y: 0,
                            w: 1,
                            h: 8
                        }
                    ],
                    "\uD83E\uDF75": [
                        {
                            x: 6,
                            y: 0,
                            w: 1,
                            h: 8
                        }
                    ],
                    "\uD83E\uDF76": [
                        {
                            x: 0,
                            y: 1,
                            w: 8,
                            h: 1
                        }
                    ],
                    "\uD83E\uDF77": [
                        {
                            x: 0,
                            y: 2,
                            w: 8,
                            h: 1
                        }
                    ],
                    "\uD83E\uDF78": [
                        {
                            x: 0,
                            y: 3,
                            w: 8,
                            h: 1
                        }
                    ],
                    "\uD83E\uDF79": [
                        {
                            x: 0,
                            y: 4,
                            w: 8,
                            h: 1
                        }
                    ],
                    "\uD83E\uDF7A": [
                        {
                            x: 0,
                            y: 5,
                            w: 8,
                            h: 1
                        }
                    ],
                    "\uD83E\uDF7B": [
                        {
                            x: 0,
                            y: 6,
                            w: 8,
                            h: 1
                        }
                    ],
                    "\uD83E\uDF7C": [
                        {
                            x: 0,
                            y: 0,
                            w: 1,
                            h: 8
                        },
                        {
                            x: 0,
                            y: 7,
                            w: 8,
                            h: 1
                        }
                    ],
                    "\uD83E\uDF7D": [
                        {
                            x: 0,
                            y: 0,
                            w: 1,
                            h: 8
                        },
                        {
                            x: 0,
                            y: 0,
                            w: 8,
                            h: 1
                        }
                    ],
                    "\uD83E\uDF7E": [
                        {
                            x: 7,
                            y: 0,
                            w: 1,
                            h: 8
                        },
                        {
                            x: 0,
                            y: 0,
                            w: 8,
                            h: 1
                        }
                    ],
                    "\uD83E\uDF7F": [
                        {
                            x: 7,
                            y: 0,
                            w: 1,
                            h: 8
                        },
                        {
                            x: 0,
                            y: 7,
                            w: 8,
                            h: 1
                        }
                    ],
                    "\uD83E\uDF80": [
                        {
                            x: 0,
                            y: 0,
                            w: 8,
                            h: 1
                        },
                        {
                            x: 0,
                            y: 7,
                            w: 8,
                            h: 1
                        }
                    ],
                    "\uD83E\uDF81": [
                        {
                            x: 0,
                            y: 0,
                            w: 8,
                            h: 1
                        },
                        {
                            x: 0,
                            y: 2,
                            w: 8,
                            h: 1
                        },
                        {
                            x: 0,
                            y: 4,
                            w: 8,
                            h: 1
                        },
                        {
                            x: 0,
                            y: 7,
                            w: 8,
                            h: 1
                        }
                    ],
                    "\uD83E\uDF82": [
                        {
                            x: 0,
                            y: 0,
                            w: 8,
                            h: 2
                        }
                    ],
                    "\uD83E\uDF83": [
                        {
                            x: 0,
                            y: 0,
                            w: 8,
                            h: 3
                        }
                    ],
                    "\uD83E\uDF84": [
                        {
                            x: 0,
                            y: 0,
                            w: 8,
                            h: 5
                        }
                    ],
                    "\uD83E\uDF85": [
                        {
                            x: 0,
                            y: 0,
                            w: 8,
                            h: 6
                        }
                    ],
                    "\uD83E\uDF86": [
                        {
                            x: 0,
                            y: 0,
                            w: 8,
                            h: 7
                        }
                    ],
                    "\uD83E\uDF87": [
                        {
                            x: 6,
                            y: 0,
                            w: 2,
                            h: 8
                        }
                    ],
                    "\uD83E\uDF88": [
                        {
                            x: 5,
                            y: 0,
                            w: 3,
                            h: 8
                        }
                    ],
                    "\uD83E\uDF89": [
                        {
                            x: 3,
                            y: 0,
                            w: 5,
                            h: 8
                        }
                    ],
                    "\uD83E\uDF8A": [
                        {
                            x: 2,
                            y: 0,
                            w: 6,
                            h: 8
                        }
                    ],
                    "\uD83E\uDF8B": [
                        {
                            x: 1,
                            y: 0,
                            w: 7,
                            h: 8
                        }
                    ],
                    "\uD83E\uDF95": [
                        {
                            x: 0,
                            y: 0,
                            w: 2,
                            h: 2
                        },
                        {
                            x: 4,
                            y: 0,
                            w: 2,
                            h: 2
                        },
                        {
                            x: 2,
                            y: 2,
                            w: 2,
                            h: 2
                        },
                        {
                            x: 6,
                            y: 2,
                            w: 2,
                            h: 2
                        },
                        {
                            x: 0,
                            y: 4,
                            w: 2,
                            h: 2
                        },
                        {
                            x: 4,
                            y: 4,
                            w: 2,
                            h: 2
                        },
                        {
                            x: 2,
                            y: 6,
                            w: 2,
                            h: 2
                        },
                        {
                            x: 6,
                            y: 6,
                            w: 2,
                            h: 2
                        }
                    ],
                    "\uD83E\uDF96": [
                        {
                            x: 2,
                            y: 0,
                            w: 2,
                            h: 2
                        },
                        {
                            x: 6,
                            y: 0,
                            w: 2,
                            h: 2
                        },
                        {
                            x: 0,
                            y: 2,
                            w: 2,
                            h: 2
                        },
                        {
                            x: 4,
                            y: 2,
                            w: 2,
                            h: 2
                        },
                        {
                            x: 2,
                            y: 4,
                            w: 2,
                            h: 2
                        },
                        {
                            x: 6,
                            y: 4,
                            w: 2,
                            h: 2
                        },
                        {
                            x: 0,
                            y: 6,
                            w: 2,
                            h: 2
                        },
                        {
                            x: 4,
                            y: 6,
                            w: 2,
                            h: 2
                        }
                    ],
                    "\uD83E\uDF97": [
                        {
                            x: 0,
                            y: 2,
                            w: 8,
                            h: 2
                        },
                        {
                            x: 0,
                            y: 6,
                            w: 8,
                            h: 2
                        }
                    ]
                };
                const r = {
                    "░": [
                        [
                            1,
                            0,
                            0,
                            0
                        ],
                        [
                            0,
                            0,
                            0,
                            0
                        ],
                        [
                            0,
                            0,
                            1,
                            0
                        ],
                        [
                            0,
                            0,
                            0,
                            0
                        ]
                    ],
                    "▒": [
                        [
                            1,
                            0
                        ],
                        [
                            0,
                            0
                        ],
                        [
                            0,
                            1
                        ],
                        [
                            0,
                            0
                        ]
                    ],
                    "▓": [
                        [
                            0,
                            1
                        ],
                        [
                            1,
                            1
                        ],
                        [
                            1,
                            0
                        ],
                        [
                            1,
                            1
                        ]
                    ]
                };
                t.boxDrawingDefinitions = {
                    "─": {
                        1: "M0,.5 L1,.5"
                    },
                    "━": {
                        3: "M0,.5 L1,.5"
                    },
                    "│": {
                        1: "M.5,0 L.5,1"
                    },
                    "┃": {
                        3: "M.5,0 L.5,1"
                    },
                    "┌": {
                        1: "M0.5,1 L.5,.5 L1,.5"
                    },
                    "┏": {
                        3: "M0.5,1 L.5,.5 L1,.5"
                    },
                    "┐": {
                        1: "M0,.5 L.5,.5 L.5,1"
                    },
                    "┓": {
                        3: "M0,.5 L.5,.5 L.5,1"
                    },
                    "└": {
                        1: "M.5,0 L.5,.5 L1,.5"
                    },
                    "┗": {
                        3: "M.5,0 L.5,.5 L1,.5"
                    },
                    "┘": {
                        1: "M.5,0 L.5,.5 L0,.5"
                    },
                    "┛": {
                        3: "M.5,0 L.5,.5 L0,.5"
                    },
                    "├": {
                        1: "M.5,0 L.5,1 M.5,.5 L1,.5"
                    },
                    "┣": {
                        3: "M.5,0 L.5,1 M.5,.5 L1,.5"
                    },
                    "┤": {
                        1: "M.5,0 L.5,1 M.5,.5 L0,.5"
                    },
                    "┫": {
                        3: "M.5,0 L.5,1 M.5,.5 L0,.5"
                    },
                    "┬": {
                        1: "M0,.5 L1,.5 M.5,.5 L.5,1"
                    },
                    "┳": {
                        3: "M0,.5 L1,.5 M.5,.5 L.5,1"
                    },
                    "┴": {
                        1: "M0,.5 L1,.5 M.5,.5 L.5,0"
                    },
                    "┻": {
                        3: "M0,.5 L1,.5 M.5,.5 L.5,0"
                    },
                    "┼": {
                        1: "M0,.5 L1,.5 M.5,0 L.5,1"
                    },
                    "╋": {
                        3: "M0,.5 L1,.5 M.5,0 L.5,1"
                    },
                    "╴": {
                        1: "M.5,.5 L0,.5"
                    },
                    "╸": {
                        3: "M.5,.5 L0,.5"
                    },
                    "╵": {
                        1: "M.5,.5 L.5,0"
                    },
                    "╹": {
                        3: "M.5,.5 L.5,0"
                    },
                    "╶": {
                        1: "M.5,.5 L1,.5"
                    },
                    "╺": {
                        3: "M.5,.5 L1,.5"
                    },
                    "╷": {
                        1: "M.5,.5 L.5,1"
                    },
                    "╻": {
                        3: "M.5,.5 L.5,1"
                    },
                    "═": {
                        1: (e, t)=>`M0,${.5 - t} L1,${.5 - t} M0,${.5 + t} L1,${.5 + t}`
                    },
                    "║": {
                        1: (e, t)=>`M${.5 - e},0 L${.5 - e},1 M${.5 + e},0 L${.5 + e},1`
                    },
                    "╒": {
                        1: (e, t)=>`M.5,1 L.5,${.5 - t} L1,${.5 - t} M.5,${.5 + t} L1,${.5 + t}`
                    },
                    "╓": {
                        1: (e, t)=>`M${.5 - e},1 L${.5 - e},.5 L1,.5 M${.5 + e},.5 L${.5 + e},1`
                    },
                    "╔": {
                        1: (e, t)=>`M1,${.5 - t} L${.5 - e},${.5 - t} L${.5 - e},1 M1,${.5 + t} L${.5 + e},${.5 + t} L${.5 + e},1`
                    },
                    "╕": {
                        1: (e, t)=>`M0,${.5 - t} L.5,${.5 - t} L.5,1 M0,${.5 + t} L.5,${.5 + t}`
                    },
                    "╖": {
                        1: (e, t)=>`M${.5 + e},1 L${.5 + e},.5 L0,.5 M${.5 - e},.5 L${.5 - e},1`
                    },
                    "╗": {
                        1: (e, t)=>`M0,${.5 + t} L${.5 - e},${.5 + t} L${.5 - e},1 M0,${.5 - t} L${.5 + e},${.5 - t} L${.5 + e},1`
                    },
                    "╘": {
                        1: (e, t)=>`M.5,0 L.5,${.5 + t} L1,${.5 + t} M.5,${.5 - t} L1,${.5 - t}`
                    },
                    "╙": {
                        1: (e, t)=>`M1,.5 L${.5 - e},.5 L${.5 - e},0 M${.5 + e},.5 L${.5 + e},0`
                    },
                    "╚": {
                        1: (e, t)=>`M1,${.5 - t} L${.5 + e},${.5 - t} L${.5 + e},0 M1,${.5 + t} L${.5 - e},${.5 + t} L${.5 - e},0`
                    },
                    "╛": {
                        1: (e, t)=>`M0,${.5 + t} L.5,${.5 + t} L.5,0 M0,${.5 - t} L.5,${.5 - t}`
                    },
                    "╜": {
                        1: (e, t)=>`M0,.5 L${.5 + e},.5 L${.5 + e},0 M${.5 - e},.5 L${.5 - e},0`
                    },
                    "╝": {
                        1: (e, t)=>`M0,${.5 - t} L${.5 - e},${.5 - t} L${.5 - e},0 M0,${.5 + t} L${.5 + e},${.5 + t} L${.5 + e},0`
                    },
                    "╞": {
                        1: (e, t)=>`M.5,0 L.5,1 M.5,${.5 - t} L1,${.5 - t} M.5,${.5 + t} L1,${.5 + t}`
                    },
                    "╟": {
                        1: (e, t)=>`M${.5 - e},0 L${.5 - e},1 M${.5 + e},0 L${.5 + e},1 M${.5 + e},.5 L1,.5`
                    },
                    "╠": {
                        1: (e, t)=>`M${.5 - e},0 L${.5 - e},1 M1,${.5 + t} L${.5 + e},${.5 + t} L${.5 + e},1 M1,${.5 - t} L${.5 + e},${.5 - t} L${.5 + e},0`
                    },
                    "╡": {
                        1: (e, t)=>`M.5,0 L.5,1 M0,${.5 - t} L.5,${.5 - t} M0,${.5 + t} L.5,${.5 + t}`
                    },
                    "╢": {
                        1: (e, t)=>`M0,.5 L${.5 - e},.5 M${.5 - e},0 L${.5 - e},1 M${.5 + e},0 L${.5 + e},1`
                    },
                    "╣": {
                        1: (e, t)=>`M${.5 + e},0 L${.5 + e},1 M0,${.5 + t} L${.5 - e},${.5 + t} L${.5 - e},1 M0,${.5 - t} L${.5 - e},${.5 - t} L${.5 - e},0`
                    },
                    "╤": {
                        1: (e, t)=>`M0,${.5 - t} L1,${.5 - t} M0,${.5 + t} L1,${.5 + t} M.5,${.5 + t} L.5,1`
                    },
                    "╥": {
                        1: (e, t)=>`M0,.5 L1,.5 M${.5 - e},.5 L${.5 - e},1 M${.5 + e},.5 L${.5 + e},1`
                    },
                    "╦": {
                        1: (e, t)=>`M0,${.5 - t} L1,${.5 - t} M0,${.5 + t} L${.5 - e},${.5 + t} L${.5 - e},1 M1,${.5 + t} L${.5 + e},${.5 + t} L${.5 + e},1`
                    },
                    "╧": {
                        1: (e, t)=>`M.5,0 L.5,${.5 - t} M0,${.5 - t} L1,${.5 - t} M0,${.5 + t} L1,${.5 + t}`
                    },
                    "╨": {
                        1: (e, t)=>`M0,.5 L1,.5 M${.5 - e},.5 L${.5 - e},0 M${.5 + e},.5 L${.5 + e},0`
                    },
                    "╩": {
                        1: (e, t)=>`M0,${.5 + t} L1,${.5 + t} M0,${.5 - t} L${.5 - e},${.5 - t} L${.5 - e},0 M1,${.5 - t} L${.5 + e},${.5 - t} L${.5 + e},0`
                    },
                    "╪": {
                        1: (e, t)=>`M.5,0 L.5,1 M0,${.5 - t} L1,${.5 - t} M0,${.5 + t} L1,${.5 + t}`
                    },
                    "╫": {
                        1: (e, t)=>`M0,.5 L1,.5 M${.5 - e},0 L${.5 - e},1 M${.5 + e},0 L${.5 + e},1`
                    },
                    "╬": {
                        1: (e, t)=>`M0,${.5 + t} L${.5 - e},${.5 + t} L${.5 - e},1 M1,${.5 + t} L${.5 + e},${.5 + t} L${.5 + e},1 M0,${.5 - t} L${.5 - e},${.5 - t} L${.5 - e},0 M1,${.5 - t} L${.5 + e},${.5 - t} L${.5 + e},0`
                    },
                    "╱": {
                        1: "M1,0 L0,1"
                    },
                    "╲": {
                        1: "M0,0 L1,1"
                    },
                    "╳": {
                        1: "M1,0 L0,1 M0,0 L1,1"
                    },
                    "╼": {
                        1: "M.5,.5 L0,.5",
                        3: "M.5,.5 L1,.5"
                    },
                    "╽": {
                        1: "M.5,.5 L.5,0",
                        3: "M.5,.5 L.5,1"
                    },
                    "╾": {
                        1: "M.5,.5 L1,.5",
                        3: "M.5,.5 L0,.5"
                    },
                    "╿": {
                        1: "M.5,.5 L.5,1",
                        3: "M.5,.5 L.5,0"
                    },
                    "┍": {
                        1: "M.5,.5 L.5,1",
                        3: "M.5,.5 L1,.5"
                    },
                    "┎": {
                        1: "M.5,.5 L1,.5",
                        3: "M.5,.5 L.5,1"
                    },
                    "┑": {
                        1: "M.5,.5 L.5,1",
                        3: "M.5,.5 L0,.5"
                    },
                    "┒": {
                        1: "M.5,.5 L0,.5",
                        3: "M.5,.5 L.5,1"
                    },
                    "┕": {
                        1: "M.5,.5 L.5,0",
                        3: "M.5,.5 L1,.5"
                    },
                    "┖": {
                        1: "M.5,.5 L1,.5",
                        3: "M.5,.5 L.5,0"
                    },
                    "┙": {
                        1: "M.5,.5 L.5,0",
                        3: "M.5,.5 L0,.5"
                    },
                    "┚": {
                        1: "M.5,.5 L0,.5",
                        3: "M.5,.5 L.5,0"
                    },
                    "┝": {
                        1: "M.5,0 L.5,1",
                        3: "M.5,.5 L1,.5"
                    },
                    "┞": {
                        1: "M0.5,1 L.5,.5 L1,.5",
                        3: "M.5,.5 L.5,0"
                    },
                    "┟": {
                        1: "M.5,0 L.5,.5 L1,.5",
                        3: "M.5,.5 L.5,1"
                    },
                    "┠": {
                        1: "M.5,.5 L1,.5",
                        3: "M.5,0 L.5,1"
                    },
                    "┡": {
                        1: "M.5,.5 L.5,1",
                        3: "M.5,0 L.5,.5 L1,.5"
                    },
                    "┢": {
                        1: "M.5,.5 L.5,0",
                        3: "M0.5,1 L.5,.5 L1,.5"
                    },
                    "┥": {
                        1: "M.5,0 L.5,1",
                        3: "M.5,.5 L0,.5"
                    },
                    "┦": {
                        1: "M0,.5 L.5,.5 L.5,1",
                        3: "M.5,.5 L.5,0"
                    },
                    "┧": {
                        1: "M.5,0 L.5,.5 L0,.5",
                        3: "M.5,.5 L.5,1"
                    },
                    "┨": {
                        1: "M.5,.5 L0,.5",
                        3: "M.5,0 L.5,1"
                    },
                    "┩": {
                        1: "M.5,.5 L.5,1",
                        3: "M.5,0 L.5,.5 L0,.5"
                    },
                    "┪": {
                        1: "M.5,.5 L.5,0",
                        3: "M0,.5 L.5,.5 L.5,1"
                    },
                    "┭": {
                        1: "M0.5,1 L.5,.5 L1,.5",
                        3: "M.5,.5 L0,.5"
                    },
                    "┮": {
                        1: "M0,.5 L.5,.5 L.5,1",
                        3: "M.5,.5 L1,.5"
                    },
                    "┯": {
                        1: "M.5,.5 L.5,1",
                        3: "M0,.5 L1,.5"
                    },
                    "┰": {
                        1: "M0,.5 L1,.5",
                        3: "M.5,.5 L.5,1"
                    },
                    "┱": {
                        1: "M.5,.5 L1,.5",
                        3: "M0,.5 L.5,.5 L.5,1"
                    },
                    "┲": {
                        1: "M.5,.5 L0,.5",
                        3: "M0.5,1 L.5,.5 L1,.5"
                    },
                    "┵": {
                        1: "M.5,0 L.5,.5 L1,.5",
                        3: "M.5,.5 L0,.5"
                    },
                    "┶": {
                        1: "M.5,0 L.5,.5 L0,.5",
                        3: "M.5,.5 L1,.5"
                    },
                    "┷": {
                        1: "M.5,.5 L.5,0",
                        3: "M0,.5 L1,.5"
                    },
                    "┸": {
                        1: "M0,.5 L1,.5",
                        3: "M.5,.5 L.5,0"
                    },
                    "┹": {
                        1: "M.5,.5 L1,.5",
                        3: "M.5,0 L.5,.5 L0,.5"
                    },
                    "┺": {
                        1: "M.5,.5 L0,.5",
                        3: "M.5,0 L.5,.5 L1,.5"
                    },
                    "┽": {
                        1: "M.5,0 L.5,1 M.5,.5 L1,.5",
                        3: "M.5,.5 L0,.5"
                    },
                    "┾": {
                        1: "M.5,0 L.5,1 M.5,.5 L0,.5",
                        3: "M.5,.5 L1,.5"
                    },
                    "┿": {
                        1: "M.5,0 L.5,1",
                        3: "M0,.5 L1,.5"
                    },
                    "╀": {
                        1: "M0,.5 L1,.5 M.5,.5 L.5,1",
                        3: "M.5,.5 L.5,0"
                    },
                    "╁": {
                        1: "M.5,.5 L.5,0 M0,.5 L1,.5",
                        3: "M.5,.5 L.5,1"
                    },
                    "╂": {
                        1: "M0,.5 L1,.5",
                        3: "M.5,0 L.5,1"
                    },
                    "╃": {
                        1: "M0.5,1 L.5,.5 L1,.5",
                        3: "M.5,0 L.5,.5 L0,.5"
                    },
                    "╄": {
                        1: "M0,.5 L.5,.5 L.5,1",
                        3: "M.5,0 L.5,.5 L1,.5"
                    },
                    "╅": {
                        1: "M.5,0 L.5,.5 L1,.5",
                        3: "M0,.5 L.5,.5 L.5,1"
                    },
                    "╆": {
                        1: "M.5,0 L.5,.5 L0,.5",
                        3: "M0.5,1 L.5,.5 L1,.5"
                    },
                    "╇": {
                        1: "M.5,.5 L.5,1",
                        3: "M.5,.5 L.5,0 M0,.5 L1,.5"
                    },
                    "╈": {
                        1: "M.5,.5 L.5,0",
                        3: "M0,.5 L1,.5 M.5,.5 L.5,1"
                    },
                    "╉": {
                        1: "M.5,.5 L1,.5",
                        3: "M.5,0 L.5,1 M.5,.5 L0,.5"
                    },
                    "╊": {
                        1: "M.5,.5 L0,.5",
                        3: "M.5,0 L.5,1 M.5,.5 L1,.5"
                    },
                    "╌": {
                        1: "M.1,.5 L.4,.5 M.6,.5 L.9,.5"
                    },
                    "╍": {
                        3: "M.1,.5 L.4,.5 M.6,.5 L.9,.5"
                    },
                    "┄": {
                        1: "M.0667,.5 L.2667,.5 M.4,.5 L.6,.5 M.7333,.5 L.9333,.5"
                    },
                    "┅": {
                        3: "M.0667,.5 L.2667,.5 M.4,.5 L.6,.5 M.7333,.5 L.9333,.5"
                    },
                    "┈": {
                        1: "M.05,.5 L.2,.5 M.3,.5 L.45,.5 M.55,.5 L.7,.5 M.8,.5 L.95,.5"
                    },
                    "┉": {
                        3: "M.05,.5 L.2,.5 M.3,.5 L.45,.5 M.55,.5 L.7,.5 M.8,.5 L.95,.5"
                    },
                    "╎": {
                        1: "M.5,.1 L.5,.4 M.5,.6 L.5,.9"
                    },
                    "╏": {
                        3: "M.5,.1 L.5,.4 M.5,.6 L.5,.9"
                    },
                    "┆": {
                        1: "M.5,.0667 L.5,.2667 M.5,.4 L.5,.6 M.5,.7333 L.5,.9333"
                    },
                    "┇": {
                        3: "M.5,.0667 L.5,.2667 M.5,.4 L.5,.6 M.5,.7333 L.5,.9333"
                    },
                    "┊": {
                        1: "M.5,.05 L.5,.2 M.5,.3 L.5,.45 L.5,.55 M.5,.7 L.5,.95"
                    },
                    "┋": {
                        3: "M.5,.05 L.5,.2 M.5,.3 L.5,.45 L.5,.55 M.5,.7 L.5,.95"
                    },
                    "╭": {
                        1: (e, t)=>`M.5,1 L.5,${.5 + t / .15 * .5} C.5,${.5 + t / .15 * .5},.5,.5,1,.5`
                    },
                    "╮": {
                        1: (e, t)=>`M.5,1 L.5,${.5 + t / .15 * .5} C.5,${.5 + t / .15 * .5},.5,.5,0,.5`
                    },
                    "╯": {
                        1: (e, t)=>`M.5,0 L.5,${.5 - t / .15 * .5} C.5,${.5 - t / .15 * .5},.5,.5,0,.5`
                    },
                    "╰": {
                        1: (e, t)=>`M.5,0 L.5,${.5 - t / .15 * .5} C.5,${.5 - t / .15 * .5},.5,.5,1,.5`
                    }
                }, t.powerlineDefinitions = {
                    "": {
                        d: "M0,0 L1,.5 L0,1",
                        type: 0,
                        rightPadding: 2
                    },
                    "": {
                        d: "M-1,-.5 L1,.5 L-1,1.5",
                        type: 1,
                        leftPadding: 1,
                        rightPadding: 1
                    },
                    "": {
                        d: "M1,0 L0,.5 L1,1",
                        type: 0,
                        leftPadding: 2
                    },
                    "": {
                        d: "M2,-.5 L0,.5 L2,1.5",
                        type: 1,
                        leftPadding: 1,
                        rightPadding: 1
                    },
                    "": {
                        d: "M0,0 L0,1 C0.552,1,1,0.776,1,.5 C1,0.224,0.552,0,0,0",
                        type: 0,
                        rightPadding: 1
                    },
                    "": {
                        d: "M0,1 C0.552,1,1,0.776,1,.5 C1,0.224,0.552,0,0,0",
                        type: 1,
                        rightPadding: 1
                    },
                    "": {
                        d: "M1,0 L1,1 C0.448,1,0,0.776,0,.5 C0,0.224,0.448,0,1,0",
                        type: 0,
                        leftPadding: 1
                    },
                    "": {
                        d: "M1,1 C0.448,1,0,0.776,0,.5 C0,0.224,0.448,0,1,0",
                        type: 1,
                        leftPadding: 1
                    },
                    "": {
                        d: "M-.5,-.5 L1.5,1.5 L-.5,1.5",
                        type: 0
                    },
                    "": {
                        d: "M-.5,-.5 L1.5,1.5",
                        type: 1,
                        leftPadding: 1,
                        rightPadding: 1
                    },
                    "": {
                        d: "M1.5,-.5 L-.5,1.5 L1.5,1.5",
                        type: 0
                    },
                    "": {
                        d: "M1.5,-.5 L-.5,1.5 L-.5,-.5",
                        type: 0
                    },
                    "": {
                        d: "M1.5,-.5 L-.5,1.5",
                        type: 1,
                        leftPadding: 1,
                        rightPadding: 1
                    },
                    "": {
                        d: "M-.5,-.5 L1.5,1.5 L1.5,-.5",
                        type: 0
                    }
                }, t.powerlineDefinitions[""] = t.powerlineDefinitions[""], t.powerlineDefinitions[""] = t.powerlineDefinitions[""], t.tryDrawCustomChar = function(e, i, n, l, c, d, _, u) {
                    const g = t.blockElementDefinitions[i];
                    if (g) return function(e, t, i, s, r, o) {
                        for(let n = 0; n < t.length; n++){
                            const a = t[n], h = r / 8, l = o / 8;
                            e.fillRect(i + a.x * h, s + a.y * l, a.w * h, a.h * l);
                        }
                    }(e, g, n, l, c, d), !0;
                    const v = r[i];
                    if (v) return function(e, t, i, r, n, a) {
                        let h = o.get(t);
                        h || (h = new Map, o.set(t, h));
                        const l = e.fillStyle;
                        if ("string" != typeof l) throw new Error(`Unexpected fillStyle type "${l}"`);
                        let c = h.get(l);
                        if (!c) {
                            const i = t[0].length, r = t.length, o = document.createElement("canvas");
                            o.width = i, o.height = r;
                            const n = (0, s.throwIfFalsy)(o.getContext("2d")), a = new ImageData(i, r);
                            let d, _, u, g;
                            if (l.startsWith("#")) d = parseInt(l.slice(1, 3), 16), _ = parseInt(l.slice(3, 5), 16), u = parseInt(l.slice(5, 7), 16), g = l.length > 7 && parseInt(l.slice(7, 9), 16) || 1;
                            else {
                                if (!l.startsWith("rgba")) throw new Error(`Unexpected fillStyle color format "${l}" when drawing pattern glyph`);
                                [d, _, u, g] = l.substring(5, l.length - 1).split(",").map((e)=>parseFloat(e));
                            }
                            for(let e = 0; e < r; e++)for(let s = 0; s < i; s++)a.data[4 * (e * i + s)] = d, a.data[4 * (e * i + s) + 1] = _, a.data[4 * (e * i + s) + 2] = u, a.data[4 * (e * i + s) + 3] = t[e][s] * (255 * g);
                            n.putImageData(a, 0, 0), c = (0, s.throwIfFalsy)(e.createPattern(o, null)), h.set(l, c);
                        }
                        e.fillStyle = c, e.fillRect(i, r, n, a);
                    }(e, v, n, l, c, d), !0;
                    const f = t.boxDrawingDefinitions[i];
                    if (f) return function(e, t, i, s, r, o, n) {
                        e.strokeStyle = e.fillStyle;
                        for (const [l, c] of Object.entries(t)){
                            let t;
                            e.beginPath(), e.lineWidth = n * Number.parseInt(l), t = "function" == typeof c ? c(.15, .15 / o * r) : c;
                            for (const l of t.split(" ")){
                                const t = l[0], c = a[t];
                                if (!c) {
                                    console.error(`Could not find drawing instructions for "${t}"`);
                                    continue;
                                }
                                const d = l.substring(1).split(",");
                                d[0] && d[1] && c(e, h(d, r, o, i, s, !0, n));
                            }
                            e.stroke(), e.closePath();
                        }
                    }(e, f, n, l, c, d, u), !0;
                    const C = t.powerlineDefinitions[i];
                    return !!C && (function(e, t, i, s, r, o, n, l) {
                        var c, d;
                        const _ = new Path2D;
                        _.rect(i, s, r, o), e.clip(_), e.beginPath();
                        const u = n / 12;
                        e.lineWidth = l * u;
                        for (const n of t.d.split(" ")){
                            const _ = n[0], g = a[_];
                            if (!g) {
                                console.error(`Could not find drawing instructions for "${_}"`);
                                continue;
                            }
                            const v = n.substring(1).split(",");
                            v[0] && v[1] && g(e, h(v, r, o, i, s, !1, l, (null !== (c = t.leftPadding) && void 0 !== c ? c : 0) * (u / 2), (null !== (d = t.rightPadding) && void 0 !== d ? d : 0) * (u / 2)));
                        }
                        1 === t.type ? (e.strokeStyle = e.fillStyle, e.stroke()) : e.fill(), e.closePath();
                    }(e, C, n, l, c, d, _, u), !0);
                };
                const o = new Map;
                function n(e, t, i = 0) {
                    return Math.max(Math.min(e, t), i);
                }
                const a = {
                    C: (e, t)=>e.bezierCurveTo(t[0], t[1], t[2], t[3], t[4], t[5]),
                    L: (e, t)=>e.lineTo(t[0], t[1]),
                    M: (e, t)=>e.moveTo(t[0], t[1])
                };
                function h(e, t, i, s, r, o, a, h = 0, l = 0) {
                    const c = e.map((e)=>parseFloat(e) || parseInt(e));
                    if (c.length < 2) throw new Error("Too few arguments for instruction");
                    for(let e = 0; e < c.length; e += 2)c[e] *= t - h * a - l * a, o && 0 !== c[e] && (c[e] = n(Math.round(c[e] + .5) - .5, t, 0)), c[e] += s + h * a;
                    for(let e = 1; e < c.length; e += 2)c[e] *= i, o && 0 !== c[e] && (c[e] = n(Math.round(c[e] + .5) - .5, i, 0)), c[e] += r;
                    return c;
                }
            },
            56: (e, t, i)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.observeDevicePixelDimensions = void 0;
                const s = i(859);
                t.observeDevicePixelDimensions = function(e, t, i) {
                    let r = new t.ResizeObserver((t)=>{
                        const s = t.find((t)=>t.target === e);
                        if (!s) return;
                        if (!("devicePixelContentBoxSize" in s)) return null == r || r.disconnect(), void (r = void 0);
                        const o = s.devicePixelContentBoxSize[0].inlineSize, n = s.devicePixelContentBoxSize[0].blockSize;
                        o > 0 && n > 0 && i(o, n);
                    });
                    try {
                        r.observe(e, {
                            box: [
                                "device-pixel-content-box"
                            ]
                        });
                    } catch (e) {
                        r.disconnect(), r = void 0;
                    }
                    return (0, s.toDisposable)(()=>null == r ? void 0 : r.disconnect());
                };
            },
            374: (e, t)=>{
                function i(e) {
                    return 57508 <= e && e <= 57558;
                }
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.createRenderDimensions = t.excludeFromContrastRatioDemands = t.isRestrictedPowerlineGlyph = t.isPowerlineGlyph = t.throwIfFalsy = void 0, t.throwIfFalsy = function(e) {
                    if (!e) throw new Error("value must not be falsy");
                    return e;
                }, t.isPowerlineGlyph = i, t.isRestrictedPowerlineGlyph = function(e) {
                    return 57520 <= e && e <= 57527;
                }, t.excludeFromContrastRatioDemands = function(e) {
                    return i(e) || function(e) {
                        return 9472 <= e && e <= 9631;
                    }(e);
                }, t.createRenderDimensions = function() {
                    return {
                        css: {
                            canvas: {
                                width: 0,
                                height: 0
                            },
                            cell: {
                                width: 0,
                                height: 0
                            }
                        },
                        device: {
                            canvas: {
                                width: 0,
                                height: 0
                            },
                            cell: {
                                width: 0,
                                height: 0
                            },
                            char: {
                                width: 0,
                                height: 0,
                                left: 0,
                                top: 0
                            }
                        }
                    };
                };
            },
            296: (e, t)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.createSelectionRenderModel = void 0;
                class i {
                    constructor(){
                        this.clear();
                    }
                    clear() {
                        this.hasSelection = !1, this.columnSelectMode = !1, this.viewportStartRow = 0, this.viewportEndRow = 0, this.viewportCappedStartRow = 0, this.viewportCappedEndRow = 0, this.startCol = 0, this.endCol = 0, this.selectionStart = void 0, this.selectionEnd = void 0;
                    }
                    update(e, t, i, s = !1) {
                        if (this.selectionStart = t, this.selectionEnd = i, !t || !i || t[0] === i[0] && t[1] === i[1]) return void this.clear();
                        const r = t[1] - e.buffer.active.viewportY, o = i[1] - e.buffer.active.viewportY, n = Math.max(r, 0), a = Math.min(o, e.rows - 1);
                        n >= e.rows || a < 0 ? this.clear() : (this.hasSelection = !0, this.columnSelectMode = s, this.viewportStartRow = r, this.viewportEndRow = o, this.viewportCappedStartRow = n, this.viewportCappedEndRow = a, this.startCol = t[0], this.endCol = i[0]);
                    }
                    isCellSelected(e, t, i) {
                        return !!this.hasSelection && (i -= e.buffer.active.viewportY, this.columnSelectMode ? this.startCol <= this.endCol ? t >= this.startCol && i >= this.viewportCappedStartRow && t < this.endCol && i <= this.viewportCappedEndRow : t < this.startCol && i >= this.viewportCappedStartRow && t >= this.endCol && i <= this.viewportCappedEndRow : i > this.viewportStartRow && i < this.viewportEndRow || this.viewportStartRow === this.viewportEndRow && i === this.viewportStartRow && t >= this.startCol && t < this.endCol || this.viewportStartRow < this.viewportEndRow && i === this.viewportEndRow && t < this.endCol || this.viewportStartRow < this.viewportEndRow && i === this.viewportStartRow && t >= this.startCol);
                    }
                }
                t.createSelectionRenderModel = function() {
                    return new i;
                };
            },
            509: (e, t, i)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.TextureAtlas = void 0;
                const s = i(237), r = i(855), o = i(147), n = i(160), a = i(860), h = i(374), l = i(485), c = i(385), d = i(345), _ = {
                    texturePage: 0,
                    texturePosition: {
                        x: 0,
                        y: 0
                    },
                    texturePositionClipSpace: {
                        x: 0,
                        y: 0
                    },
                    offset: {
                        x: 0,
                        y: 0
                    },
                    size: {
                        x: 0,
                        y: 0
                    },
                    sizeClipSpace: {
                        x: 0,
                        y: 0
                    }
                };
                let u;
                class g {
                    constructor(e, t, i){
                        this._document = e, this._config = t, this._unicodeService = i, this._didWarmUp = !1, this._cacheMap = new l.FourKeyMap, this._cacheMapCombined = new l.FourKeyMap, this._pages = [], this._activePages = [], this._workBoundingBox = {
                            top: 0,
                            left: 0,
                            bottom: 0,
                            right: 0
                        }, this._workAttributeData = new o.AttributeData, this._textureSize = 512, this._onAddTextureAtlasCanvas = new d.EventEmitter, this.onAddTextureAtlasCanvas = this._onAddTextureAtlasCanvas.event, this._onRemoveTextureAtlasCanvas = new d.EventEmitter, this.onRemoveTextureAtlasCanvas = this._onRemoveTextureAtlasCanvas.event, this._requestClearModel = !1, this._createNewPage(), this._tmpCanvas = C(e, 4 * this._config.deviceCellWidth + 4, this._config.deviceCellHeight + 4), this._tmpCtx = (0, h.throwIfFalsy)(this._tmpCanvas.getContext("2d", {
                            alpha: this._config.allowTransparency,
                            willReadFrequently: !0
                        }));
                    }
                    get pages() {
                        return this._pages;
                    }
                    dispose() {
                        for (const e of this.pages)e.canvas.remove();
                        this._onAddTextureAtlasCanvas.dispose();
                    }
                    warmUp() {
                        this._didWarmUp || (this._doWarmUp(), this._didWarmUp = !0);
                    }
                    _doWarmUp() {
                        const e = new c.IdleTaskQueue;
                        for(let t = 33; t < 126; t++)e.enqueue(()=>{
                            if (!this._cacheMap.get(t, r.DEFAULT_COLOR, r.DEFAULT_COLOR, r.DEFAULT_EXT)) {
                                const e = this._drawToCache(t, r.DEFAULT_COLOR, r.DEFAULT_COLOR, r.DEFAULT_EXT);
                                this._cacheMap.set(t, r.DEFAULT_COLOR, r.DEFAULT_COLOR, r.DEFAULT_EXT, e);
                            }
                        });
                    }
                    beginFrame() {
                        return this._requestClearModel;
                    }
                    clearTexture() {
                        if (0 !== this._pages[0].currentRow.x || 0 !== this._pages[0].currentRow.y) {
                            for (const e of this._pages)e.clear();
                            this._cacheMap.clear(), this._cacheMapCombined.clear(), this._didWarmUp = !1;
                        }
                    }
                    _createNewPage() {
                        g.maxAtlasPages && this._pages.length >= Math.max(4, g.maxAtlasPages / 2) && queueMicrotask(()=>{
                            const e = this._pages.filter((e)=>2 * e.canvas.width <= (g.maxTextureSize || 4096)).sort((e, t)=>t.canvas.width !== e.canvas.width ? t.canvas.width - e.canvas.width : t.percentageUsed - e.percentageUsed);
                            let t = -1, i = 0;
                            for(let s = 0; s < e.length; s++)if (e[s].canvas.width !== i) t = s, i = e[s].canvas.width;
                            else if (s - t == 3) break;
                            const s = e.slice(t, t + 4), r = s.map((e)=>e.glyphs[0].texturePage).sort((e, t)=>e > t ? 1 : -1), o = r[0], n = this._mergePages(s, o);
                            n.version++, this._pages[o] = n;
                            for(let e = r.length - 1; e >= 1; e--)this._deletePage(r[e]);
                            this._requestClearModel = !0, this._onAddTextureAtlasCanvas.fire(n.canvas);
                        });
                        const e = new v(this._document, this._textureSize);
                        return this._pages.push(e), this._activePages.push(e), this._onAddTextureAtlasCanvas.fire(e.canvas), e;
                    }
                    _mergePages(e, t) {
                        const i = 2 * e[0].canvas.width, s = new v(this._document, i, e);
                        for (const [r, o] of e.entries()){
                            const e = r * o.canvas.width % i, n = Math.floor(r / 2) * o.canvas.height;
                            s.ctx.drawImage(o.canvas, e, n);
                            for (const s of o.glyphs)s.texturePage = t, s.sizeClipSpace.x = s.size.x / i, s.sizeClipSpace.y = s.size.y / i, s.texturePosition.x += e, s.texturePosition.y += n, s.texturePositionClipSpace.x = s.texturePosition.x / i, s.texturePositionClipSpace.y = s.texturePosition.y / i;
                            this._onRemoveTextureAtlasCanvas.fire(o.canvas);
                            const a = this._activePages.indexOf(o);
                            -1 !== a && this._activePages.splice(a, 1);
                        }
                        return s;
                    }
                    _deletePage(e) {
                        this._pages.splice(e, 1);
                        for(let t = e; t < this._pages.length; t++){
                            const e = this._pages[t];
                            for (const t of e.glyphs)t.texturePage--;
                            e.version++;
                        }
                    }
                    getRasterizedGlyphCombinedChar(e, t, i, s) {
                        return this._getFromCacheMap(this._cacheMapCombined, e, t, i, s);
                    }
                    getRasterizedGlyph(e, t, i, s) {
                        return this._getFromCacheMap(this._cacheMap, e, t, i, s);
                    }
                    _getFromCacheMap(e, t, i, s, r) {
                        return u = e.get(t, i, s, r), u || (u = this._drawToCache(t, i, s, r), e.set(t, i, s, r, u)), u;
                    }
                    _getColorFromAnsiIndex(e) {
                        if (e >= this._config.colors.ansi.length) throw new Error("No color found for idx " + e);
                        return this._config.colors.ansi[e];
                    }
                    _getBackgroundColor(e, t, i, s) {
                        if (this._config.allowTransparency) return n.NULL_COLOR;
                        let r;
                        switch(e){
                            case 16777216:
                            case 33554432:
                                r = this._getColorFromAnsiIndex(t);
                                break;
                            case 50331648:
                                const e1 = o.AttributeData.toColorRGB(t);
                                r = n.rgba.toColor(e1[0], e1[1], e1[2]);
                                break;
                            default:
                                r = i ? this._config.colors.foreground : this._config.colors.background;
                        }
                        return r;
                    }
                    _getForegroundColor(e, t, i, r, a, h, l, c, d, _) {
                        const u = this._getMinimumContrastColor(e, t, i, r, a, h, !1, d, _);
                        if (u) return u;
                        let g;
                        switch(a){
                            case 16777216:
                            case 33554432:
                                this._config.drawBoldTextInBrightColors && d && h < 8 && (h += 8), g = this._getColorFromAnsiIndex(h);
                                break;
                            case 50331648:
                                const e1 = o.AttributeData.toColorRGB(h);
                                g = n.rgba.toColor(e1[0], e1[1], e1[2]);
                                break;
                            default:
                                g = l ? this._config.colors.background : this._config.colors.foreground;
                        }
                        return this._config.allowTransparency && (g = n.color.opaque(g)), c && (g = n.color.multiplyOpacity(g, s.DIM_OPACITY)), g;
                    }
                    _resolveBackgroundRgba(e, t, i) {
                        switch(e){
                            case 16777216:
                            case 33554432:
                                return this._getColorFromAnsiIndex(t).rgba;
                            case 50331648:
                                return t << 8;
                            default:
                                return i ? this._config.colors.foreground.rgba : this._config.colors.background.rgba;
                        }
                    }
                    _resolveForegroundRgba(e, t, i, s) {
                        switch(e){
                            case 16777216:
                            case 33554432:
                                return this._config.drawBoldTextInBrightColors && s && t < 8 && (t += 8), this._getColorFromAnsiIndex(t).rgba;
                            case 50331648:
                                return t << 8;
                            default:
                                return i ? this._config.colors.background.rgba : this._config.colors.foreground.rgba;
                        }
                    }
                    _getMinimumContrastColor(e, t, i, s, r, o, a, h, l) {
                        if (1 === this._config.minimumContrastRatio || l) return;
                        const c = this._config.colors.contrastCache.getColor(e, s);
                        if (void 0 !== c) return c || void 0;
                        const d = this._resolveBackgroundRgba(t, i, a), _ = this._resolveForegroundRgba(r, o, a, h), u = n.rgba.ensureContrastRatio(d, _, this._config.minimumContrastRatio);
                        if (!u) return void this._config.colors.contrastCache.setColor(e, s, null);
                        const g = n.rgba.toColor(u >> 24 & 255, u >> 16 & 255, u >> 8 & 255);
                        return this._config.colors.contrastCache.setColor(e, s, g), g;
                    }
                    _drawToCache(e, t, i, r) {
                        const n = "number" == typeof e ? String.fromCharCode(e) : e, l = Math.min(this._config.deviceCellWidth * Math.max(n.length, 2) + 4, this._textureSize);
                        this._tmpCanvas.width < l && (this._tmpCanvas.width = l);
                        const c = Math.min(this._config.deviceCellHeight + 8, this._textureSize);
                        if (this._tmpCanvas.height < c && (this._tmpCanvas.height = c), this._tmpCtx.save(), this._workAttributeData.fg = i, this._workAttributeData.bg = t, this._workAttributeData.extended.ext = r, this._workAttributeData.isInvisible()) return _;
                        const d = !!this._workAttributeData.isBold(), u = !!this._workAttributeData.isInverse(), g = !!this._workAttributeData.isDim(), v = !!this._workAttributeData.isItalic(), C = !!this._workAttributeData.isUnderline(), p = !!this._workAttributeData.isStrikethrough(), m = !!this._workAttributeData.isOverline();
                        let x = this._workAttributeData.getFgColor(), L = this._workAttributeData.getFgColorMode(), w = this._workAttributeData.getBgColor(), b = this._workAttributeData.getBgColorMode();
                        if (u) {
                            const e = x;
                            x = w, w = e;
                            const t = L;
                            L = b, b = t;
                        }
                        const M = this._getBackgroundColor(b, w, u, g);
                        this._tmpCtx.globalCompositeOperation = "copy", this._tmpCtx.fillStyle = M.css, this._tmpCtx.fillRect(0, 0, this._tmpCanvas.width, this._tmpCanvas.height), this._tmpCtx.globalCompositeOperation = "source-over";
                        const R = d ? this._config.fontWeightBold : this._config.fontWeight, y = v ? "italic" : "";
                        this._tmpCtx.font = `${y} ${R} ${this._config.fontSize * this._config.devicePixelRatio}px ${this._config.fontFamily}`, this._tmpCtx.textBaseline = s.TEXT_BASELINE;
                        const A = 1 === n.length && (0, h.isPowerlineGlyph)(n.charCodeAt(0)), E = 1 === n.length && (0, h.isRestrictedPowerlineGlyph)(n.charCodeAt(0)), T = this._getForegroundColor(t, b, w, i, L, x, u, g, d, (0, h.excludeFromContrastRatioDemands)(n.charCodeAt(0)));
                        this._tmpCtx.fillStyle = T.css;
                        const S = E ? 0 : 4;
                        let D = !1;
                        !1 !== this._config.customGlyphs && (D = (0, a.tryDrawCustomChar)(this._tmpCtx, n, S, S, this._config.deviceCellWidth, this._config.deviceCellHeight, this._config.fontSize, this._config.devicePixelRatio));
                        let B, P = !A;
                        if (B = "number" == typeof e ? this._unicodeService.wcwidth(e) : this._unicodeService.getStringCellWidth(e), C) {
                            this._tmpCtx.save();
                            const e = Math.max(1, Math.floor(this._config.fontSize * this._config.devicePixelRatio / 15)), t = e % 2 == 1 ? .5 : 0;
                            if (this._tmpCtx.lineWidth = e, this._workAttributeData.isUnderlineColorDefault()) this._tmpCtx.strokeStyle = this._tmpCtx.fillStyle;
                            else if (this._workAttributeData.isUnderlineColorRGB()) P = !1, this._tmpCtx.strokeStyle = `rgb(${o.AttributeData.toColorRGB(this._workAttributeData.getUnderlineColor()).join(",")})`;
                            else {
                                P = !1;
                                let e = this._workAttributeData.getUnderlineColor();
                                this._config.drawBoldTextInBrightColors && this._workAttributeData.isBold() && e < 8 && (e += 8), this._tmpCtx.strokeStyle = this._getColorFromAnsiIndex(e).css;
                            }
                            this._tmpCtx.beginPath();
                            const i = S, s = Math.ceil(S + this._config.deviceCharHeight) - t, r = S + this._config.deviceCharHeight + e - t, a = Math.ceil(S + this._config.deviceCharHeight + 2 * e) - t;
                            for(let o = 0; o < B; o++){
                                this._tmpCtx.save();
                                const n = i + o * this._config.deviceCellWidth, h = i + (o + 1) * this._config.deviceCellWidth, l = n + this._config.deviceCellWidth / 2;
                                switch(this._workAttributeData.extended.underlineStyle){
                                    case 2:
                                        this._tmpCtx.moveTo(n, s), this._tmpCtx.lineTo(h, s), this._tmpCtx.moveTo(n, a), this._tmpCtx.lineTo(h, a);
                                        break;
                                    case 3:
                                        const i1 = e <= 1 ? a : Math.ceil(S + this._config.deviceCharHeight - e / 2) - t, o1 = e <= 1 ? s : Math.ceil(S + this._config.deviceCharHeight + e / 2) - t, c = new Path2D;
                                        c.rect(n, s, this._config.deviceCellWidth, a - s), this._tmpCtx.clip(c), this._tmpCtx.moveTo(n - this._config.deviceCellWidth / 2, r), this._tmpCtx.bezierCurveTo(n - this._config.deviceCellWidth / 2, o1, n, o1, n, r), this._tmpCtx.bezierCurveTo(n, i1, l, i1, l, r), this._tmpCtx.bezierCurveTo(l, o1, h, o1, h, r), this._tmpCtx.bezierCurveTo(h, i1, h + this._config.deviceCellWidth / 2, i1, h + this._config.deviceCellWidth / 2, r);
                                        break;
                                    case 4:
                                        this._tmpCtx.setLineDash([
                                            Math.round(e),
                                            Math.round(e)
                                        ]), this._tmpCtx.moveTo(n, s), this._tmpCtx.lineTo(h, s);
                                        break;
                                    case 5:
                                        this._tmpCtx.setLineDash([
                                            4 * this._config.devicePixelRatio,
                                            3 * this._config.devicePixelRatio
                                        ]), this._tmpCtx.moveTo(n, s), this._tmpCtx.lineTo(h, s);
                                        break;
                                    default:
                                        this._tmpCtx.moveTo(n, s), this._tmpCtx.lineTo(h, s);
                                }
                                this._tmpCtx.stroke(), this._tmpCtx.restore();
                            }
                            if (this._tmpCtx.restore(), !D && this._config.fontSize >= 12 && !this._config.allowTransparency && " " !== n) {
                                this._tmpCtx.save(), this._tmpCtx.textBaseline = "alphabetic";
                                const t = this._tmpCtx.measureText(n);
                                if (this._tmpCtx.restore(), "actualBoundingBoxDescent" in t && t.actualBoundingBoxDescent > 0) {
                                    this._tmpCtx.save();
                                    const t = new Path2D;
                                    t.rect(i, s - Math.ceil(e / 2), this._config.deviceCellWidth * B, a - s + Math.ceil(e / 2)), this._tmpCtx.clip(t), this._tmpCtx.lineWidth = 3 * this._config.devicePixelRatio, this._tmpCtx.strokeStyle = M.css, this._tmpCtx.strokeText(n, S, S + this._config.deviceCharHeight), this._tmpCtx.restore();
                                }
                            }
                        }
                        if (m) {
                            const e = Math.max(1, Math.floor(this._config.fontSize * this._config.devicePixelRatio / 15)), t = e % 2 == 1 ? .5 : 0;
                            this._tmpCtx.lineWidth = e, this._tmpCtx.strokeStyle = this._tmpCtx.fillStyle, this._tmpCtx.beginPath(), this._tmpCtx.moveTo(S, S + t), this._tmpCtx.lineTo(S + this._config.deviceCharWidth * B, S + t), this._tmpCtx.stroke();
                        }
                        if (D || this._tmpCtx.fillText(n, S, S + this._config.deviceCharHeight), "_" === n && !this._config.allowTransparency) {
                            let e = f(this._tmpCtx.getImageData(S, S, this._config.deviceCellWidth, this._config.deviceCellHeight), M, T, P);
                            if (e) for(let t = 1; t <= 5 && (this._tmpCtx.save(), this._tmpCtx.fillStyle = M.css, this._tmpCtx.fillRect(0, 0, this._tmpCanvas.width, this._tmpCanvas.height), this._tmpCtx.restore(), this._tmpCtx.fillText(n, S, S + this._config.deviceCharHeight - t), e = f(this._tmpCtx.getImageData(S, S, this._config.deviceCellWidth, this._config.deviceCellHeight), M, T, P), e); t++);
                        }
                        if (p) {
                            const e = Math.max(1, Math.floor(this._config.fontSize * this._config.devicePixelRatio / 10)), t = this._tmpCtx.lineWidth % 2 == 1 ? .5 : 0;
                            this._tmpCtx.lineWidth = e, this._tmpCtx.strokeStyle = this._tmpCtx.fillStyle, this._tmpCtx.beginPath(), this._tmpCtx.moveTo(S, S + Math.floor(this._config.deviceCharHeight / 2) - t), this._tmpCtx.lineTo(S + this._config.deviceCharWidth * B, S + Math.floor(this._config.deviceCharHeight / 2) - t), this._tmpCtx.stroke();
                        }
                        this._tmpCtx.restore();
                        const F = this._tmpCtx.getImageData(0, 0, this._tmpCanvas.width, this._tmpCanvas.height);
                        let I;
                        if (I = this._config.allowTransparency ? function(e) {
                            for(let t = 0; t < e.data.length; t += 4)if (e.data[t + 3] > 0) return !1;
                            return !0;
                        }(F) : f(F, M, T, P), I) return _;
                        const $ = this._findGlyphBoundingBox(F, this._workBoundingBox, l, E, D, S);
                        let k, O;
                        for(;;){
                            if (0 === this._activePages.length) {
                                const e = this._createNewPage();
                                k = e, O = e.currentRow, O.height = $.size.y;
                                break;
                            }
                            k = this._activePages[this._activePages.length - 1], O = k.currentRow;
                            for (const e of this._activePages)$.size.y <= e.currentRow.height && (k = e, O = e.currentRow);
                            for(let e = this._activePages.length - 1; e >= 0; e--)for (const t of this._activePages[e].fixedRows)t.height <= O.height && $.size.y <= t.height && (k = this._activePages[e], O = t);
                            if (O.y + $.size.y >= k.canvas.height || O.height > $.size.y + 2) {
                                let e = !1;
                                if (k.currentRow.y + k.currentRow.height + $.size.y >= k.canvas.height) {
                                    let t;
                                    for (const e of this._activePages)if (e.currentRow.y + e.currentRow.height + $.size.y < e.canvas.height) {
                                        t = e;
                                        break;
                                    }
                                    if (t) k = t;
                                    else {
                                        const t = this._createNewPage();
                                        k = t, O = t.currentRow, O.height = $.size.y, e = !0;
                                    }
                                }
                                e || (k.currentRow.height > 0 && k.fixedRows.push(k.currentRow), O = {
                                    x: 0,
                                    y: k.currentRow.y + k.currentRow.height,
                                    height: $.size.y
                                }, k.fixedRows.push(O), k.currentRow = {
                                    x: 0,
                                    y: O.y + O.height,
                                    height: 0
                                });
                            }
                            if (O.x + $.size.x <= k.canvas.width) break;
                            O === k.currentRow ? (O.x = 0, O.y += O.height, O.height = 0) : k.fixedRows.splice(k.fixedRows.indexOf(O), 1);
                        }
                        return $.texturePage = this._pages.indexOf(k), $.texturePosition.x = O.x, $.texturePosition.y = O.y, $.texturePositionClipSpace.x = O.x / k.canvas.width, $.texturePositionClipSpace.y = O.y / k.canvas.height, $.sizeClipSpace.x /= k.canvas.width, $.sizeClipSpace.y /= k.canvas.height, O.height = Math.max(O.height, $.size.y), O.x += $.size.x, k.ctx.putImageData(F, $.texturePosition.x - this._workBoundingBox.left, $.texturePosition.y - this._workBoundingBox.top, this._workBoundingBox.left, this._workBoundingBox.top, $.size.x, $.size.y), k.addGlyph($), k.version++, $;
                    }
                    _findGlyphBoundingBox(e, t, i, s, r, o) {
                        t.top = 0;
                        const n = s ? this._config.deviceCellHeight : this._tmpCanvas.height, a = s ? this._config.deviceCellWidth : i;
                        let h = !1;
                        for(let i = 0; i < n; i++){
                            for(let s = 0; s < a; s++){
                                const r = i * this._tmpCanvas.width * 4 + 4 * s + 3;
                                if (0 !== e.data[r]) {
                                    t.top = i, h = !0;
                                    break;
                                }
                            }
                            if (h) break;
                        }
                        t.left = 0, h = !1;
                        for(let i = 0; i < o + a; i++){
                            for(let s = 0; s < n; s++){
                                const r = s * this._tmpCanvas.width * 4 + 4 * i + 3;
                                if (0 !== e.data[r]) {
                                    t.left = i, h = !0;
                                    break;
                                }
                            }
                            if (h) break;
                        }
                        t.right = a, h = !1;
                        for(let i = o + a - 1; i >= o; i--){
                            for(let s = 0; s < n; s++){
                                const r = s * this._tmpCanvas.width * 4 + 4 * i + 3;
                                if (0 !== e.data[r]) {
                                    t.right = i, h = !0;
                                    break;
                                }
                            }
                            if (h) break;
                        }
                        t.bottom = n, h = !1;
                        for(let i = n - 1; i >= 0; i--){
                            for(let s = 0; s < a; s++){
                                const r = i * this._tmpCanvas.width * 4 + 4 * s + 3;
                                if (0 !== e.data[r]) {
                                    t.bottom = i, h = !0;
                                    break;
                                }
                            }
                            if (h) break;
                        }
                        return {
                            texturePage: 0,
                            texturePosition: {
                                x: 0,
                                y: 0
                            },
                            texturePositionClipSpace: {
                                x: 0,
                                y: 0
                            },
                            size: {
                                x: t.right - t.left + 1,
                                y: t.bottom - t.top + 1
                            },
                            sizeClipSpace: {
                                x: t.right - t.left + 1,
                                y: t.bottom - t.top + 1
                            },
                            offset: {
                                x: -t.left + o + (s || r ? Math.floor((this._config.deviceCellWidth - this._config.deviceCharWidth) / 2) : 0),
                                y: -t.top + o + (s || r ? 1 === this._config.lineHeight ? 0 : Math.round((this._config.deviceCellHeight - this._config.deviceCharHeight) / 2) : 0)
                            }
                        };
                    }
                }
                t.TextureAtlas = g;
                class v {
                    constructor(e, t, i){
                        if (this._usedPixels = 0, this._glyphs = [], this.version = 0, this.currentRow = {
                            x: 0,
                            y: 0,
                            height: 0
                        }, this.fixedRows = [], i) for (const e of i)this._glyphs.push(...e.glyphs), this._usedPixels += e._usedPixels;
                        this.canvas = C(e, t, t), this.ctx = (0, h.throwIfFalsy)(this.canvas.getContext("2d", {
                            alpha: !0
                        }));
                    }
                    get percentageUsed() {
                        return this._usedPixels / (this.canvas.width * this.canvas.height);
                    }
                    get glyphs() {
                        return this._glyphs;
                    }
                    addGlyph(e) {
                        this._glyphs.push(e), this._usedPixels += e.size.x * e.size.y;
                    }
                    clear() {
                        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height), this.currentRow.x = 0, this.currentRow.y = 0, this.currentRow.height = 0, this.fixedRows.length = 0, this.version++;
                    }
                }
                function f(e, t, i, s) {
                    const r = t.rgba >>> 24, o = t.rgba >>> 16 & 255, n = t.rgba >>> 8 & 255, a = i.rgba >>> 24, h = i.rgba >>> 16 & 255, l = i.rgba >>> 8 & 255, c = Math.floor((Math.abs(r - a) + Math.abs(o - h) + Math.abs(n - l)) / 12);
                    let d = !0;
                    for(let t = 0; t < e.data.length; t += 4)e.data[t] === r && e.data[t + 1] === o && e.data[t + 2] === n || s && Math.abs(e.data[t] - r) + Math.abs(e.data[t + 1] - o) + Math.abs(e.data[t + 2] - n) < c ? e.data[t + 3] = 0 : d = !1;
                    return d;
                }
                function C(e, t, i) {
                    const s = e.createElement("canvas");
                    return s.width = t, s.height = i, s;
                }
            },
            160: (e, t, i)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.contrastRatio = t.toPaddedHex = t.rgba = t.rgb = t.css = t.color = t.channels = t.NULL_COLOR = void 0;
                const s = i(399);
                let r = 0, o = 0, n = 0, a = 0;
                var h, l, c;
                function d(e) {
                    const t = e.toString(16);
                    return t.length < 2 ? "0" + t : t;
                }
                function _(e, t) {
                    return e < t ? (t + .05) / (e + .05) : (e + .05) / (t + .05);
                }
                t.NULL_COLOR = {
                    css: "#00000000",
                    rgba: 0
                }, function(e) {
                    e.toCss = function(e, t, i, s) {
                        return void 0 !== s ? `#${d(e)}${d(t)}${d(i)}${d(s)}` : `#${d(e)}${d(t)}${d(i)}`;
                    }, e.toRgba = function(e, t, i, s = 255) {
                        return (e << 24 | t << 16 | i << 8 | s) >>> 0;
                    };
                }(h = t.channels || (t.channels = {})), function(e) {
                    function t(e, t) {
                        return a = Math.round(255 * t), [r, o, n] = c.toChannels(e.rgba), {
                            css: h.toCss(r, o, n, a),
                            rgba: h.toRgba(r, o, n, a)
                        };
                    }
                    e.blend = function(e, t) {
                        if (a = (255 & t.rgba) / 255, 1 === a) return {
                            css: t.css,
                            rgba: t.rgba
                        };
                        const i = t.rgba >> 24 & 255, s = t.rgba >> 16 & 255, l = t.rgba >> 8 & 255, c = e.rgba >> 24 & 255, d = e.rgba >> 16 & 255, _ = e.rgba >> 8 & 255;
                        return r = c + Math.round((i - c) * a), o = d + Math.round((s - d) * a), n = _ + Math.round((l - _) * a), {
                            css: h.toCss(r, o, n),
                            rgba: h.toRgba(r, o, n)
                        };
                    }, e.isOpaque = function(e) {
                        return 255 == (255 & e.rgba);
                    }, e.ensureContrastRatio = function(e, t, i) {
                        const s = c.ensureContrastRatio(e.rgba, t.rgba, i);
                        if (s) return c.toColor(s >> 24 & 255, s >> 16 & 255, s >> 8 & 255);
                    }, e.opaque = function(e) {
                        const t = (255 | e.rgba) >>> 0;
                        return [r, o, n] = c.toChannels(t), {
                            css: h.toCss(r, o, n),
                            rgba: t
                        };
                    }, e.opacity = t, e.multiplyOpacity = function(e, i) {
                        return a = 255 & e.rgba, t(e, a * i / 255);
                    }, e.toColorRGB = function(e) {
                        return [
                            e.rgba >> 24 & 255,
                            e.rgba >> 16 & 255,
                            e.rgba >> 8 & 255
                        ];
                    };
                }(t.color || (t.color = {})), function(e) {
                    let t, i;
                    if (!s.isNode) {
                        const e = document.createElement("canvas");
                        e.width = 1, e.height = 1;
                        const s = e.getContext("2d", {
                            willReadFrequently: !0
                        });
                        s && (t = s, t.globalCompositeOperation = "copy", i = t.createLinearGradient(0, 0, 1, 1));
                    }
                    e.toColor = function(e) {
                        if (e.match(/#[\da-f]{3,8}/i)) switch(e.length){
                            case 4:
                                return r = parseInt(e.slice(1, 2).repeat(2), 16), o = parseInt(e.slice(2, 3).repeat(2), 16), n = parseInt(e.slice(3, 4).repeat(2), 16), c.toColor(r, o, n);
                            case 5:
                                return r = parseInt(e.slice(1, 2).repeat(2), 16), o = parseInt(e.slice(2, 3).repeat(2), 16), n = parseInt(e.slice(3, 4).repeat(2), 16), a = parseInt(e.slice(4, 5).repeat(2), 16), c.toColor(r, o, n, a);
                            case 7:
                                return {
                                    css: e,
                                    rgba: (parseInt(e.slice(1), 16) << 8 | 255) >>> 0
                                };
                            case 9:
                                return {
                                    css: e,
                                    rgba: parseInt(e.slice(1), 16) >>> 0
                                };
                        }
                        const s = e.match(/rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(,\s*(0|1|\d?\.(\d+))\s*)?\)/);
                        if (s) return r = parseInt(s[1]), o = parseInt(s[2]), n = parseInt(s[3]), a = Math.round(255 * (void 0 === s[5] ? 1 : parseFloat(s[5]))), c.toColor(r, o, n, a);
                        if (!t || !i) throw new Error("css.toColor: Unsupported css format");
                        if (t.fillStyle = i, t.fillStyle = e, "string" != typeof t.fillStyle) throw new Error("css.toColor: Unsupported css format");
                        if (t.fillRect(0, 0, 1, 1), [r, o, n, a] = t.getImageData(0, 0, 1, 1).data, 255 !== a) throw new Error("css.toColor: Unsupported css format");
                        return {
                            rgba: h.toRgba(r, o, n, a),
                            css: e
                        };
                    };
                }(t.css || (t.css = {})), function(e) {
                    function t(e, t, i) {
                        const s = e / 255, r = t / 255, o = i / 255;
                        return .2126 * (s <= .03928 ? s / 12.92 : Math.pow((s + .055) / 1.055, 2.4)) + .7152 * (r <= .03928 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4)) + .0722 * (o <= .03928 ? o / 12.92 : Math.pow((o + .055) / 1.055, 2.4));
                    }
                    e.relativeLuminance = function(e) {
                        return t(e >> 16 & 255, e >> 8 & 255, 255 & e);
                    }, e.relativeLuminance2 = t;
                }(l = t.rgb || (t.rgb = {})), function(e) {
                    function t(e, t, i) {
                        const s = e >> 24 & 255, r = e >> 16 & 255, o = e >> 8 & 255;
                        let n = t >> 24 & 255, a = t >> 16 & 255, h = t >> 8 & 255, c = _(l.relativeLuminance2(n, a, h), l.relativeLuminance2(s, r, o));
                        for(; c < i && (n > 0 || a > 0 || h > 0);)n -= Math.max(0, Math.ceil(.1 * n)), a -= Math.max(0, Math.ceil(.1 * a)), h -= Math.max(0, Math.ceil(.1 * h)), c = _(l.relativeLuminance2(n, a, h), l.relativeLuminance2(s, r, o));
                        return (n << 24 | a << 16 | h << 8 | 255) >>> 0;
                    }
                    function i(e, t, i) {
                        const s = e >> 24 & 255, r = e >> 16 & 255, o = e >> 8 & 255;
                        let n = t >> 24 & 255, a = t >> 16 & 255, h = t >> 8 & 255, c = _(l.relativeLuminance2(n, a, h), l.relativeLuminance2(s, r, o));
                        for(; c < i && (n < 255 || a < 255 || h < 255);)n = Math.min(255, n + Math.ceil(.1 * (255 - n))), a = Math.min(255, a + Math.ceil(.1 * (255 - a))), h = Math.min(255, h + Math.ceil(.1 * (255 - h))), c = _(l.relativeLuminance2(n, a, h), l.relativeLuminance2(s, r, o));
                        return (n << 24 | a << 16 | h << 8 | 255) >>> 0;
                    }
                    e.ensureContrastRatio = function(e, s, r) {
                        const o = l.relativeLuminance(e >> 8), n = l.relativeLuminance(s >> 8);
                        if (_(o, n) < r) {
                            if (n < o) {
                                const n = t(e, s, r), a = _(o, l.relativeLuminance(n >> 8));
                                if (a < r) {
                                    const t = i(e, s, r);
                                    return a > _(o, l.relativeLuminance(t >> 8)) ? n : t;
                                }
                                return n;
                            }
                            const a = i(e, s, r), h = _(o, l.relativeLuminance(a >> 8));
                            if (h < r) {
                                const i = t(e, s, r);
                                return h > _(o, l.relativeLuminance(i >> 8)) ? a : i;
                            }
                            return a;
                        }
                    }, e.reduceLuminance = t, e.increaseLuminance = i, e.toChannels = function(e) {
                        return [
                            e >> 24 & 255,
                            e >> 16 & 255,
                            e >> 8 & 255,
                            255 & e
                        ];
                    }, e.toColor = function(e, t, i, s) {
                        return {
                            css: h.toCss(e, t, i, s),
                            rgba: h.toRgba(e, t, i, s)
                        };
                    };
                }(c = t.rgba || (t.rgba = {})), t.toPaddedHex = d, t.contrastRatio = _;
            },
            345: (e, t)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.forwardEvent = t.EventEmitter = void 0, t.EventEmitter = class {
                    constructor(){
                        this._listeners = [], this._disposed = !1;
                    }
                    get event() {
                        return this._event || (this._event = (e)=>(this._listeners.push(e), {
                                dispose: ()=>{
                                    if (!this._disposed) {
                                        for(let t = 0; t < this._listeners.length; t++)if (this._listeners[t] === e) return void this._listeners.splice(t, 1);
                                    }
                                }
                            })), this._event;
                    }
                    fire(e, t) {
                        const i = [];
                        for(let e = 0; e < this._listeners.length; e++)i.push(this._listeners[e]);
                        for(let s = 0; s < i.length; s++)i[s].call(void 0, e, t);
                    }
                    dispose() {
                        this._listeners && (this._listeners.length = 0), this._disposed = !0;
                    }
                }, t.forwardEvent = function(e, t) {
                    return e((e)=>t.fire(e));
                };
            },
            859: (e, t)=>{
                function i(e) {
                    for (const t of e)t.dispose();
                    e.length = 0;
                }
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.getDisposeArrayDisposable = t.disposeArray = t.toDisposable = t.Disposable = void 0, t.Disposable = class {
                    constructor(){
                        this._disposables = [], this._isDisposed = !1;
                    }
                    dispose() {
                        this._isDisposed = !0;
                        for (const e of this._disposables)e.dispose();
                        this._disposables.length = 0;
                    }
                    register(e) {
                        return this._disposables.push(e), e;
                    }
                    unregister(e) {
                        const t = this._disposables.indexOf(e);
                        -1 !== t && this._disposables.splice(t, 1);
                    }
                }, t.toDisposable = function(e) {
                    return {
                        dispose: e
                    };
                }, t.disposeArray = i, t.getDisposeArrayDisposable = function(e) {
                    return {
                        dispose: ()=>i(e)
                    };
                };
            },
            485: (e, t)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.FourKeyMap = t.TwoKeyMap = void 0;
                class i {
                    constructor(){
                        this._data = {};
                    }
                    set(e, t, i) {
                        this._data[e] || (this._data[e] = {}), this._data[e][t] = i;
                    }
                    get(e, t) {
                        return this._data[e] ? this._data[e][t] : void 0;
                    }
                    clear() {
                        this._data = {};
                    }
                }
                t.TwoKeyMap = i, t.FourKeyMap = class {
                    constructor(){
                        this._data = new i;
                    }
                    set(e, t, s, r, o) {
                        this._data.get(e, t) || this._data.set(e, t, new i), this._data.get(e, t).set(s, r, o);
                    }
                    get(e, t, i, s) {
                        var r;
                        return null === (r = this._data.get(e, t)) || void 0 === r ? void 0 : r.get(i, s);
                    }
                    clear() {
                        this._data.clear();
                    }
                };
            },
            399: (e, t)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.isChromeOS = t.isLinux = t.isWindows = t.isIphone = t.isIpad = t.isMac = t.getSafariVersion = t.isSafari = t.isLegacyEdge = t.isFirefox = t.isNode = void 0, t.isNode = "undefined" == typeof navigator;
                const i = t.isNode ? "node" : navigator.userAgent, s = t.isNode ? "node" : navigator.platform;
                t.isFirefox = i.includes("Firefox"), t.isLegacyEdge = i.includes("Edge"), t.isSafari = /^((?!chrome|android).)*safari/i.test(i), t.getSafariVersion = function() {
                    if (!t.isSafari) return 0;
                    const e = i.match(/Version\/(\d+)/);
                    return null === e || e.length < 2 ? 0 : parseInt(e[1]);
                }, t.isMac = [
                    "Macintosh",
                    "MacIntel",
                    "MacPPC",
                    "Mac68K"
                ].includes(s), t.isIpad = "iPad" === s, t.isIphone = "iPhone" === s, t.isWindows = [
                    "Windows",
                    "Win16",
                    "Win32",
                    "WinCE"
                ].includes(s), t.isLinux = s.indexOf("Linux") >= 0, t.isChromeOS = /\bCrOS\b/.test(i);
            },
            385: (e, t, i)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.DebouncedIdleTask = t.IdleTaskQueue = t.PriorityTaskQueue = void 0;
                const s = i(399);
                class r {
                    constructor(){
                        this._tasks = [], this._i = 0;
                    }
                    enqueue(e) {
                        this._tasks.push(e), this._start();
                    }
                    flush() {
                        for(; this._i < this._tasks.length;)this._tasks[this._i]() || this._i++;
                        this.clear();
                    }
                    clear() {
                        this._idleCallback && (this._cancelCallback(this._idleCallback), this._idleCallback = void 0), this._i = 0, this._tasks.length = 0;
                    }
                    _start() {
                        this._idleCallback || (this._idleCallback = this._requestCallback(this._process.bind(this)));
                    }
                    _process(e) {
                        this._idleCallback = void 0;
                        let t = 0, i = 0, s = e.timeRemaining(), r = 0;
                        for(; this._i < this._tasks.length;){
                            if (t = Date.now(), this._tasks[this._i]() || this._i++, t = Math.max(1, Date.now() - t), i = Math.max(t, i), r = e.timeRemaining(), 1.5 * i > r) return s - t < -20 && console.warn(`task queue exceeded allotted deadline by ${Math.abs(Math.round(s - t))}ms`), void this._start();
                            s = r;
                        }
                        this.clear();
                    }
                }
                class o extends r {
                    _requestCallback(e) {
                        return setTimeout(()=>e(this._createDeadline(16)));
                    }
                    _cancelCallback(e) {
                        clearTimeout(e);
                    }
                    _createDeadline(e) {
                        const t = Date.now() + e;
                        return {
                            timeRemaining: ()=>Math.max(0, t - Date.now())
                        };
                    }
                }
                t.PriorityTaskQueue = o, t.IdleTaskQueue = !s.isNode && "requestIdleCallback" in window ? class extends r {
                    _requestCallback(e) {
                        return requestIdleCallback(e);
                    }
                    _cancelCallback(e) {
                        cancelIdleCallback(e);
                    }
                } : o, t.DebouncedIdleTask = class {
                    constructor(){
                        this._queue = new t.IdleTaskQueue;
                    }
                    set(e) {
                        this._queue.clear(), this._queue.enqueue(e);
                    }
                    flush() {
                        this._queue.flush();
                    }
                };
            },
            147: (e, t)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.ExtendedAttrs = t.AttributeData = void 0;
                class i {
                    constructor(){
                        this.fg = 0, this.bg = 0, this.extended = new s;
                    }
                    static toColorRGB(e) {
                        return [
                            e >>> 16 & 255,
                            e >>> 8 & 255,
                            255 & e
                        ];
                    }
                    static fromColorRGB(e) {
                        return (255 & e[0]) << 16 | (255 & e[1]) << 8 | 255 & e[2];
                    }
                    clone() {
                        const e = new i;
                        return e.fg = this.fg, e.bg = this.bg, e.extended = this.extended.clone(), e;
                    }
                    isInverse() {
                        return 67108864 & this.fg;
                    }
                    isBold() {
                        return 134217728 & this.fg;
                    }
                    isUnderline() {
                        return this.hasExtendedAttrs() && 0 !== this.extended.underlineStyle ? 1 : 268435456 & this.fg;
                    }
                    isBlink() {
                        return 536870912 & this.fg;
                    }
                    isInvisible() {
                        return 1073741824 & this.fg;
                    }
                    isItalic() {
                        return 67108864 & this.bg;
                    }
                    isDim() {
                        return 134217728 & this.bg;
                    }
                    isStrikethrough() {
                        return 2147483648 & this.fg;
                    }
                    isProtected() {
                        return 536870912 & this.bg;
                    }
                    isOverline() {
                        return 1073741824 & this.bg;
                    }
                    getFgColorMode() {
                        return 50331648 & this.fg;
                    }
                    getBgColorMode() {
                        return 50331648 & this.bg;
                    }
                    isFgRGB() {
                        return 50331648 == (50331648 & this.fg);
                    }
                    isBgRGB() {
                        return 50331648 == (50331648 & this.bg);
                    }
                    isFgPalette() {
                        return 16777216 == (50331648 & this.fg) || 33554432 == (50331648 & this.fg);
                    }
                    isBgPalette() {
                        return 16777216 == (50331648 & this.bg) || 33554432 == (50331648 & this.bg);
                    }
                    isFgDefault() {
                        return 0 == (50331648 & this.fg);
                    }
                    isBgDefault() {
                        return 0 == (50331648 & this.bg);
                    }
                    isAttributeDefault() {
                        return 0 === this.fg && 0 === this.bg;
                    }
                    getFgColor() {
                        switch(50331648 & this.fg){
                            case 16777216:
                            case 33554432:
                                return 255 & this.fg;
                            case 50331648:
                                return 16777215 & this.fg;
                            default:
                                return -1;
                        }
                    }
                    getBgColor() {
                        switch(50331648 & this.bg){
                            case 16777216:
                            case 33554432:
                                return 255 & this.bg;
                            case 50331648:
                                return 16777215 & this.bg;
                            default:
                                return -1;
                        }
                    }
                    hasExtendedAttrs() {
                        return 268435456 & this.bg;
                    }
                    updateExtended() {
                        this.extended.isEmpty() ? this.bg &= -268435457 : this.bg |= 268435456;
                    }
                    getUnderlineColor() {
                        if (268435456 & this.bg && ~this.extended.underlineColor) switch(50331648 & this.extended.underlineColor){
                            case 16777216:
                            case 33554432:
                                return 255 & this.extended.underlineColor;
                            case 50331648:
                                return 16777215 & this.extended.underlineColor;
                            default:
                                return this.getFgColor();
                        }
                        return this.getFgColor();
                    }
                    getUnderlineColorMode() {
                        return 268435456 & this.bg && ~this.extended.underlineColor ? 50331648 & this.extended.underlineColor : this.getFgColorMode();
                    }
                    isUnderlineColorRGB() {
                        return 268435456 & this.bg && ~this.extended.underlineColor ? 50331648 == (50331648 & this.extended.underlineColor) : this.isFgRGB();
                    }
                    isUnderlineColorPalette() {
                        return 268435456 & this.bg && ~this.extended.underlineColor ? 16777216 == (50331648 & this.extended.underlineColor) || 33554432 == (50331648 & this.extended.underlineColor) : this.isFgPalette();
                    }
                    isUnderlineColorDefault() {
                        return 268435456 & this.bg && ~this.extended.underlineColor ? 0 == (50331648 & this.extended.underlineColor) : this.isFgDefault();
                    }
                    getUnderlineStyle() {
                        return 268435456 & this.fg ? 268435456 & this.bg ? this.extended.underlineStyle : 1 : 0;
                    }
                }
                t.AttributeData = i;
                class s {
                    constructor(e = 0, t = 0){
                        this._ext = 0, this._urlId = 0, this._ext = e, this._urlId = t;
                    }
                    get ext() {
                        return this._urlId ? -469762049 & this._ext | this.underlineStyle << 26 : this._ext;
                    }
                    set ext(e) {
                        this._ext = e;
                    }
                    get underlineStyle() {
                        return this._urlId ? 5 : (469762048 & this._ext) >> 26;
                    }
                    set underlineStyle(e) {
                        this._ext &= -469762049, this._ext |= e << 26 & 469762048;
                    }
                    get underlineColor() {
                        return 67108863 & this._ext;
                    }
                    set underlineColor(e) {
                        this._ext &= -67108864, this._ext |= 67108863 & e;
                    }
                    get urlId() {
                        return this._urlId;
                    }
                    set urlId(e) {
                        this._urlId = e;
                    }
                    clone() {
                        return new s(this._ext, this._urlId);
                    }
                    isEmpty() {
                        return 0 === this.underlineStyle && 0 === this._urlId;
                    }
                }
                t.ExtendedAttrs = s;
            },
            782: (e, t, i)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.CellData = void 0;
                const s = i(133), r = i(855), o = i(147);
                class n extends o.AttributeData {
                    constructor(){
                        super(...arguments), this.content = 0, this.fg = 0, this.bg = 0, this.extended = new o.ExtendedAttrs, this.combinedData = "";
                    }
                    static fromCharData(e) {
                        const t = new n;
                        return t.setFromCharData(e), t;
                    }
                    isCombined() {
                        return 2097152 & this.content;
                    }
                    getWidth() {
                        return this.content >> 22;
                    }
                    getChars() {
                        return 2097152 & this.content ? this.combinedData : 2097151 & this.content ? (0, s.stringFromCodePoint)(2097151 & this.content) : "";
                    }
                    getCode() {
                        return this.isCombined() ? this.combinedData.charCodeAt(this.combinedData.length - 1) : 2097151 & this.content;
                    }
                    setFromCharData(e) {
                        this.fg = e[r.CHAR_DATA_ATTR_INDEX], this.bg = 0;
                        let t = !1;
                        if (e[r.CHAR_DATA_CHAR_INDEX].length > 2) t = !0;
                        else if (2 === e[r.CHAR_DATA_CHAR_INDEX].length) {
                            const i = e[r.CHAR_DATA_CHAR_INDEX].charCodeAt(0);
                            if (55296 <= i && i <= 56319) {
                                const s = e[r.CHAR_DATA_CHAR_INDEX].charCodeAt(1);
                                56320 <= s && s <= 57343 ? this.content = 1024 * (i - 55296) + s - 56320 + 65536 | e[r.CHAR_DATA_WIDTH_INDEX] << 22 : t = !0;
                            } else t = !0;
                        } else this.content = e[r.CHAR_DATA_CHAR_INDEX].charCodeAt(0) | e[r.CHAR_DATA_WIDTH_INDEX] << 22;
                        t && (this.combinedData = e[r.CHAR_DATA_CHAR_INDEX], this.content = 2097152 | e[r.CHAR_DATA_WIDTH_INDEX] << 22);
                    }
                    getAsCharData() {
                        return [
                            this.fg,
                            this.getChars(),
                            this.getWidth(),
                            this.getCode()
                        ];
                    }
                }
                t.CellData = n;
            },
            855: (e, t)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.WHITESPACE_CELL_CODE = t.WHITESPACE_CELL_WIDTH = t.WHITESPACE_CELL_CHAR = t.NULL_CELL_CODE = t.NULL_CELL_WIDTH = t.NULL_CELL_CHAR = t.CHAR_DATA_CODE_INDEX = t.CHAR_DATA_WIDTH_INDEX = t.CHAR_DATA_CHAR_INDEX = t.CHAR_DATA_ATTR_INDEX = t.DEFAULT_EXT = t.DEFAULT_ATTR = t.DEFAULT_COLOR = void 0, t.DEFAULT_COLOR = 0, t.DEFAULT_ATTR = 256 | t.DEFAULT_COLOR << 9, t.DEFAULT_EXT = 0, t.CHAR_DATA_ATTR_INDEX = 0, t.CHAR_DATA_CHAR_INDEX = 1, t.CHAR_DATA_WIDTH_INDEX = 2, t.CHAR_DATA_CODE_INDEX = 3, t.NULL_CELL_CHAR = "", t.NULL_CELL_WIDTH = 1, t.NULL_CELL_CODE = 0, t.WHITESPACE_CELL_CHAR = " ", t.WHITESPACE_CELL_WIDTH = 1, t.WHITESPACE_CELL_CODE = 32;
            },
            133: (e, t)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.Utf8ToUtf32 = t.StringToUtf32 = t.utf32ToString = t.stringFromCodePoint = void 0, t.stringFromCodePoint = function(e) {
                    return e > 65535 ? (e -= 65536, String.fromCharCode(55296 + (e >> 10)) + String.fromCharCode(e % 1024 + 56320)) : String.fromCharCode(e);
                }, t.utf32ToString = function(e, t = 0, i = e.length) {
                    let s = "";
                    for(let r = t; r < i; ++r){
                        let t = e[r];
                        t > 65535 ? (t -= 65536, s += String.fromCharCode(55296 + (t >> 10)) + String.fromCharCode(t % 1024 + 56320)) : s += String.fromCharCode(t);
                    }
                    return s;
                }, t.StringToUtf32 = class {
                    constructor(){
                        this._interim = 0;
                    }
                    clear() {
                        this._interim = 0;
                    }
                    decode(e, t) {
                        const i = e.length;
                        if (!i) return 0;
                        let s = 0, r = 0;
                        if (this._interim) {
                            const i = e.charCodeAt(r++);
                            56320 <= i && i <= 57343 ? t[s++] = 1024 * (this._interim - 55296) + i - 56320 + 65536 : (t[s++] = this._interim, t[s++] = i), this._interim = 0;
                        }
                        for(let o = r; o < i; ++o){
                            const r = e.charCodeAt(o);
                            if (55296 <= r && r <= 56319) {
                                if (++o >= i) return this._interim = r, s;
                                const n = e.charCodeAt(o);
                                56320 <= n && n <= 57343 ? t[s++] = 1024 * (r - 55296) + n - 56320 + 65536 : (t[s++] = r, t[s++] = n);
                            } else 65279 !== r && (t[s++] = r);
                        }
                        return s;
                    }
                }, t.Utf8ToUtf32 = class {
                    constructor(){
                        this.interim = new Uint8Array(3);
                    }
                    clear() {
                        this.interim.fill(0);
                    }
                    decode(e, t) {
                        const i = e.length;
                        if (!i) return 0;
                        let s, r, o, n, a = 0, h = 0, l = 0;
                        if (this.interim[0]) {
                            let s = !1, r = this.interim[0];
                            r &= 192 == (224 & r) ? 31 : 224 == (240 & r) ? 15 : 7;
                            let o, n = 0;
                            for(; (o = 63 & this.interim[++n]) && n < 4;)r <<= 6, r |= o;
                            const h = 192 == (224 & this.interim[0]) ? 2 : 224 == (240 & this.interim[0]) ? 3 : 4, c = h - n;
                            for(; l < c;){
                                if (l >= i) return 0;
                                if (o = e[l++], 128 != (192 & o)) {
                                    l--, s = !0;
                                    break;
                                }
                                this.interim[n++] = o, r <<= 6, r |= 63 & o;
                            }
                            s || (2 === h ? r < 128 ? l-- : t[a++] = r : 3 === h ? r < 2048 || r >= 55296 && r <= 57343 || 65279 === r || (t[a++] = r) : r < 65536 || r > 1114111 || (t[a++] = r)), this.interim.fill(0);
                        }
                        const c = i - 4;
                        let d = l;
                        for(; d < i;){
                            for(; !(!(d < c) || 128 & (s = e[d]) || 128 & (r = e[d + 1]) || 128 & (o = e[d + 2]) || 128 & (n = e[d + 3]));)t[a++] = s, t[a++] = r, t[a++] = o, t[a++] = n, d += 4;
                            if (s = e[d++], s < 128) t[a++] = s;
                            else if (192 == (224 & s)) {
                                if (d >= i) return this.interim[0] = s, a;
                                if (r = e[d++], 128 != (192 & r)) {
                                    d--;
                                    continue;
                                }
                                if (h = (31 & s) << 6 | 63 & r, h < 128) {
                                    d--;
                                    continue;
                                }
                                t[a++] = h;
                            } else if (224 == (240 & s)) {
                                if (d >= i) return this.interim[0] = s, a;
                                if (r = e[d++], 128 != (192 & r)) {
                                    d--;
                                    continue;
                                }
                                if (d >= i) return this.interim[0] = s, this.interim[1] = r, a;
                                if (o = e[d++], 128 != (192 & o)) {
                                    d--;
                                    continue;
                                }
                                if (h = (15 & s) << 12 | (63 & r) << 6 | 63 & o, h < 2048 || h >= 55296 && h <= 57343 || 65279 === h) continue;
                                t[a++] = h;
                            } else if (240 == (248 & s)) {
                                if (d >= i) return this.interim[0] = s, a;
                                if (r = e[d++], 128 != (192 & r)) {
                                    d--;
                                    continue;
                                }
                                if (d >= i) return this.interim[0] = s, this.interim[1] = r, a;
                                if (o = e[d++], 128 != (192 & o)) {
                                    d--;
                                    continue;
                                }
                                if (d >= i) return this.interim[0] = s, this.interim[1] = r, this.interim[2] = o, a;
                                if (n = e[d++], 128 != (192 & n)) {
                                    d--;
                                    continue;
                                }
                                if (h = (7 & s) << 18 | (63 & r) << 12 | (63 & o) << 6 | 63 & n, h < 65536 || h > 1114111) continue;
                                t[a++] = h;
                            }
                        }
                        return a;
                    }
                };
            }
        }, t = {};
        function i(s) {
            var r = t[s];
            if (void 0 !== r) return r.exports;
            var o = t[s] = {
                exports: {}
            };
            return e[s](o, o.exports, i), o.exports;
        }
        var s = {};
        return (()=>{
            var e = s;
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.WebglAddon = void 0;
            const t = i(345), r = i(859), o = i(399), n = i(666);
            class a extends r.Disposable {
                constructor(e){
                    if (o.isSafari && (0, o.getSafariVersion)() < 16) throw new Error("Webgl2 is only supported on Safari 16 and above");
                    super(), this._preserveDrawingBuffer = e, this._onChangeTextureAtlas = this.register(new t.EventEmitter), this.onChangeTextureAtlas = this._onChangeTextureAtlas.event, this._onAddTextureAtlasCanvas = this.register(new t.EventEmitter), this.onAddTextureAtlasCanvas = this._onAddTextureAtlasCanvas.event, this._onRemoveTextureAtlasCanvas = this.register(new t.EventEmitter), this.onRemoveTextureAtlasCanvas = this._onRemoveTextureAtlasCanvas.event, this._onContextLoss = this.register(new t.EventEmitter), this.onContextLoss = this._onContextLoss.event;
                }
                activate(e) {
                    const i = e._core;
                    if (!e.element) return void this.register(i.onWillOpen(()=>this.activate(e)));
                    this._terminal = e;
                    const s = i.coreService, o = i.optionsService, a = i, h = a._renderService, l = a._characterJoinerService, c = a._charSizeService, d = a._coreBrowserService, _ = a._decorationService, u = a._themeService;
                    this._renderer = this.register(new n.WebglRenderer(e, l, c, d, s, _, o, u, this._preserveDrawingBuffer)), this.register((0, t.forwardEvent)(this._renderer.onContextLoss, this._onContextLoss)), this.register((0, t.forwardEvent)(this._renderer.onChangeTextureAtlas, this._onChangeTextureAtlas)), this.register((0, t.forwardEvent)(this._renderer.onAddTextureAtlasCanvas, this._onAddTextureAtlasCanvas)), this.register((0, t.forwardEvent)(this._renderer.onRemoveTextureAtlasCanvas, this._onRemoveTextureAtlasCanvas)), h.setRenderer(this._renderer), this.register((0, r.toDisposable)(()=>{
                        const t = this._terminal._core._renderService;
                        t.setRenderer(this._terminal._core._createRenderer()), t.handleResize(e.cols, e.rows);
                    }));
                }
                get textureAtlas() {
                    var e;
                    return null === (e = this._renderer) || void 0 === e ? void 0 : e.textureAtlas;
                }
                clearTextureAtlas() {
                    var e;
                    null === (e = this._renderer) || void 0 === e || e.clearTextureAtlas();
                }
            }
            e.WebglAddon = a;
        })(), s;
    })());

},{}]},["igKGj","8lqZg"], "8lqZg", "parcelRequire2a8d")

//# sourceMappingURL=index.975ef6c8.js.map
